import{as as A,at as F,af as c,C as w,y,V as j,w as I,R as _}from"./index-dzV0rMYg.js";import{F as N}from"./flowGraphCachedOperationBlock-BMFXzeZ-.js";const g=new RegExp(/\/\{(\w+)\}(?=\/|$)/g);class V{constructor(r,s){this.path=r,this.ownerBlock=s,this.templatedInputs=[];let n=g.exec(r);const o=new Set;for(;n;){const[,e]=n;if(o.has(e))throw new Error("Duplicate template variable detected.");o.add(e),this.templatedInputs.push(s.registerDataInput(e,A,new F(0))),n=g.exec(r)}}getAccessor(r,s){let n=this.path;for(const o of this.templatedInputs){const e=o.getValue(s).value;if(typeof e!="number"||e<0)throw new Error("Invalid value for templated input.");n=n.replace(`{${o.name}}`,e.toString())}return r.convert(n)}}class D extends N{constructor(r){super(c,r),this.config=r,this.object=this.registerDataOutput("object",c),this.propertyName=this.registerDataOutput("propertyName",c),this.setterFunction=this.registerDataOutput("setFunction",c,this._setPropertyValue.bind(this)),this.getterFunction=this.registerDataOutput("getFunction",c,this._getPropertyValue.bind(this)),this.generateAnimationsFunction=this.registerDataOutput("generateAnimationsFunction",c,this._getInterpolationAnimationPropertyInfo.bind(this)),this.templateComponent=new V(r.jsonPointer,this)}_doOperation(r){const s=this.templateComponent.getAccessor(this.config.pathConverter,r),n=s.info.get(s.object),o=s.info.getTarget?.(s.object),e=s.info.getPropertyName?.[0](s.object);if(o)this.object.setValue(o,r),e&&this.propertyName.setValue(e,r);else throw new Error("Object is undefined");return n}_setPropertyValue(r,s,n,o){const e=this.templateComponent.getAccessor(this.config.pathConverter,o),i=e.info.type;i.startsWith("Color")&&(n=C(n,i)),e.info.set?.(n,e.object)}_getPropertyValue(r,s,n){const o=this.templateComponent.getAccessor(this.config.pathConverter,n),e=o.info.type,i=o.info.get(o.object);return e.startsWith("Color")?G(i):i}_getInterpolationAnimationPropertyInfo(r,s,n){const o=this.templateComponent.getAccessor(this.config.pathConverter,n);return(e,i,b,h)=>{const l=[],m=o.info.type;return m.startsWith("Color")&&(e=e.map(p=>({frame:p.frame,value:C(p.value,m)}))),o.info.interpolation?.forEach((p,f)=>{const d=o.info.getPropertyName?.[f](o.object)||"Animation-interpolation-"+f;let u=e;b!==p.type&&(u=e.map(a=>({frame:a.frame,value:p.getValue(void 0,a.value.asArray?a.value.asArray():[a.value],0,1)})));const P=p.buildAnimations(o.object,d,60,u);for(const a of P)h&&a.babylonAnimation.setEasingFunction(h),l.push(a.babylonAnimation)}),l}}getClassName(){return"FlowGraphJsonPointerParserBlock"}}function C(t,r){return t.getClassName().startsWith("Color")?t:r==="Color3"?new w(t.x,t.y,t.z):r==="Color4"?new y(t.x,t.y,t.z,t.w):t}function G(t){if(t instanceof w)return new j(t.r,t.g,t.b);if(t instanceof y)return new I(t.r,t.g,t.b,t.a);throw new Error("Invalid color type")}_("FlowGraphJsonPointerParserBlock",D);export{D as FlowGraphJsonPointerParserBlock};
