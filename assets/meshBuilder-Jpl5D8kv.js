const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["./color.vertex-Vp-uvC58.js","./index-DHuikXXi.js","./index-BuH4d2kg.css","./vertexColorMixing-DsOWYLga.js","./fogVertex-87q0z6lW.js","./color.fragment-B4-hQLNZ.js","./fogFragment-DO3r2z7_.js","./color.vertex-ENmlZluc.js","./fogVertex-XUmXhuug.js","./vertexColorMixing-D5uLua63.js","./color.fragment-CElMKGuX.js","./fogFragment-GVYXCY3C.js"])))=>i.map(i=>d[i]);
import{M as T,T as rt,b as K,c as U,_ as $t,V as F,d as nt,e as mt,C as Pt,E as It,f as ke,g as Ut,h as pt,i as it,A as Xe,S as te,P as Ze,j as Ge,k as He,l as Ye,m as qe,n as Ke,B as je,o as Qe,p as Je,q as $e,r as ts,s as es,t as zt,u as Kt,Q as ss,W as jt,v as rs,R as is,w as Lt,x as Dt,I as ns,L as ot,y as ee,z as Wt,D as Qt,F as tt,H as Jt,G as as}from"./index-DHuikXXi.js";function se(a){let t=a.pathArray;const e=a.closeArray||!1,s=a.closePath||!1,r=a.invertUV||!1,i=Math.floor(t[0].length/2);let n=a.offset||i;n=n>i?i:Math.floor(n);const c=a.sideOrientation===0?0:a.sideOrientation||U.DEFAULTSIDE,u=a.uvs,x=a.colors,p=[],o=[],h=[],m=[],d=[],A=[],y=[],v=[];let w;const C=[],b=[];let f,_,g;if(t.length<2){const k=[],j=[];for(_=0;_<t[0].length-n;_++)k.push(t[0][_]),j.push(t[0][_+n]);t=[k,j]}let P=0;const D=s?1:0,V=e?1:0;let M,L;w=t[0].length;let R,q;for(f=0;f<t.length+V;f++){for(y[f]=0,d[f]=[0],M=f===t.length?t[0]:t[f],L=M.length,w=w<L?w:L,g=0;g<L;)p.push(M[g].x,M[g].y,M[g].z),g>0&&(R=M[g].subtract(M[g-1]).length(),q=R+y[f],d[f].push(q),y[f]=q),g++;s&&(g--,p.push(M[0].x,M[0].y,M[0].z),R=M[g].subtract(M[0]).length(),q=R+y[f],d[f].push(q),y[f]=q),C[f]=L+D,b[f]=P,P+=L+D}let W,Y,N=null,X=null;for(_=0;_<w+D;_++)for(v[_]=0,A[_]=[0],f=0;f<t.length-1+V;f++)W=t[f],Y=f===t.length-1?t[0]:t[f+1],_===w?(N=W[0],X=Y[0]):(N=W[_],X=Y[_]),R=X.subtract(N).length(),q=R+v[_],A[_].push(q),v[_]=q;let B,E;if(u)for(f=0;f<u.length;f++)m.push(u[f].x,u[f].y);else for(f=0;f<t.length+V;f++)for(_=0;_<w+D;_++)B=y[f]!=0?d[f][_]/y[f]:0,E=v[_]!=0?A[_][f]/v[_]:0,r?m.push(E,B):m.push(B,E);f=0;let l=0,O=C[f]-1,I=C[f+1]-1,S=O<I?O:I,Z=b[1]-b[0];const z=C.length-1;for(;l<=S&&f<z;)o.push(l,l+Z,l+1),o.push(l+Z+1,l+1,l+Z),l+=1,l===S&&(f++,Z=b[f+1]-b[f],O=C[f]-1,I=C[f+1]-1,l=b[f],S=O<I?O+l:I+l);if(U.ComputeNormals(p,o,h),s){let k=0,j=0;for(f=0;f<t.length;f++){k=b[f]*3,f+1<t.length?j=(b[f+1]-1)*3:j=h.length-3,h[k]=(h[k]+h[j])*.5,h[k+1]=(h[k+1]+h[j+1])*.5,h[k+2]=(h[k+2]+h[j+2])*.5;const G=Math.sqrt(h[k]*h[k]+h[k+1]*h[k+1]+h[k+2]*h[k+2]);h[k]/=G,h[k+1]/=G,h[k+2]/=G,h[j]=h[k],h[j+1]=h[k+1],h[j+2]=h[k+2]}}if(e){let k=b[0]*3,j=b[t.length]*3;for(_=0;_<w+D;_++){h[k]=(h[k]+h[j])*.5,h[k+1]=(h[k+1]+h[j+1])*.5,h[k+2]=(h[k+2]+h[j+2])*.5;const G=Math.sqrt(h[k]*h[k]+h[k+1]*h[k+1]+h[k+2]*h[k+2]);h[k]/=G,h[k+1]/=G,h[k+2]/=G,h[j]=h[k],h[j+1]=h[k+1],h[j+2]=h[k+2],k+=3,j+=3}}U._ComputeSides(c,p,o,h,m,a.frontUVs,a.backUVs);let H=null;if(x){H=new Float32Array(x.length*4);for(let k=0;k<x.length;k++)H[k*4]=x[k].r,H[k*4+1]=x[k].g,H[k*4+2]=x[k].b,H[k*4+3]=x[k].a}const Q=new U,et=new Float32Array(p),$=new Float32Array(h),st=new Float32Array(m);return Q.indices=o,Q.positions=et,Q.normals=$,Q.uvs=st,H&&Q.set(H,K.ColorKind),s&&(Q._idx=b),Q}function _t(a,t,e=null){const s=t.pathArray,r=t.closeArray,i=t.closePath,n=T._GetDefaultSideOrientation(t.sideOrientation),c=t.instance,u=t.updatable;if(c){const x=rt.Vector3[0].setAll(Number.MAX_VALUE),p=rt.Vector3[1].setAll(-Number.MAX_VALUE),o=m=>{let d=s[0].length;const A=c;let y=0;const v=A._originalBuilderSideOrientation===T.DOUBLESIDE?2:1;for(let w=1;w<=v;++w)for(let C=0;C<s.length;++C){const b=s[C],f=b.length;d=d<f?d:f;for(let _=0;_<d;++_){const g=b[_];m[y]=g.x,m[y+1]=g.y,m[y+2]=g.z,x.minimizeInPlaceFromFloats(g.x,g.y,g.z),p.maximizeInPlaceFromFloats(g.x,g.y,g.z),y+=3}if(A._creationDataStorage&&A._creationDataStorage.closePath){const _=b[0];m[y]=_.x,m[y+1]=_.y,m[y+2]=_.z,y+=3}}},h=c.getVerticesData(K.PositionKind);if(o(h),c.hasBoundingInfo?c.getBoundingInfo().reConstruct(x,p,c._worldMatrix):c.buildBoundingInfo(x,p,c._worldMatrix),c.updateVerticesData(K.PositionKind,h,!1,!1),t.colors){const m=c.getVerticesData(K.ColorKind);for(let d=0,A=0;d<t.colors.length;d++,A+=4){const y=t.colors[d];m[A]=y.r,m[A+1]=y.g,m[A+2]=y.b,m[A+3]=y.a}c.updateVerticesData(K.ColorKind,m,!1,!1)}if(t.uvs){const m=c.getVerticesData(K.UVKind);for(let d=0;d<t.uvs.length;d++)m[d*2]=t.uvs[d].x,m[d*2+1]=t.uvs[d].y;c.updateVerticesData(K.UVKind,m,!1,!1)}if(!c.areNormalsFrozen||c.isFacetDataEnabled){const m=c.getIndices(),d=c.getVerticesData(K.NormalKind),A=c.isFacetDataEnabled?c.getFacetDataParameters():null;if(U.ComputeNormals(h,m,d,A),c._creationDataStorage&&c._creationDataStorage.closePath){let y=0,v=0;for(let w=0;w<s.length;w++)y=c._creationDataStorage.idx[w]*3,w+1<s.length?v=(c._creationDataStorage.idx[w+1]-1)*3:v=d.length-3,d[y]=(d[y]+d[v])*.5,d[y+1]=(d[y+1]+d[v+1])*.5,d[y+2]=(d[y+2]+d[v+2])*.5,d[v]=d[y],d[v+1]=d[y+1],d[v+2]=d[y+2]}c.areNormalsFrozen||c.updateVerticesData(K.NormalKind,d,!1,!1)}return c}else{const x=new T(a,e);x._originalBuilderSideOrientation=n,x._creationDataStorage=new $t;const p=se(t);return i&&(x._creationDataStorage.idx=p._idx),x._creationDataStorage.closePath=i,x._creationDataStorage.closeArray=r,p.applyToMesh(x,u),x}}U.CreateRibbon=se;T.CreateRibbon=(a,t,e=!1,s,r,i,n=!1,c,u)=>_t(a,{pathArray:t,closeArray:e,closePath:s,offset:r,updatable:n,sideOrientation:c,instance:u},i);function re(a){const t=[],e=[],s=[],r=[],i=a.radius||.5,n=a.tessellation||64,c=a.arc&&(a.arc<=0||a.arc>1)?1:a.arc||1,u=a.sideOrientation===0?0:a.sideOrientation||U.DEFAULTSIDE;t.push(0,0,0),r.push(.5,.5);const x=Math.PI*2*c,p=c===1?x/n:x/(n-1);let o=0;for(let d=0;d<n;d++){const A=Math.cos(o),y=Math.sin(o),v=(A+1)/2,w=(1-y)/2;t.push(i*A,i*y,0),r.push(v,w),o+=p}c===1&&(t.push(t[3],t[4],t[5]),r.push(r[2],r[3]));const h=t.length/3;for(let d=1;d<h-1;d++)e.push(d+1,0,d);U.ComputeNormals(t,e,s),U._ComputeSides(u,t,e,s,r,a.frontUVs,a.backUVs);const m=new U;return m.indices=e,m.positions=t,m.normals=s,m.uvs=r,m}function ie(a,t={},e=null){const s=new T(a,e);return t.sideOrientation=T._GetDefaultSideOrientation(t.sideOrientation),s._originalBuilderSideOrientation=t.sideOrientation,re(t).applyToMesh(s,t.updatable),s}U.CreateDisc=re;T.CreateDisc=(a,t,e,s=null,r,i)=>ie(a,{radius:t,tessellation:e,sideOrientation:i,updatable:r},s);T._GroundMeshParser=(a,t)=>wt.Parse(a,t);class wt extends T{constructor(t,e){super(t,e),this.generateOctree=!1}getClassName(){return"GroundMesh"}get subdivisions(){return Math.min(this._subdivisionsX,this._subdivisionsY)}get subdivisionsX(){return this._subdivisionsX}get subdivisionsY(){return this._subdivisionsY}optimize(t,e=32){this._subdivisionsX=t,this._subdivisionsY=t,this.subdivide(t);const s=this;s.createOrUpdateSubmeshesOctree&&s.createOrUpdateSubmeshesOctree(e)}getHeightAtCoordinates(t,e){const s=this.getWorldMatrix(),r=rt.Matrix[5];s.invertToRef(r);const i=rt.Vector3[8];if(F.TransformCoordinatesFromFloatsToRef(t,0,e,r,i),t=i.x,e=i.z,t<this._minX||t>=this._maxX||e<=this._minZ||e>this._maxZ)return this.position.y;(!this._heightQuads||this._heightQuads.length==0)&&(this._initHeightQuads(),this._computeHeightQuads());const n=this._getFacetAt(t,e),c=-(n.x*t+n.z*e+n.w)/n.y;return F.TransformCoordinatesFromFloatsToRef(0,c,0,s,i),i.y}getNormalAtCoordinates(t,e){const s=new F(0,1,0);return this.getNormalAtCoordinatesToRef(t,e,s),s}getNormalAtCoordinatesToRef(t,e,s){const r=this.getWorldMatrix(),i=rt.Matrix[5];r.invertToRef(i);const n=rt.Vector3[8];if(F.TransformCoordinatesFromFloatsToRef(t,0,e,i,n),t=n.x,e=n.z,t<this._minX||t>this._maxX||e<this._minZ||e>this._maxZ)return this;(!this._heightQuads||this._heightQuads.length==0)&&(this._initHeightQuads(),this._computeHeightQuads());const c=this._getFacetAt(t,e);return F.TransformNormalFromFloatsToRef(c.x,c.y,c.z,r,s),this}updateCoordinateHeights(){return(!this._heightQuads||this._heightQuads.length==0)&&this._initHeightQuads(),this._computeHeightQuads(),this}_getFacetAt(t,e){const s=Math.floor((t+this._maxX)*this._subdivisionsX/this._width),r=Math.floor(-(e+this._maxZ)*this._subdivisionsY/this._height+this._subdivisionsY),i=this._heightQuads[r*this._subdivisionsX+s];let n;return e<i.slope.x*t+i.slope.y?n=i.facet1:n=i.facet2,n}_initHeightQuads(){const t=this._subdivisionsX,e=this._subdivisionsY;this._heightQuads=[];for(let s=0;s<e;s++)for(let r=0;r<t;r++){const i={slope:nt.Zero(),facet1:new mt(0,0,0,0),facet2:new mt(0,0,0,0)};this._heightQuads[s*t+r]=i}return this}_computeHeightQuads(){const t=this.getVerticesData(K.PositionKind);if(!t)return this;const e=rt.Vector3[3],s=rt.Vector3[2],r=rt.Vector3[1],i=rt.Vector3[0],n=rt.Vector3[4],c=rt.Vector3[5],u=rt.Vector3[6],x=rt.Vector3[7],p=rt.Vector3[8];let o=0,h=0,m=0,d=0,A=0,y=0,v=0;const w=this._subdivisionsX,C=this._subdivisionsY;for(let b=0;b<C;b++)for(let f=0;f<w;f++){o=f*3,h=b*(w+1)*3,m=(b+1)*(w+1)*3,e.x=t[h+o],e.y=t[h+o+1],e.z=t[h+o+2],s.x=t[h+o+3],s.y=t[h+o+4],s.z=t[h+o+5],r.x=t[m+o],r.y=t[m+o+1],r.z=t[m+o+2],i.x=t[m+o+3],i.y=t[m+o+4],i.z=t[m+o+5],d=(i.z-e.z)/(i.x-e.x),A=e.z-d*e.x,s.subtractToRef(e,n),r.subtractToRef(e,c),i.subtractToRef(e,u),F.CrossToRef(u,c,x),F.CrossToRef(n,u,p),x.normalize(),p.normalize(),y=-(x.x*e.x+x.y*e.y+x.z*e.z),v=-(p.x*s.x+p.y*s.y+p.z*s.z);const _=this._heightQuads[b*w+f];_.slope.copyFromFloats(d,A),_.facet1.copyFromFloats(x.x,x.y,x.z,y),_.facet2.copyFromFloats(p.x,p.y,p.z,v)}return this}serialize(t){super.serialize(t),t.subdivisionsX=this._subdivisionsX,t.subdivisionsY=this._subdivisionsY,t.minX=this._minX,t.maxX=this._maxX,t.minZ=this._minZ,t.maxZ=this._maxZ,t.width=this._width,t.height=this._height}static Parse(t,e){const s=new wt(t.name,e);return s._subdivisionsX=t.subdivisionsX||1,s._subdivisionsY=t.subdivisionsY||1,s._minX=t.minX,s._maxX=t.maxX,s._minZ=t.minZ,s._maxZ=t.maxZ,s._width=t.width,s._height=t.height,s}}function ne(a){const t=[],e=[],s=[],r=[];let i,n;const c=a.width||a.size||1,u=a.height||a.size||1,x=(a.subdivisionsX||a.subdivisions||1)|0,p=(a.subdivisionsY||a.subdivisions||1)|0;for(i=0;i<=p;i++)for(n=0;n<=x;n++){const h=new F(n*c/x-c/2,0,(p-i)*u/p-u/2),m=new F(0,1,0);e.push(h.x,h.y,h.z),s.push(m.x,m.y,m.z),r.push(n/x,1-i/p)}for(i=0;i<p;i++)for(n=0;n<x;n++)t.push(n+1+(i+1)*(x+1)),t.push(n+1+i*(x+1)),t.push(n+i*(x+1)),t.push(n+(i+1)*(x+1)),t.push(n+1+(i+1)*(x+1)),t.push(n+i*(x+1));const o=new U;return o.indices=t,o.positions=e,o.normals=s,o.uvs=r,o}function ae(a){const t=a.xmin!==void 0&&a.xmin!==null?a.xmin:-1,e=a.zmin!==void 0&&a.zmin!==null?a.zmin:-1,s=a.xmax!==void 0&&a.xmax!==null?a.xmax:1,r=a.zmax!==void 0&&a.zmax!==null?a.zmax:1,i=a.subdivisions||{w:1,h:1},n=a.precision||{w:1,h:1},c=[],u=[],x=[],p=[];let o,h,m,d;i.h=i.h<1?1:i.h,i.w=i.w<1?1:i.w,n.w=n.w<1?1:n.w,n.h=n.h<1?1:n.h;const A={w:(s-t)/i.w,h:(r-e)/i.h};function y(w,C,b,f){const _=u.length/3,g=n.w+1;for(o=0;o<n.h;o++)for(h=0;h<n.w;h++){const V=[_+h+o*g,_+(h+1)+o*g,_+(h+1)+(o+1)*g,_+h+(o+1)*g];c.push(V[1]),c.push(V[2]),c.push(V[3]),c.push(V[0]),c.push(V[1]),c.push(V[3])}const P=F.Zero(),D=new F(0,1,0);for(o=0;o<=n.h;o++)for(P.z=o*(f-C)/n.h+C,h=0;h<=n.w;h++)P.x=h*(b-w)/n.w+w,P.y=0,u.push(P.x,P.y,P.z),x.push(D.x,D.y,D.z),p.push(h/n.w,o/n.h)}for(m=0;m<i.h;m++)for(d=0;d<i.w;d++)y(t+d*A.w,e+m*A.h,t+(d+1)*A.w,e+(m+1)*A.h);const v=new U;return v.indices=c,v.positions=u,v.normals=x,v.uvs=p,v}function oe(a){const t=[],e=[],s=[],r=[];let i,n;const c=a.colorFilter||new Pt(.3,.59,.11),u=a.alphaFilter||0;let x=!1;if(a.minHeight>a.maxHeight){x=!0;const o=a.maxHeight;a.maxHeight=a.minHeight,a.minHeight=o}for(i=0;i<=a.subdivisions;i++)for(n=0;n<=a.subdivisions;n++){const o=new F(n*a.width/a.subdivisions-a.width/2,0,(a.subdivisions-i)*a.height/a.subdivisions-a.height/2),h=(o.x+a.width/2)/a.width*(a.bufferWidth-1)|0,m=(1-(o.z+a.height/2)/a.height)*(a.bufferHeight-1)|0,d=(h+m*a.bufferWidth)*4;let A=a.buffer[d]/255,y=a.buffer[d+1]/255,v=a.buffer[d+2]/255;const w=a.buffer[d+3]/255;x&&(A=1-A,y=1-y,v=1-v);const C=A*c.r+y*c.g+v*c.b;w>=u?o.y=a.minHeight+(a.maxHeight-a.minHeight)*C:o.y=a.minHeight-Ut,a.heightBuffer&&(a.heightBuffer[i*(a.subdivisions+1)+n]=o.y),e.push(o.x,o.y,o.z),s.push(0,0,0),r.push(n/a.subdivisions,1-i/a.subdivisions)}for(i=0;i<a.subdivisions;i++)for(n=0;n<a.subdivisions;n++){const o=n+1+(i+1)*(a.subdivisions+1),h=n+1+i*(a.subdivisions+1),m=n+i*(a.subdivisions+1),d=n+(i+1)*(a.subdivisions+1),A=e[o*3+1]>=a.minHeight,y=e[h*3+1]>=a.minHeight,v=e[m*3+1]>=a.minHeight;A&&y&&v&&(t.push(o),t.push(h),t.push(m)),e[d*3+1]>=a.minHeight&&A&&v&&(t.push(d),t.push(o),t.push(m))}U.ComputeNormals(e,t,s);const p=new U;return p.indices=t,p.positions=e,p.normals=s,p.uvs=r,p}function ce(a,t={},e){const s=new wt(a,e);return s._setReady(!1),s._subdivisionsX=t.subdivisionsX||t.subdivisions||1,s._subdivisionsY=t.subdivisionsY||t.subdivisions||1,s._width=t.width||1,s._height=t.height||1,s._maxX=s._width/2,s._maxZ=s._height/2,s._minX=-s._maxX,s._minZ=-s._maxZ,ne(t).applyToMesh(s,t.updatable),s._setReady(!0),s}function le(a,t,e=null){const s=new T(a,e);return ae(t).applyToMesh(s,t.updatable),s}function he(a,t,e={},s=null){const r=e.width||10,i=e.height||10,n=e.subdivisions||1,c=e.minHeight||0,u=e.maxHeight||1,x=e.colorFilter||new Pt(.3,.59,.11),p=e.alphaFilter||0,o=e.updatable,h=e.onReady;s=s||It.LastCreatedScene;const m=new wt(a,s);m._subdivisionsX=n,m._subdivisionsY=n,m._width=r,m._height=i,m._maxX=m._width/2,m._maxZ=m._height/2,m._minX=-m._maxX,m._minZ=-m._maxZ,m._setReady(!1);let d;e.passHeightBufferInCallback&&(d=new Float32Array((n+1)*(n+1)));const A=(y,v,w)=>{oe({width:r,height:i,subdivisions:n,minHeight:c,maxHeight:u,colorFilter:x,buffer:y,bufferWidth:v,bufferHeight:w,alphaFilter:p,heightBuffer:d}).applyToMesh(m,o),h&&h(m,d),m._setReady(!0)};if(typeof t=="string"){const y=v=>{const w=v.width,C=v.height;if(s.isDisposed)return;const b=s?.getEngine().resizeImageBitmap(v,w,C);A(b,w,C)};ke.LoadImage(t,y,e.onError?e.onError:()=>{},s.offlineProvider)}else A(t.data,t.width,t.height);return m}U.CreateGround=ne;U.CreateTiledGround=ae;U.CreateGroundFromHeightMap=oe;T.CreateGround=(a,t,e,s,r,i)=>ce(a,{width:t,height:e,subdivisions:s,updatable:i},r);T.CreateTiledGround=(a,t,e,s,r,i,n,c,u)=>le(a,{xmin:t,zmin:e,xmax:s,zmax:r,subdivisions:i,precision:n,updatable:u},c);T.CreateGroundFromHeightMap=(a,t,e,s,r,i,n,c,u,x,p)=>he(a,t,{width:e,height:s,subdivisions:r,minHeight:i,maxHeight:n,updatable:u,onReady:x,alphaFilter:p},c);function ue(a){let e=[0,1,2,0,2,3,4,5,6,4,6,7,8,9,10,8,10,11,12,13,14,12,14,15,16,17,18,16,18,19,20,21,22,20,22,23];const s=[0,0,1,0,0,1,0,0,1,0,0,1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,1,0,0,1,0,0,1,0,0,1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,0,1,0,0,1,0,0,1,0,0,1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0],r=[];let i=[];const n=a.width||a.size||1,c=a.height||a.size||1,u=a.depth||a.size||1,x=a.wrap||!1;let p=a.topBaseAt===void 0?1:a.topBaseAt,o=a.bottomBaseAt===void 0?0:a.bottomBaseAt;p=(p+4)%4,o=(o+4)%4;const h=[2,0,3,1],m=[2,0,1,3];let d=h[p],A=m[o],y=[1,-1,1,-1,-1,1,-1,1,1,1,1,1,1,1,-1,-1,1,-1,-1,-1,-1,1,-1,-1,1,1,-1,1,-1,-1,1,-1,1,1,1,1,-1,1,1,-1,-1,1,-1,-1,-1,-1,1,-1,-1,1,1,-1,1,-1,1,1,-1,1,1,1,1,-1,1,1,-1,-1,-1,-1,-1,-1,-1,1];if(x){e=[2,3,0,2,0,1,4,5,6,4,6,7,9,10,11,9,11,8,12,14,15,12,13,14],y=[-1,1,1,1,1,1,1,-1,1,-1,-1,1,1,1,-1,-1,1,-1,-1,-1,-1,1,-1,-1,1,1,1,1,1,-1,1,-1,-1,1,-1,1,-1,1,-1,-1,1,1,-1,-1,1,-1,-1,-1];let g=[[1,1,1],[-1,1,1],[-1,1,-1],[1,1,-1]],P=[[-1,-1,1],[1,-1,1],[1,-1,-1],[-1,-1,-1]];const D=[17,18,19,16],V=[22,23,20,21];for(;d>0;)g.unshift(g.pop()),D.unshift(D.pop()),d--;for(;A>0;)P.unshift(P.pop()),V.unshift(V.pop()),A--;g=g.flat(),P=P.flat(),y=y.concat(g).concat(P),e.push(D[0],D[2],D[3],D[0],D[1],D[2]),e.push(V[0],V[2],V[3],V[0],V[1],V[2])}const v=[n/2,c/2,u/2];i=y.reduce((g,P,D)=>g.concat(P*v[D%3]),[]);const w=a.sideOrientation===0?0:a.sideOrientation||U.DEFAULTSIDE,C=a.faceUV||new Array(6),b=a.faceColors,f=[];for(let g=0;g<6;g++)C[g]===void 0&&(C[g]=new mt(0,0,1,1)),b&&b[g]===void 0&&(b[g]=new pt(1,1,1,1));for(let g=0;g<6;g++)if(r.push(C[g].z,C[g].w),r.push(C[g].x,C[g].w),r.push(C[g].x,C[g].y),r.push(C[g].z,C[g].y),b)for(let P=0;P<4;P++)f.push(b[g].r,b[g].g,b[g].b,b[g].a);U._ComputeSides(w,i,e,s,r,a.frontUVs,a.backUVs);const _=new U;if(_.indices=e,_.positions=i,_.normals=s,_.uvs=r,b){const g=w===U.DOUBLESIDE?f.concat(f):f;_.colors=g}return _}function fe(a,t={},e=null){const s=new T(a,e);return t.sideOrientation=T._GetDefaultSideOrientation(t.sideOrientation),s._originalBuilderSideOrientation=t.sideOrientation,ue(t).applyToMesh(s,t.updatable),s}U.CreateBox=ue;T.CreateBox=(a,t,e=null,s,r)=>fe(a,{size:t,sideOrientation:r,updatable:s},e);function Tt(a){const t=a.pattern||T.NO_FLIP,e=a.tileWidth||a.tileSize||1,s=a.tileHeight||a.tileSize||1,r=a.alignHorizontal||0,i=a.alignVertical||0,n=a.width||a.size||1,c=Math.floor(n/e);let u=n-c*e;const x=a.height||a.size||1,p=Math.floor(x/s);let o=x-p*s;const h=e*c/2,m=s*p/2;let d=0,A=0,y=0,v=0,w=0,C=0;if(u>0||o>0){switch(y=-h,v=-m,w=h,C=m,r){case T.CENTER:u/=2,y-=u,w+=u;break;case T.LEFT:w+=u,d=-u/2;break;case T.RIGHT:y-=u,d=u/2;break}switch(i){case T.CENTER:o/=2,v-=o,C+=o;break;case T.BOTTOM:C+=o,A=-o/2;break;case T.TOP:v-=o,A=o/2;break}}const b=[],f=[],_=[];_[0]=[0,0,1,0,1,1,0,1],_[1]=[0,0,1,0,1,1,0,1],(t===T.ROTATE_TILE||t===T.ROTATE_ROW)&&(_[1]=[1,1,0,1,0,0,1,0]),(t===T.FLIP_TILE||t===T.FLIP_ROW)&&(_[1]=[1,0,0,0,0,1,1,1]),(t===T.FLIP_N_ROTATE_TILE||t===T.FLIP_N_ROTATE_ROW)&&(_[1]=[0,1,1,1,1,0,0,0]);let g=[];const P=[],D=[];let V=0;for(let q=0;q<p;q++)for(let W=0;W<c;W++)b.push(-h+W*e+d,-m+q*s+A,0),b.push(-h+(W+1)*e+d,-m+q*s+A,0),b.push(-h+(W+1)*e+d,-m+(q+1)*s+A,0),b.push(-h+W*e+d,-m+(q+1)*s+A,0),D.push(V,V+1,V+3,V+1,V+2,V+3),t===T.FLIP_TILE||t===T.ROTATE_TILE||t===T.FLIP_N_ROTATE_TILE?g=g.concat(_[(W%2+q%2)%2]):t===T.FLIP_ROW||t===T.ROTATE_ROW||t===T.FLIP_N_ROTATE_ROW?g=g.concat(_[q%2]):g=g.concat(_[0]),P.push(1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1),f.push(0,0,-1,0,0,-1,0,0,-1,0,0,-1),V+=4;if(u>0||o>0){const q=o>0&&(i===T.CENTER||i===T.TOP),W=o>0&&(i===T.CENTER||i===T.BOTTOM),Y=u>0&&(r===T.CENTER||r===T.RIGHT),N=u>0&&(r===T.CENTER||r===T.LEFT);let X=[],B,E,l,O;if(q&&Y&&(b.push(y+d,v+A,0),b.push(-h+d,v+A,0),b.push(-h+d,v+o+A,0),b.push(y+d,v+o+A,0),D.push(V,V+1,V+3,V+1,V+2,V+3),V+=4,B=1-u/e,E=1-o/s,l=1,O=1,X=[B,E,l,E,l,O,B,O],t===T.ROTATE_ROW&&(X=[1-B,1-E,1-l,1-E,1-l,1-O,1-B,1-O]),t===T.FLIP_ROW&&(X=[1-B,E,1-l,E,1-l,O,1-B,O]),t===T.FLIP_N_ROTATE_ROW&&(X=[B,1-E,l,1-E,l,1-O,B,1-O]),g=g.concat(X),P.push(1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1),f.push(0,0,-1,0,0,-1,0,0,-1,0,0,-1)),q&&N&&(b.push(h+d,v+A,0),b.push(w+d,v+A,0),b.push(w+d,v+o+A,0),b.push(h+d,v+o+A,0),D.push(V,V+1,V+3,V+1,V+2,V+3),V+=4,B=0,E=1-o/s,l=u/e,O=1,X=[B,E,l,E,l,O,B,O],(t===T.ROTATE_ROW||t===T.ROTATE_TILE&&c%2===0)&&(X=[1-B,1-E,1-l,1-E,1-l,1-O,1-B,1-O]),(t===T.FLIP_ROW||t===T.FLIP_TILE&&c%2===0)&&(X=[1-B,E,1-l,E,1-l,O,1-B,O]),(t===T.FLIP_N_ROTATE_ROW||t===T.FLIP_N_ROTATE_TILE&&c%2===0)&&(X=[B,1-E,l,1-E,l,1-O,B,1-O]),g=g.concat(X),P.push(1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1),f.push(0,0,-1,0,0,-1,0,0,-1,0,0,-1)),W&&Y&&(b.push(y+d,m+A,0),b.push(-h+d,m+A,0),b.push(-h+d,C+A,0),b.push(y+d,C+A,0),D.push(V,V+1,V+3,V+1,V+2,V+3),V+=4,B=1-u/e,E=0,l=1,O=o/s,X=[B,E,l,E,l,O,B,O],(t===T.ROTATE_ROW&&p%2===1||t===T.ROTATE_TILE&&p%1===0)&&(X=[1-B,1-E,1-l,1-E,1-l,1-O,1-B,1-O]),(t===T.FLIP_ROW&&p%2===1||t===T.FLIP_TILE&&p%2===0)&&(X=[1-B,E,1-l,E,1-l,O,1-B,O]),(t===T.FLIP_N_ROTATE_ROW&&p%2===1||t===T.FLIP_N_ROTATE_TILE&&p%2===0)&&(X=[B,1-E,l,1-E,l,1-O,B,1-O]),g=g.concat(X),P.push(1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1),f.push(0,0,-1,0,0,-1,0,0,-1,0,0,-1)),W&&N&&(b.push(h+d,m+A,0),b.push(w+d,m+A,0),b.push(w+d,C+A,0),b.push(h+d,C+A,0),D.push(V,V+1,V+3,V+1,V+2,V+3),V+=4,B=0,E=0,l=u/e,O=o/s,X=[B,E,l,E,l,O,B,O],(t===T.ROTATE_ROW&&p%2===1||t===T.ROTATE_TILE&&(p+c)%2===1)&&(X=[1-B,1-E,1-l,1-E,1-l,1-O,1-B,1-O]),(t===T.FLIP_ROW&&p%2===1||t===T.FLIP_TILE&&(p+c)%2===1)&&(X=[1-B,E,1-l,E,1-l,O,1-B,O]),(t===T.FLIP_N_ROTATE_ROW&&p%2===1||t===T.FLIP_N_ROTATE_TILE&&(p+c)%2===1)&&(X=[B,1-E,l,1-E,l,1-O,B,1-O]),g=g.concat(X),P.push(1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1),f.push(0,0,-1,0,0,-1,0,0,-1,0,0,-1)),q){const I=[];B=0,E=1-o/s,l=1,O=1,I[0]=[B,E,l,E,l,O,B,O],I[1]=[B,E,l,E,l,O,B,O],(t===T.ROTATE_TILE||t===T.ROTATE_ROW)&&(I[1]=[1-B,1-E,1-l,1-E,1-l,1-O,1-B,1-O]),(t===T.FLIP_TILE||t===T.FLIP_ROW)&&(I[1]=[1-B,E,1-l,E,1-l,O,1-B,O]),(t===T.FLIP_N_ROTATE_TILE||t===T.FLIP_N_ROTATE_ROW)&&(I[1]=[B,1-E,l,1-E,l,1-O,B,1-O]);for(let S=0;S<c;S++)b.push(-h+S*e+d,v+A,0),b.push(-h+(S+1)*e+d,v+A,0),b.push(-h+(S+1)*e+d,v+o+A,0),b.push(-h+S*e+d,v+o+A,0),D.push(V,V+1,V+3,V+1,V+2,V+3),V+=4,t===T.FLIP_TILE||t===T.ROTATE_TILE||t===T.FLIP_N_ROTATE_TILE?g=g.concat(I[(S+1)%2]):t===T.FLIP_ROW||t===T.ROTATE_ROW||t===T.FLIP_N_ROTATE_ROW?g=g.concat(I[1]):g=g.concat(I[0]),P.push(1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1),f.push(0,0,-1,0,0,-1,0,0,-1,0,0,-1)}if(W){const I=[];B=0,E=0,l=1,O=o/s,I[0]=[B,E,l,E,l,O,B,O],I[1]=[B,E,l,E,l,O,B,O],(t===T.ROTATE_TILE||t===T.ROTATE_ROW)&&(I[1]=[1-B,1-E,1-l,1-E,1-l,1-O,1-B,1-O]),(t===T.FLIP_TILE||t===T.FLIP_ROW)&&(I[1]=[1-B,E,1-l,E,1-l,O,1-B,O]),(t===T.FLIP_N_ROTATE_TILE||t===T.FLIP_N_ROTATE_ROW)&&(I[1]=[B,1-E,l,1-E,l,1-O,B,1-O]);for(let S=0;S<c;S++)b.push(-h+S*e+d,C-o+A,0),b.push(-h+(S+1)*e+d,C-o+A,0),b.push(-h+(S+1)*e+d,C+A,0),b.push(-h+S*e+d,C+A,0),D.push(V,V+1,V+3,V+1,V+2,V+3),V+=4,t===T.FLIP_TILE||t===T.ROTATE_TILE||t===T.FLIP_N_ROTATE_TILE?g=g.concat(I[(S+p)%2]):t===T.FLIP_ROW||t===T.ROTATE_ROW||t===T.FLIP_N_ROTATE_ROW?g=g.concat(I[p%2]):g=g.concat(I[0]),P.push(1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1),f.push(0,0,-1,0,0,-1,0,0,-1,0,0,-1)}if(Y){const I=[];B=1-u/e,E=0,l=1,O=1,I[0]=[B,E,l,E,l,O,B,O],I[1]=[B,E,l,E,l,O,B,O],(t===T.ROTATE_TILE||t===T.ROTATE_ROW)&&(I[1]=[1-B,1-E,1-l,1-E,1-l,1-O,1-B,1-O]),(t===T.FLIP_TILE||t===T.FLIP_ROW)&&(I[1]=[1-B,E,1-l,E,1-l,O,1-B,O]),(t===T.FLIP_N_ROTATE_TILE||t===T.FLIP_N_ROTATE_ROW)&&(I[1]=[B,1-E,l,1-E,l,1-O,B,1-O]);for(let S=0;S<p;S++)b.push(y+d,-m+S*s+A,0),b.push(y+u+d,-m+S*s+A,0),b.push(y+u+d,-m+(S+1)*s+A,0),b.push(y+d,-m+(S+1)*s+A,0),D.push(V,V+1,V+3,V+1,V+2,V+3),V+=4,t===T.FLIP_TILE||t===T.ROTATE_TILE||t===T.FLIP_N_ROTATE_TILE?g=g.concat(I[(S+1)%2]):t===T.FLIP_ROW||t===T.ROTATE_ROW||t===T.FLIP_N_ROTATE_ROW?g=g.concat(I[S%2]):g=g.concat(I[0]),P.push(1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1),f.push(0,0,-1,0,0,-1,0,0,-1,0,0,-1)}if(N){const I=[];B=0,E=0,l=u/s,O=1,I[0]=[B,E,l,E,l,O,B,O],I[1]=[B,E,l,E,l,O,B,O],(t===T.ROTATE_TILE||t===T.ROTATE_ROW)&&(I[1]=[1-B,1-E,1-l,1-E,1-l,1-O,1-B,1-O]),(t===T.FLIP_TILE||t===T.FLIP_ROW)&&(I[1]=[1-B,E,1-l,E,1-l,O,1-B,O]),(t===T.FLIP_N_ROTATE_TILE||t===T.FLIP_N_ROTATE_ROW)&&(I[1]=[B,1-E,l,1-E,l,1-O,B,1-O]);for(let S=0;S<p;S++)b.push(w-u+d,-m+S*s+A,0),b.push(w+d,-m+S*s+A,0),b.push(w+d,-m+(S+1)*s+A,0),b.push(w-u+d,-m+(S+1)*s+A,0),D.push(V,V+1,V+3,V+1,V+2,V+3),V+=4,t===T.FLIP_TILE||t===T.ROTATE_TILE||t===T.FLIP_N_ROTATE_TILE?g=g.concat(I[(S+c)%2]):t===T.FLIP_ROW||t===T.ROTATE_ROW||t===T.FLIP_N_ROTATE_ROW?g=g.concat(I[S%2]):g=g.concat(I[0]),P.push(1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1),f.push(0,0,-1,0,0,-1,0,0,-1,0,0,-1)}}const M=a.sideOrientation===0?0:a.sideOrientation||U.DEFAULTSIDE;U._ComputeSides(M,b,D,f,g,a.frontUVs,a.backUVs);const L=new U;L.indices=D,L.positions=b,L.normals=f,L.uvs=g;const R=M===U.DOUBLESIDE?P.concat(P):P;return L.colors=R,L}function os(a,t,e=null){const s=new T(a,e);return t.sideOrientation=T._GetDefaultSideOrientation(t.sideOrientation),s._originalBuilderSideOrientation=t.sideOrientation,Tt(t).applyToMesh(s,t.updatable),s}U.CreateTiledPlane=Tt;function de(a){const e=a.faceUV||new Array(6),s=a.faceColors,r=a.pattern||T.NO_FLIP,i=a.width||a.size||1,n=a.height||a.size||1,c=a.depth||a.size||1,u=a.tileWidth||a.tileSize||1,x=a.tileHeight||a.tileSize||1,p=a.alignHorizontal||0,o=a.alignVertical||0,h=a.sideOrientation===0?0:a.sideOrientation||U.DEFAULTSIDE;for(let l=0;l<6;l++)e[l]===void 0&&(e[l]=new mt(0,0,1,1)),s&&s[l]===void 0&&(s[l]=new pt(1,1,1,1));const m=i/2,d=n/2,A=c/2,y=[];for(let l=0;l<2;l++)y[l]=Tt({pattern:r,tileWidth:u,tileHeight:x,width:i,height:n,alignVertical:o,alignHorizontal:p,sideOrientation:h});for(let l=2;l<4;l++)y[l]=Tt({pattern:r,tileWidth:u,tileHeight:x,width:c,height:n,alignVertical:o,alignHorizontal:p,sideOrientation:h});let v=o;o===T.BOTTOM?v=T.TOP:o===T.TOP&&(v=T.BOTTOM);for(let l=4;l<6;l++)y[l]=Tt({pattern:r,tileWidth:u,tileHeight:x,width:i,height:c,alignVertical:v,alignHorizontal:p,sideOrientation:h});let w=[],C=[],b=[],f=[];const _=[],g=[],P=[],D=[];let V=0,M=0;for(let l=0;l<6;l++){const O=y[l].positions.length;g[l]=[],P[l]=[];for(let I=0;I<O/3;I++)g[l].push(new F(y[l].positions[3*I],y[l].positions[3*I+1],y[l].positions[3*I+2])),P[l].push(new F(y[l].normals[3*I],y[l].normals[3*I+1],y[l].normals[3*I+2]));V=y[l].uvs.length,D[l]=[];for(let I=0;I<V;I+=2)D[l][I]=e[l].x+(e[l].z-e[l].x)*y[l].uvs[I],D[l][I+1]=e[l].y+(e[l].w-e[l].y)*y[l].uvs[I+1];if(b=b.concat(D[l]),f=f.concat(y[l].indices.map(I=>I+M)),M+=g[l].length,s)for(let I=0;I<4;I++)_.push(s[l].r,s[l].g,s[l].b,s[l].a)}const L=new F(0,0,A),R=it.RotationY(Math.PI);w=g[0].map(l=>F.TransformNormal(l,R).add(L)).map(l=>[l.x,l.y,l.z]).reduce((l,O)=>l.concat(O),[]),C=P[0].map(l=>F.TransformNormal(l,R)).map(l=>[l.x,l.y,l.z]).reduce((l,O)=>l.concat(O),[]),w=w.concat(g[1].map(l=>l.subtract(L)).map(l=>[l.x,l.y,l.z]).reduce((l,O)=>l.concat(O),[])),C=C.concat(P[1].map(l=>[l.x,l.y,l.z]).reduce((l,O)=>l.concat(O),[]));const q=new F(m,0,0),W=it.RotationY(-Math.PI/2);w=w.concat(g[2].map(l=>F.TransformNormal(l,W).add(q)).map(l=>[l.x,l.y,l.z]).reduce((l,O)=>l.concat(O),[])),C=C.concat(P[2].map(l=>F.TransformNormal(l,W)).map(l=>[l.x,l.y,l.z]).reduce((l,O)=>l.concat(O),[]));const Y=it.RotationY(Math.PI/2);w=w.concat(g[3].map(l=>F.TransformNormal(l,Y).subtract(q)).map(l=>[l.x,l.y,l.z]).reduce((l,O)=>l.concat(O),[])),C=C.concat(P[3].map(l=>F.TransformNormal(l,Y)).map(l=>[l.x,l.y,l.z]).reduce((l,O)=>l.concat(O),[]));const N=new F(0,d,0),X=it.RotationX(Math.PI/2);w=w.concat(g[4].map(l=>F.TransformNormal(l,X).add(N)).map(l=>[l.x,l.y,l.z]).reduce((l,O)=>l.concat(O),[])),C=C.concat(P[4].map(l=>F.TransformNormal(l,X)).map(l=>[l.x,l.y,l.z]).reduce((l,O)=>l.concat(O),[]));const B=it.RotationX(-Math.PI/2);w=w.concat(g[5].map(l=>F.TransformNormal(l,B).subtract(N)).map(l=>[l.x,l.y,l.z]).reduce((l,O)=>l.concat(O),[])),C=C.concat(P[5].map(l=>F.TransformNormal(l,B)).map(l=>[l.x,l.y,l.z]).reduce((l,O)=>l.concat(O),[])),U._ComputeSides(h,w,f,C,b);const E=new U;if(E.indices=f,E.positions=w,E.normals=C,E.uvs=b,s){const l=h===U.DOUBLESIDE?_.concat(_):_;E.colors=l}return E}function cs(a,t,e=null){const s=new T(a,e);return t.sideOrientation=T._GetDefaultSideOrientation(t.sideOrientation),s._originalBuilderSideOrientation=t.sideOrientation,de(t).applyToMesh(s,t.updatable),s}U.CreateTiledBox=de;function xe(a){const t=(a.segments||32)|0,e=a.diameterX||a.diameter||1,s=a.diameterY||a.diameter||1,r=a.diameterZ||a.diameter||1,i=a.arc&&(a.arc<=0||a.arc>1)?1:a.arc||1,n=a.slice&&a.slice<=0?1:a.slice||1,c=a.sideOrientation===0?0:a.sideOrientation||U.DEFAULTSIDE,u=!!a.dedupTopBottomIndices,x=new F(e/2,s/2,r/2),p=2+t,o=2*p,h=[],m=[],d=[],A=[];for(let v=0;v<=p;v++){const w=v/p,C=w*Math.PI*n;for(let b=0;b<=o;b++){const f=b/o,_=f*Math.PI*2*i,g=it.RotationZ(-C),P=it.RotationY(_),D=F.TransformCoordinates(F.Up(),g),V=F.TransformCoordinates(D,P),M=V.multiply(x),L=V.divide(x).normalize();m.push(M.x,M.y,M.z),d.push(L.x,L.y,L.z),A.push(f,w)}if(v>0){const b=m.length/3;for(let f=b-2*(o+1);f+o+2<b;f++)u?(v>1&&(h.push(f),h.push(f+1),h.push(f+o+1)),(v<p||n<1)&&(h.push(f+o+1),h.push(f+1),h.push(f+o+2))):(h.push(f),h.push(f+1),h.push(f+o+1),h.push(f+o+1),h.push(f+1),h.push(f+o+2))}}U._ComputeSides(c,m,h,d,A,a.frontUVs,a.backUVs);const y=new U;return y.indices=h,y.positions=m,y.normals=d,y.uvs=A,y}function pe(a,t={},e=null){const s=new T(a,e);return t.sideOrientation=T._GetDefaultSideOrientation(t.sideOrientation),s._originalBuilderSideOrientation=t.sideOrientation,xe(t).applyToMesh(s,t.updatable),s}U.CreateSphere=xe;T.CreateSphere=(a,t,e,s,r,i)=>pe(a,{segments:t,diameterX:e,diameterY:e,diameterZ:e,sideOrientation:i,updatable:r},s);function ge(a){const t=a.height||2;let e=a.diameterTop===0?0:a.diameterTop||a.diameter||1,s=a.diameterBottom===0?0:a.diameterBottom||a.diameter||1;e=e||1e-5,s=s||1e-5;const r=(a.tessellation||24)|0,i=(a.subdivisions||1)|0,n=!!a.hasRings,c=!!a.enclose,u=a.cap===0?0:a.cap||T.CAP_ALL,x=a.arc&&(a.arc<=0||a.arc>1)?1:a.arc||1,p=a.sideOrientation===0?0:a.sideOrientation||U.DEFAULTSIDE,o=a.faceUV||new Array(3),h=a.faceColors,m=x!==1&&c?2:0,d=n?i:1,A=2+(1+m)*d;let y;for(y=0;y<A;y++)h&&h[y]===void 0&&(h[y]=new pt(1,1,1,1));for(y=0;y<A;y++)o&&o[y]===void 0&&(o[y]=new mt(0,0,1,1));const v=[],w=[],C=[],b=[],f=[],_=Math.PI*2*x/r;let g,P,D;const V=(s-e)/2/t,M=F.Zero(),L=F.Zero(),R=F.Zero(),q=F.Zero(),W=F.Zero(),Y=Xe.Y;let N,X,B,E=1,l=1,O=0,I=0;for(N=0;N<=i;N++)for(P=N/i,D=(P*(e-s)+s)/2,E=n&&N!==0&&N!==i?2:1,B=0;B<E;B++){for(n&&(l+=B),c&&(l+=2*B),X=0;X<=r;X++)g=X*_,M.x=Math.cos(-g)*D,M.y=-t/2+P*t,M.z=Math.sin(-g)*D,e===0&&N===i?(L.x=C[C.length-(r+1)*3],L.y=C[C.length-(r+1)*3+1],L.z=C[C.length-(r+1)*3+2]):(L.x=M.x,L.z=M.z,L.y=Math.sqrt(L.x*L.x+L.z*L.z)*V,L.normalize()),X===0&&(R.copyFrom(M),q.copyFrom(L)),w.push(M.x,M.y,M.z),C.push(L.x,L.y,L.z),n?I=O!==l?o[l].y:o[l].w:I=o[l].y+(o[l].w-o[l].y)*P,b.push(o[l].x+(o[l].z-o[l].x)*X/r,I),h&&f.push(h[l].r,h[l].g,h[l].b,h[l].a);x!==1&&c&&(w.push(M.x,M.y,M.z),w.push(0,M.y,0),w.push(0,M.y,0),w.push(R.x,R.y,R.z),F.CrossToRef(Y,L,W),W.normalize(),C.push(W.x,W.y,W.z,W.x,W.y,W.z),F.CrossToRef(q,Y,W),W.normalize(),C.push(W.x,W.y,W.z,W.x,W.y,W.z),n?I=O!==l?o[l+1].y:o[l+1].w:I=o[l+1].y+(o[l+1].w-o[l+1].y)*P,b.push(o[l+1].x,I),b.push(o[l+1].z,I),n?I=O!==l?o[l+2].y:o[l+2].w:I=o[l+2].y+(o[l+2].w-o[l+2].y)*P,b.push(o[l+2].x,I),b.push(o[l+2].z,I),h&&(f.push(h[l+1].r,h[l+1].g,h[l+1].b,h[l+1].a),f.push(h[l+1].r,h[l+1].g,h[l+1].b,h[l+1].a),f.push(h[l+2].r,h[l+2].g,h[l+2].b,h[l+2].a),f.push(h[l+2].r,h[l+2].g,h[l+2].b,h[l+2].a))),O!==l&&(O=l)}const S=x!==1&&c?r+4:r;for(N=0,l=0;l<i;l++){let H=0,Q=0,et=0,$=0;for(X=0;X<r;X++)H=N*(S+1)+X,Q=(N+1)*(S+1)+X,et=N*(S+1)+(X+1),$=(N+1)*(S+1)+(X+1),v.push(H,Q,et),v.push($,et,Q);x!==1&&c&&(v.push(H+2,Q+2,et+2),v.push($+2,et+2,Q+2),v.push(H+4,Q+4,et+4),v.push($+4,et+4,Q+4)),N=n?N+2:N+1}const Z=H=>{const Q=H?e/2:s/2;if(Q===0)return;let et,$,st;const k=H?o[A-1]:o[0];let j=null;h&&(j=H?h[A-1]:h[0]);const G=w.length/3,at=H?t/2:-t/2,lt=new F(0,at,0);w.push(lt.x,lt.y,lt.z),C.push(0,H?1:-1,0);const ct=k.y+(k.w-k.y)*.5;b.push(k.x+(k.z-k.x)*.5,ct),j&&f.push(j.r,j.g,j.b,j.a);const ht=new nt(.5,.5);for(st=0;st<=r;st++){et=Math.PI*2*st*x/r;const yt=Math.cos(-et),ft=Math.sin(-et);$=new F(yt*Q,at,ft*Q);const At=new nt(yt*ht.x+.5,ft*ht.y+.5);w.push($.x,$.y,$.z),C.push(0,H?1:-1,0);const vt=k.y+(k.w-k.y)*At.y;b.push(k.x+(k.z-k.x)*At.x,vt),j&&f.push(j.r,j.g,j.b,j.a)}for(st=0;st<r;st++)H?(v.push(G),v.push(G+(st+2)),v.push(G+(st+1))):(v.push(G),v.push(G+(st+1)),v.push(G+(st+2)))};(u===T.CAP_START||u===T.CAP_ALL)&&Z(!1),(u===T.CAP_END||u===T.CAP_ALL)&&Z(!0),U._ComputeSides(p,w,v,C,b,a.frontUVs,a.backUVs);const z=new U;return z.indices=v,z.positions=w,z.normals=C,z.uvs=b,h&&(z.colors=f),z}function me(a,t={},e){const s=new T(a,e);return t.sideOrientation=T._GetDefaultSideOrientation(t.sideOrientation),s._originalBuilderSideOrientation=t.sideOrientation,ge(t).applyToMesh(s,t.updatable),s}U.CreateCylinder=ge;T.CreateCylinder=(a,t,e,s,r,i,n,c,u)=>((n===void 0||!(n instanceof te))&&(n!==void 0&&(u=c||T.DEFAULTSIDE,c=n),n=i,i=1),me(a,{height:t,diameterTop:e,diameterBottom:s,tessellation:r,subdivisions:i,sideOrientation:u,updatable:c},n));function _e(a){const t=[],e=[],s=[],r=[],i=a.diameter||1,n=a.thickness||.5,c=(a.tessellation||16)|0,u=a.sideOrientation===0?0:a.sideOrientation||U.DEFAULTSIDE,x=c+1;for(let o=0;o<=c;o++){const h=o/c,m=o*Math.PI*2/c-Math.PI/2,d=it.Translation(i/2,0,0).multiply(it.RotationY(m));for(let A=0;A<=c;A++){const y=1-A/c,v=A*Math.PI*2/c+Math.PI,w=Math.cos(v),C=Math.sin(v);let b=new F(w,C,0),f=b.scale(n/2);const _=new nt(h,y);f=F.TransformCoordinates(f,d),b=F.TransformNormal(b,d),e.push(f.x,f.y,f.z),s.push(b.x,b.y,b.z),r.push(_.x,_.y);const g=(o+1)%x,P=(A+1)%x;t.push(o*x+A),t.push(o*x+P),t.push(g*x+A),t.push(o*x+P),t.push(g*x+P),t.push(g*x+A)}}U._ComputeSides(u,e,t,s,r,a.frontUVs,a.backUVs);const p=new U;return p.indices=t,p.positions=e,p.normals=s,p.uvs=r,p}function ye(a,t={},e){const s=new T(a,e);return t.sideOrientation=T._GetDefaultSideOrientation(t.sideOrientation),s._originalBuilderSideOrientation=t.sideOrientation,_e(t).applyToMesh(s,t.updatable),s}U.CreateTorus=_e;T.CreateTorus=(a,t,e,s,r,i,n)=>ye(a,{diameter:t,thickness:e,tessellation:s,sideOrientation:n,updatable:i},r);function Ae(a){const t=[],e=[],s=[],r=[],i=a.radius||2,n=a.tube||.5,c=a.radialSegments||32,u=a.tubularSegments||32,x=a.p||2,p=a.q||3,o=a.sideOrientation===0?0:a.sideOrientation||U.DEFAULTSIDE,h=y=>{const v=Math.cos(y),w=Math.sin(y),C=p/x*y,b=Math.cos(C),f=i*(2+b)*.5*v,_=i*(2+b)*w*.5,g=i*Math.sin(C)*.5;return new F(f,_,g)};let m,d;for(m=0;m<=c;m++){const v=m%c/c*2*x*Math.PI,w=h(v),C=h(v+.01),b=C.subtract(w);let f=C.add(w);const _=F.Cross(b,f);for(f=F.Cross(_,b),_.normalize(),f.normalize(),d=0;d<u;d++){const P=d%u/u*2*Math.PI,D=-n*Math.cos(P),V=n*Math.sin(P);e.push(w.x+D*f.x+V*_.x),e.push(w.y+D*f.y+V*_.y),e.push(w.z+D*f.z+V*_.z),r.push(m/c),r.push(d/u)}}for(m=0;m<c;m++)for(d=0;d<u;d++){const y=(d+1)%u,v=m*u+d,w=(m+1)*u+d,C=(m+1)*u+y,b=m*u+y;t.push(b),t.push(w),t.push(v),t.push(b),t.push(C),t.push(w)}U.ComputeNormals(e,t,s),U._ComputeSides(o,e,t,s,r,a.frontUVs,a.backUVs);const A=new U;return A.indices=t,A.positions=e,A.normals=s,A.uvs=r,A}function ve(a,t={},e){const s=new T(a,e);return t.sideOrientation=T._GetDefaultSideOrientation(t.sideOrientation),s._originalBuilderSideOrientation=t.sideOrientation,Ae(t).applyToMesh(s,t.updatable),s}U.CreateTorusKnot=Ae;T.CreateTorusKnot=(a,t,e,s,r,i,n,c,u,x)=>ve(a,{radius:t,tube:e,radialSegments:s,tubularSegments:r,p:i,q:n,sideOrientation:x,updatable:u},c);const Rt={effect:null,subMesh:null};class xt extends Ze{constructor(t,e,s,r={},i=!0){super(t,e,i),this._textures={},this._textureArrays={},this._externalTextures={},this._floats={},this._ints={},this._uints={},this._floatsArrays={},this._colors3={},this._colors3Arrays={},this._colors4={},this._colors4Arrays={},this._vectors2={},this._vectors3={},this._vectors4={},this._quaternions={},this._quaternionsArrays={},this._matrices={},this._matrixArrays={},this._matrices3x3={},this._matrices2x2={},this._vectors2Arrays={},this._vectors3Arrays={},this._vectors4Arrays={},this._uniformBuffers={},this._textureSamplers={},this._storageBuffers={},this._cachedWorldViewMatrix=new it,this._cachedWorldViewProjectionMatrix=new it,this._multiview=!1,this._materialHelperNeedsPreviousMatrices=!1,this._shaderPath=s,this._options={needAlphaBlending:!1,needAlphaTesting:!1,attributes:["position","normal","uv"],uniforms:["worldViewProjection"],uniformBuffers:[],samplers:[],externalTextures:[],samplerObjects:[],storageBuffers:[],defines:[],useClipPlane:!1,...r}}get shaderPath(){return this._shaderPath}set shaderPath(t){this._shaderPath=t}get options(){return this._options}get isMultiview(){return this._multiview}getClassName(){return"ShaderMaterial"}needAlphaBlending(){return this.alpha<1||this._options.needAlphaBlending}needAlphaTesting(){return this._options.needAlphaTesting}_checkUniform(t){this._options.uniforms.indexOf(t)===-1&&this._options.uniforms.push(t)}setTexture(t,e){return this._options.samplers.indexOf(t)===-1&&this._options.samplers.push(t),this._textures[t]=e,this}removeTexture(t){delete this._textures[t]}setTextureArray(t,e){return this._options.samplers.indexOf(t)===-1&&this._options.samplers.push(t),this._checkUniform(t),this._textureArrays[t]=e,this}setExternalTexture(t,e){return this._options.externalTextures.indexOf(t)===-1&&this._options.externalTextures.push(t),this._externalTextures[t]=e,this}setFloat(t,e){return this._checkUniform(t),this._floats[t]=e,this}setInt(t,e){return this._checkUniform(t),this._ints[t]=e,this}setUInt(t,e){return this._checkUniform(t),this._uints[t]=e,this}setFloats(t,e){return this._checkUniform(t),this._floatsArrays[t]=e,this}setColor3(t,e){return this._checkUniform(t),this._colors3[t]=e,this}setColor3Array(t,e){return this._checkUniform(t),this._colors3Arrays[t]=e.reduce((s,r)=>(s.push(r.r,r.g,r.b),s),[]),this}setColor4(t,e){return this._checkUniform(t),this._colors4[t]=e,this}setColor4Array(t,e){return this._checkUniform(t),this._colors4Arrays[t]=e.reduce((s,r)=>(s.push(r.r,r.g,r.b,r.a),s),[]),this}setVector2(t,e){return this._checkUniform(t),this._vectors2[t]=e,this}setVector3(t,e){return this._checkUniform(t),this._vectors3[t]=e,this}setVector4(t,e){return this._checkUniform(t),this._vectors4[t]=e,this}setQuaternion(t,e){return this._checkUniform(t),this._quaternions[t]=e,this}setQuaternionArray(t,e){return this._checkUniform(t),this._quaternionsArrays[t]=e.reduce((s,r)=>(r.toArray(s,s.length),s),[]),this}setMatrix(t,e){return this._checkUniform(t),this._matrices[t]=e,this}setMatrices(t,e){this._checkUniform(t);const s=new Float32Array(e.length*16);for(let r=0;r<e.length;r++)e[r].copyToArray(s,r*16);return this._matrixArrays[t]=s,this}setMatrix3x3(t,e){return this._checkUniform(t),this._matrices3x3[t]=e,this}setMatrix2x2(t,e){return this._checkUniform(t),this._matrices2x2[t]=e,this}setArray2(t,e){return this._checkUniform(t),this._vectors2Arrays[t]=e,this}setArray3(t,e){return this._checkUniform(t),this._vectors3Arrays[t]=e,this}setArray4(t,e){return this._checkUniform(t),this._vectors4Arrays[t]=e,this}setUniformBuffer(t,e){return this._options.uniformBuffers.indexOf(t)===-1&&this._options.uniformBuffers.push(t),this._uniformBuffers[t]=e,this}setTextureSampler(t,e){return this._options.samplerObjects.indexOf(t)===-1&&this._options.samplerObjects.push(t),this._textureSamplers[t]=e,this}setStorageBuffer(t,e){return this._options.storageBuffers.indexOf(t)===-1&&this._options.storageBuffers.push(t),this._storageBuffers[t]=e,this}setDefine(t,e){const s=t.trimEnd()+" ",r=this.options.defines.findIndex(i=>i===t||i.startsWith(s));return r>=0&&this.options.defines.splice(r,1),(typeof e!="boolean"||e)&&this.options.defines.push(s+e),this}isReadyForSubMesh(t,e,s){return this.isReady(t,s,e)}isReady(t,e,s){const r=s&&this._storeEffectOnSubMeshes;if(this.isFrozen){const _=r?s._drawWrapper:this._drawWrapper;if(_.effect&&_._wasPreviouslyReady&&_._wasPreviouslyUsingInstances===e)return!0}const i=this.getScene(),n=i.getEngine(),c=[],u=[];let x=null,p=this._shaderPath,o=this._options.uniforms,h=this._options.uniformBuffers,m=this._options.samplers;n.getCaps().multiview&&i.activeCamera&&i.activeCamera.outputRenderTarget&&i.activeCamera.outputRenderTarget.getViewCount()>1&&(this._multiview=!0,c.push("#define MULTIVIEW"),o.indexOf("viewProjection")!==-1&&o.indexOf("viewProjectionR")===-1&&o.push("viewProjectionR"));for(let _=0;_<this._options.defines.length;_++){const g=this._options.defines[_].indexOf("#define")===0?this._options.defines[_]:`#define ${this._options.defines[_]}`;c.push(g)}for(let _=0;_<this._options.attributes.length;_++)u.push(this._options.attributes[_]);if(t&&t.isVerticesDataPresent(K.ColorKind)&&(u.indexOf(K.ColorKind)===-1&&u.push(K.ColorKind),c.push("#define VERTEXCOLOR")),e&&(c.push("#define INSTANCES"),Ge(u,this._materialHelperNeedsPreviousMatrices),t?.hasThinInstances&&(c.push("#define THIN_INSTANCES"),t&&t.isVerticesDataPresent(K.ColorInstanceKind)&&(u.push(K.ColorInstanceKind),c.push("#define INSTANCESCOLOR")))),t&&t.useBones&&t.computeBonesUsingShaders&&t.skeleton){u.push(K.MatricesIndicesKind),u.push(K.MatricesWeightsKind),t.numBoneInfluencers>4&&(u.push(K.MatricesIndicesExtraKind),u.push(K.MatricesWeightsExtraKind));const _=t.skeleton;c.push("#define NUM_BONE_INFLUENCERS "+t.numBoneInfluencers),x=new rs,x.addCPUSkinningFallback(0,t),_.isUsingTextureForMatrices?(c.push("#define BONETEXTURE"),o.indexOf("boneTextureWidth")===-1&&o.push("boneTextureWidth"),this._options.samplers.indexOf("boneSampler")===-1&&this._options.samplers.push("boneSampler")):(c.push("#define BonesPerMesh "+(_.bones.length+1)),o.indexOf("mBones")===-1&&o.push("mBones"))}else c.push("#define NUM_BONE_INFLUENCERS 0");let d=0;const A=t?t.morphTargetManager:null;if(A){const _=c.indexOf("#define UV1")!==-1,g=c.indexOf("#define UV2")!==-1,P=c.indexOf("#define TANGENT")!==-1,D=c.indexOf("#define NORMAL")!==-1,V=c.indexOf("#define VERTEXCOLOR")!==-1;d=He(A,c,u,t,!0,D,P,_,g,V),A.isUsingTextureForTargets&&(o.indexOf("morphTargetTextureIndices")===-1&&o.push("morphTargetTextureIndices"),this._options.samplers.indexOf("morphTargets")===-1&&this._options.samplers.push("morphTargets")),d>0&&(o=o.slice(),o.push("morphTargetInfluences"),o.push("morphTargetCount"),o.push("morphTargetTextureInfo"),o.push("morphTargetTextureIndices"))}else c.push("#define NUM_MORPH_INFLUENCERS 0");if(t){const _=t.bakedVertexAnimationManager;_&&_.isEnabled&&(c.push("#define BAKED_VERTEX_ANIMATION_TEXTURE"),o.indexOf("bakedVertexAnimationSettings")===-1&&o.push("bakedVertexAnimationSettings"),o.indexOf("bakedVertexAnimationTextureSizeInverted")===-1&&o.push("bakedVertexAnimationTextureSizeInverted"),o.indexOf("bakedVertexAnimationTime")===-1&&o.push("bakedVertexAnimationTime"),this._options.samplers.indexOf("bakedVertexAnimationTexture")===-1&&this._options.samplers.push("bakedVertexAnimationTexture")),Ye(u,t,c)}for(const _ in this._textures)if(!this._textures[_].isReady())return!1;t&&this.needAlphaTestingForMesh(t)&&c.push("#define ALPHATEST"),this._options.useClipPlane!==!1&&(qe(o),Ke(this,i,c)),i.fogEnabled&&t?.applyFog&&i.fogMode!==te.FOGMODE_NONE&&(c.push("#define FOG"),o.indexOf("view")===-1&&o.push("view"),o.indexOf("vFogInfos")===-1&&o.push("vFogInfos"),o.indexOf("vFogColor")===-1&&o.push("vFogColor")),this._useLogarithmicDepth&&(c.push("#define LOGARITHMICDEPTH"),o.indexOf("logarithmicDepthConstant")===-1&&o.push("logarithmicDepthConstant")),this.customShaderNameResolve&&(o=o.slice(),h=h.slice(),m=m.slice(),p=this.customShaderNameResolve(this.name,o,h,m,c,u));const y=s?s.getRenderingMesh():t;if(y&&this.useVertexPulling){c.push("#define USE_VERTEX_PULLING");const _=y.geometry?.getIndexBuffer();_&&(c.push("#define VERTEX_PULLING_USE_INDEX_BUFFER"),_.is32Bits&&c.push("#define VERTEX_PULLING_INDEX_BUFFER_32BITS"))}const v=r?s._getDrawWrapper(void 0,!0):this._drawWrapper,w=v?.effect??null,C=v?.defines??null,b=c.join(`
`);let f=w;return C!==b&&(f=n.createEffect(p,{attributes:u,uniformsNames:o,uniformBuffersNames:h,samplers:m,defines:b,fallbacks:x,onCompiled:this.onCompiled,onError:this.onError,indexParameters:{maxSimultaneousMorphTargets:d},shaderLanguage:this._options.shaderLanguage,extraInitializationsAsync:this._options.extraInitializationsAsync},n),r?s.setEffect(f,b,this._materialContext):v&&v.setEffect(f,b),this._onEffectCreatedObservable&&(Rt.effect=f,Rt.subMesh=s??t?.subMeshes[0]??null,this._onEffectCreatedObservable.notifyObservers(Rt))),v._wasPreviouslyUsingInstances=!!e,f?.isReady()?(w!==f&&i.resetCachedMaterial(),v._wasPreviouslyReady=!0,!0):!1}bindOnlyWorldMatrix(t,e){const s=e??this.getEffect();if(!s)return;const r=this._options.uniforms;r.indexOf("world")!==-1&&s.setMatrix("world",t);const i=this.getScene();r.indexOf("worldView")!==-1&&(t.multiplyToRef(i.getViewMatrix(),this._cachedWorldViewMatrix),s.setMatrix("worldView",this._cachedWorldViewMatrix)),r.indexOf("worldViewProjection")!==-1&&(t.multiplyToRef(i.getTransformMatrix(),this._cachedWorldViewProjectionMatrix),s.setMatrix("worldViewProjection",this._cachedWorldViewProjectionMatrix)),r.indexOf("view")!==-1&&s.setMatrix("view",i.getViewMatrix())}bindForSubMesh(t,e,s){this.bind(t,e,s._drawWrapperOverride?.effect,s)}bind(t,e,s,r){const i=r&&this._storeEffectOnSubMeshes,n=s??(i?r.effect:this.getEffect());if(!n)return;const c=this.getScene();this._activeEffect=n,this.bindOnlyWorldMatrix(t,s);const u=this._options.uniformBuffers;let x=!1;if(n&&u&&u.length>0&&c.getEngine().supportsUniformBuffers)for(let o=0;o<u.length;++o)switch(u[o]){case"Mesh":e&&(e.getMeshUniformBuffer().bindToEffect(n,"Mesh"),e.transferToEffect(t));break;case"Scene":je(n,c.getSceneUniformBuffer()),c.finalizeSceneUbo(),x=!0;break}const p=e&&i?this._mustRebind(c,n,r,e.visibility):c.getCachedMaterial()!==this;if(n&&p){!x&&this._options.uniforms.indexOf("view")!==-1&&n.setMatrix("view",c.getViewMatrix()),!x&&this._options.uniforms.indexOf("projection")!==-1&&n.setMatrix("projection",c.getProjectionMatrix()),!x&&this._options.uniforms.indexOf("viewProjection")!==-1&&(n.setMatrix("viewProjection",c.getTransformMatrix()),this._multiview&&n.setMatrix("viewProjectionR",c._transformMatrixR)),c.activeCamera&&this._options.uniforms.indexOf("cameraPosition")!==-1&&n.setVector3("cameraPosition",c.activeCamera.globalPosition),Qe(e,n),Je(n,this,c),this._useLogarithmicDepth&&$e(i?r.materialDefines:n.defines,n,c),e&&ts(c,e,n);let o;for(o in this._textures)n.setTexture(o,this._textures[o]);for(o in this._textureArrays)n.setTextureArray(o,this._textureArrays[o]);for(o in this._ints)n.setInt(o,this._ints[o]);for(o in this._uints)n.setUInt(o,this._uints[o]);for(o in this._floats)n.setFloat(o,this._floats[o]);for(o in this._floatsArrays)n.setArray(o,this._floatsArrays[o]);for(o in this._colors3)n.setColor3(o,this._colors3[o]);for(o in this._colors3Arrays)n.setArray3(o,this._colors3Arrays[o]);for(o in this._colors4){const y=this._colors4[o];n.setFloat4(o,y.r,y.g,y.b,y.a)}for(o in this._colors4Arrays)n.setArray4(o,this._colors4Arrays[o]);for(o in this._vectors2)n.setVector2(o,this._vectors2[o]);for(o in this._vectors3)n.setVector3(o,this._vectors3[o]);for(o in this._vectors4)n.setVector4(o,this._vectors4[o]);for(o in this._quaternions)n.setQuaternion(o,this._quaternions[o]);for(o in this._matrices)n.setMatrix(o,this._matrices[o]);for(o in this._matrixArrays)n.setMatrices(o,this._matrixArrays[o]);for(o in this._matrices3x3)n.setMatrix3x3(o,this._matrices3x3[o]);for(o in this._matrices2x2)n.setMatrix2x2(o,this._matrices2x2[o]);for(o in this._vectors2Arrays)n.setArray2(o,this._vectors2Arrays[o]);for(o in this._vectors3Arrays)n.setArray3(o,this._vectors3Arrays[o]);for(o in this._vectors4Arrays)n.setArray4(o,this._vectors4Arrays[o]);for(o in this._quaternionsArrays)n.setArray4(o,this._quaternionsArrays[o]);for(o in this._uniformBuffers){const y=this._uniformBuffers[o].getBuffer();y&&n.bindUniformBuffer(y,o)}const h=c.getEngine(),m=h.setExternalTexture;if(m)for(o in this._externalTextures)m.call(h,o,this._externalTextures[o]);const d=h.setTextureSampler;if(d)for(o in this._textureSamplers)d.call(h,o,this._textureSamplers[o]);const A=h.setStorageBuffer;if(A)for(o in this._storageBuffers)A.call(h,o,this._storageBuffers[o])}if(n&&e&&(p||!this.isFrozen)){es(e,n),e.morphTargetManager&&e.morphTargetManager.isUsingTextureForTargets&&e.morphTargetManager._bind(n);const o=e.bakedVertexAnimationManager;if(o&&o.isEnabled){const h=i?r._drawWrapper:this._drawWrapper;e.bakedVertexAnimationManager?.bind(n,!!h._wasPreviouslyUsingInstances)}}this._afterBind(e,n,r)}getActiveTextures(){const t=super.getActiveTextures();for(const e in this._textures)t.push(this._textures[e]);for(const e in this._textureArrays){const s=this._textureArrays[e];for(let r=0;r<s.length;r++)t.push(s[r])}return t}hasTexture(t){if(super.hasTexture(t))return!0;for(const e in this._textures)if(this._textures[e]===t)return!0;for(const e in this._textureArrays){const s=this._textureArrays[e];for(let r=0;r<s.length;r++)if(s[r]===t)return!0}return!1}clone(t){const e=zt.Clone(()=>new xt(t,this.getScene(),this._shaderPath,this._options,this._storeEffectOnSubMeshes),this);e.name=t,e.id=t,typeof e._shaderPath=="object"&&(e._shaderPath={...e._shaderPath}),this._options={...this._options};const s=Object.keys(this._options);for(const r of s){const i=this._options[r];Array.isArray(i)&&(this._options[r]=i.slice(0))}this.stencil.copyTo(e.stencil);for(const r in this._textures)e.setTexture(r,this._textures[r]);for(const r in this._textureArrays)e.setTextureArray(r,this._textureArrays[r]);for(const r in this._externalTextures)e.setExternalTexture(r,this._externalTextures[r]);for(const r in this._ints)e.setInt(r,this._ints[r]);for(const r in this._uints)e.setUInt(r,this._uints[r]);for(const r in this._floats)e.setFloat(r,this._floats[r]);for(const r in this._floatsArrays)e.setFloats(r,this._floatsArrays[r]);for(const r in this._colors3)e.setColor3(r,this._colors3[r]);for(const r in this._colors3Arrays)e._colors3Arrays[r]=this._colors3Arrays[r];for(const r in this._colors4)e.setColor4(r,this._colors4[r]);for(const r in this._colors4Arrays)e._colors4Arrays[r]=this._colors4Arrays[r];for(const r in this._vectors2)e.setVector2(r,this._vectors2[r]);for(const r in this._vectors3)e.setVector3(r,this._vectors3[r]);for(const r in this._vectors4)e.setVector4(r,this._vectors4[r]);for(const r in this._quaternions)e.setQuaternion(r,this._quaternions[r]);for(const r in this._quaternionsArrays)e._quaternionsArrays[r]=this._quaternionsArrays[r];for(const r in this._matrices)e.setMatrix(r,this._matrices[r]);for(const r in this._matrixArrays)e._matrixArrays[r]=this._matrixArrays[r].slice();for(const r in this._matrices3x3)e.setMatrix3x3(r,this._matrices3x3[r]);for(const r in this._matrices2x2)e.setMatrix2x2(r,this._matrices2x2[r]);for(const r in this._vectors2Arrays)e.setArray2(r,this._vectors2Arrays[r]);for(const r in this._vectors3Arrays)e.setArray3(r,this._vectors3Arrays[r]);for(const r in this._vectors4Arrays)e.setArray4(r,this._vectors4Arrays[r]);for(const r in this._uniformBuffers)e.setUniformBuffer(r,this._uniformBuffers[r]);for(const r in this._textureSamplers)e.setTextureSampler(r,this._textureSamplers[r]);for(const r in this._storageBuffers)e.setStorageBuffer(r,this._storageBuffers[r]);return e}dispose(t,e,s){if(e){let r;for(r in this._textures)this._textures[r].dispose();for(r in this._textureArrays){const i=this._textureArrays[r];for(let n=0;n<i.length;n++)i[n].dispose()}}this._textures={},super.dispose(t,e,s)}serialize(){const t=zt.Serialize(this);t.customType="BABYLON.ShaderMaterial",t.uniqueId=this.uniqueId,t.options=this._options,t.shaderPath=this._shaderPath,t.storeEffectOnSubMeshes=this._storeEffectOnSubMeshes;let e;t.stencil=this.stencil.serialize(),t.textures={};for(e in this._textures)t.textures[e]=this._textures[e].serialize();t.textureArrays={};for(e in this._textureArrays){t.textureArrays[e]=[];const s=this._textureArrays[e];for(let r=0;r<s.length;r++)t.textureArrays[e].push(s[r].serialize())}t.ints={};for(e in this._ints)t.ints[e]=this._ints[e];t.uints={};for(e in this._uints)t.uints[e]=this._uints[e];t.floats={};for(e in this._floats)t.floats[e]=this._floats[e];t.floatsArrays={};for(e in this._floatsArrays)t.floatsArrays[e]=this._floatsArrays[e];t.colors3={};for(e in this._colors3){const s=this._colors3[e];t.colors3[e]=[s.r,s.g,s.b]}t.colors3Arrays={};for(e in this._colors3Arrays)t.colors3Arrays[e]=this._colors3Arrays[e];t.colors4={};for(e in this._colors4){const s=this._colors4[e];t.colors4[e]=[s.r,s.g,s.b,s.a]}t.colors4Arrays={};for(e in this._colors4Arrays)t.colors4Arrays[e]=this._colors4Arrays[e];t.vectors2={};for(e in this._vectors2){const s=this._vectors2[e];t.vectors2[e]=[s.x,s.y]}t.vectors3={};for(e in this._vectors3){const s=this._vectors3[e];t.vectors3[e]=[s.x,s.y,s.z]}t.vectors4={};for(e in this._vectors4){const s=this._vectors4[e];t.vectors4[e]=[s.x,s.y,s.z,s.w]}t.quaternions={};for(e in this._quaternions)t.quaternions[e]=this._quaternions[e].asArray();t.matrices={};for(e in this._matrices)t.matrices[e]=this._matrices[e].asArray();t.matrixArray={};for(e in this._matrixArrays)t.matrixArray[e]=this._matrixArrays[e];t.matrices3x3={};for(e in this._matrices3x3)t.matrices3x3[e]=this._matrices3x3[e];t.matrices2x2={};for(e in this._matrices2x2)t.matrices2x2[e]=this._matrices2x2[e];t.vectors2Arrays={};for(e in this._vectors2Arrays)t.vectors2Arrays[e]=this._vectors2Arrays[e];t.vectors3Arrays={};for(e in this._vectors3Arrays)t.vectors3Arrays[e]=this._vectors3Arrays[e];t.vectors4Arrays={};for(e in this._vectors4Arrays)t.vectors4Arrays[e]=this._vectors4Arrays[e];t.quaternionsArrays={};for(e in this._quaternionsArrays)t.quaternionsArrays[e]=this._quaternionsArrays[e];return t}static Parse(t,e,s){const r=zt.Parse(()=>new xt(t.name,e,t.shaderPath,t.options,t.storeEffectOnSubMeshes),t,e,s);let i;t.stencil&&r.stencil.parse(t.stencil,e,s);for(i in t.textures)r.setTexture(i,Kt.Parse(t.textures[i],e,s));for(i in t.textureArrays){const n=t.textureArrays[i],c=[];for(let u=0;u<n.length;u++)c.push(Kt.Parse(n[u],e,s));r.setTextureArray(i,c)}for(i in t.ints)r.setInt(i,t.ints[i]);for(i in t.uints)r.setUInt(i,t.uints[i]);for(i in t.floats)r.setFloat(i,t.floats[i]);for(i in t.floatsArrays)r.setFloats(i,t.floatsArrays[i]);for(i in t.colors3){const n=t.colors3[i];r.setColor3(i,{r:n[0],g:n[1],b:n[2]})}for(i in t.colors3Arrays){const n=t.colors3Arrays[i].reduce((c,u,x)=>(x%3===0?c.push([u]):c[c.length-1].push(u),c),[]).map(c=>({r:c[0],g:c[1],b:c[2]}));r.setColor3Array(i,n)}for(i in t.colors4){const n=t.colors4[i];r.setColor4(i,{r:n[0],g:n[1],b:n[2],a:n[3]})}for(i in t.colors4Arrays){const n=t.colors4Arrays[i].reduce((c,u,x)=>(x%4===0?c.push([u]):c[c.length-1].push(u),c),[]).map(c=>({r:c[0],g:c[1],b:c[2],a:c[3]}));r.setColor4Array(i,n)}for(i in t.vectors2){const n=t.vectors2[i];r.setVector2(i,{x:n[0],y:n[1]})}for(i in t.vectors3){const n=t.vectors3[i];r.setVector3(i,{x:n[0],y:n[1],z:n[2]})}for(i in t.vectors4){const n=t.vectors4[i];r.setVector4(i,{x:n[0],y:n[1],z:n[2],w:n[3]})}for(i in t.quaternions)r.setQuaternion(i,ss.FromArray(t.quaternions[i]));for(i in t.matrices)r.setMatrix(i,it.FromArray(t.matrices[i]));for(i in t.matrixArray)r._matrixArrays[i]=new Float32Array(t.matrixArray[i]);for(i in t.matrices3x3)r.setMatrix3x3(i,t.matrices3x3[i]);for(i in t.matrices2x2)r.setMatrix2x2(i,t.matrices2x2[i]);for(i in t.vectors2Arrays)r.setArray2(i,t.vectors2Arrays[i]);for(i in t.vectors3Arrays)r.setArray3(i,t.vectors3Arrays[i]);for(i in t.vectors4Arrays)r.setArray4(i,t.vectors4Arrays[i]);for(i in t.quaternionsArrays)r.setArray4(i,t.quaternionsArrays[i]);return r}static async ParseFromFileAsync(t,e,s,r=""){return await new Promise((i,n)=>{const c=new jt;c.addEventListener("readystatechange",()=>{if(c.readyState==4)if(c.status==200){const u=JSON.parse(c.responseText),x=this.Parse(u,s||It.LastCreatedScene,r);t&&(x.name=t),i(x)}else n("Unable to load the ShaderMaterial")}),c.open("GET",e),c.send()})}static async ParseFromSnippetAsync(t,e,s=""){return await new Promise((r,i)=>{const n=new jt;n.addEventListener("readystatechange",()=>{if(n.readyState==4)if(n.status==200){const c=JSON.parse(JSON.parse(n.responseText).jsonPayload),u=JSON.parse(c.shaderMaterial),x=this.Parse(u,e||It.LastCreatedScene,s);x.snippetId=t,r(x)}else i("Unable to load the snippet "+t)}),n.open("GET",this.SnippetUrl+"/"+t.replace(/#/g,"/")),n.send()})}}xt.SnippetUrl="https://snippet.babylonjs.com";xt.CreateFromSnippetAsync=xt.ParseFromSnippetAsync;is("BABYLON.ShaderMaterial",xt);T._LinesMeshParser=(a,t)=>dt.Parse(a,t);class dt extends T{_isShaderMaterial(t){return t?t.getClassName()==="ShaderMaterial":!1}constructor(t,e=null,s=null,r=null,i,n,c,u){super(t,e,s,r,i),this.useVertexColor=n,this.useVertexAlpha=c,this.color=new Pt(1,1,1),this.alpha=1,this._shaderLanguage=0,r&&(this.color=r.color.clone(),this.alpha=r.alpha,this.useVertexColor=r.useVertexColor,this.useVertexAlpha=r.useVertexAlpha),this.intersectionThreshold=.1;const x=[],p={attributes:[K.PositionKind],uniforms:["world","viewProjection"],needAlphaBlending:!0,defines:x,useClipPlane:null,shaderLanguage:0};this.useVertexAlpha?p.defines.push("#define VERTEXALPHA"):p.needAlphaBlending=!1,this.useVertexColor?(p.defines.push("#define VERTEXCOLOR"),p.attributes.push(K.ColorKind)):(p.uniforms.push("color"),this._color4=new pt),u?this.material=u:(this.getScene().getEngine().isWebGPU&&!dt.ForceGLSL&&(this._shaderLanguage=1),p.shaderLanguage=this._shaderLanguage,p.extraInitializationsAsync=async()=>{this._shaderLanguage===1?await Promise.all([Dt(()=>import("./color.vertex-Vp-uvC58.js"),__vite__mapDeps([0,1,2,3,4]),import.meta.url),Dt(()=>import("./color.fragment-B4-hQLNZ.js"),__vite__mapDeps([5,1,2,6]),import.meta.url)]):await Promise.all([Dt(()=>import("./color.vertex-ENmlZluc.js"),__vite__mapDeps([7,1,2,8,9]),import.meta.url),Dt(()=>import("./color.fragment-CElMKGuX.js"),__vite__mapDeps([10,1,2,11]),import.meta.url)])},this.material=new xt("colorShader",this.getScene(),"color",p,!1),this.material.doNotSerialize=!0)}getClassName(){return"LinesMesh"}get material(){return this._internalAbstractMeshDataInfo._material}set material(t){this._setMaterial(t),this.material&&(this.material.fillMode=Lt.LineListDrawMode)}get checkCollisions(){return!1}set checkCollisions(t){}_bind(t,e){if(!this._geometry)return this;const s=this.isUnIndexed?null:this._geometry.getIndexBuffer();if(!this._userInstancedBuffersStorage||this.hasThinInstances?this._geometry._bind(e,s):this._geometry._bind(e,s,this._userInstancedBuffersStorage.vertexBuffers,this._userInstancedBuffersStorage.vertexArrayObjects),!this.useVertexColor&&this._isShaderMaterial(this.material)){const{r,g:i,b:n}=this.color;this._color4.set(r,i,n,this.alpha),this.material.setColor4("color",this._color4)}return this}_draw(t,e,s){if(!this._geometry||!this._geometry.getVertexBuffers()||!this._unIndexed&&!this._geometry.getIndexBuffer())return this;const r=this.getScene().getEngine();return this._unIndexed?r.drawArraysType(Lt.LineListDrawMode,t.verticesStart,t.verticesCount,s):r.drawElementsType(Lt.LineListDrawMode,t.indexStart,t.indexCount,s),this}dispose(t,e=!1,s){s||this.material?.dispose(!1,!1,!0),super.dispose(t)}clone(t,e=null,s){if(e&&e._addToSceneRootNodes===void 0){const r=e;return r.source=this,new dt(t,this.getScene(),r.parent,r.source,r.doNotCloneChildren)}return new dt(t,this.getScene(),e,this,s)}createInstance(t){const e=new ls(t,this);if(this.instancedBuffers){e.instancedBuffers={};for(const s in this.instancedBuffers)e.instancedBuffers[s]=this.instancedBuffers[s]}return e}serialize(t){super.serialize(t),t.color=this.color.asArray(),t.alpha=this.alpha}static Parse(t,e){const s=new dt(t.name,e);return s.color=Pt.FromArray(t.color),s.alpha=t.alpha,s}}dt.ForceGLSL=!1;class ls extends ns{constructor(t,e){super(t,e),this.intersectionThreshold=e.intersectionThreshold}getClassName(){return"InstancedLinesMesh"}}function be(a){const t=[],e=[],s=a.lines,r=a.colors,i=[];let n=0;for(let u=0;u<s.length;u++){const x=s[u];for(let p=0;p<x.length;p++){const{x:o,y:h,z:m}=x[p];if(e.push(o,h,m),r){const d=r[u],{r:A,g:y,b:v,a:w}=d[p];i.push(A,y,v,w)}p>0&&(t.push(n-1),t.push(n)),n++}}const c=new U;return c.indices=t,c.positions=e,r&&(c.colors=i),c}function Oe(a){const t=a.dashSize||3,e=a.gapSize||1,s=a.dashNb||200,r=a.points,i=[],n=[],c=F.Zero();let u=0,x=0,p=0,o=0,h=0,m=0,d=0;for(d=0;d<r.length-1;d++)r[d+1].subtractToRef(r[d],c),u+=c.length();for(p=u/s,o=t*p/(t+e),d=0;d<r.length-1;d++){r[d+1].subtractToRef(r[d],c),x=Math.floor(c.length()/p),c.normalize();for(let y=0;y<x;y++)h=p*y,i.push(r[d].x+h*c.x,r[d].y+h*c.y,r[d].z+h*c.z),i.push(r[d].x+(h+o)*c.x,r[d].y+(h+o)*c.y,r[d].z+(h+o)*c.z),n.push(m,m+1),m+=2}const A=new U;return A.positions=i,A.indices=n,A}function Te(a,t,e=null){const s=t.instance,r=t.lines,i=t.colors;if(s){const x=s.getVerticesData(K.PositionKind);let p,o;i&&(p=s.getVerticesData(K.ColorKind));let h=0,m=0;for(let d=0;d<r.length;d++){const A=r[d];for(let y=0;y<A.length;y++)x[h]=A[y].x,x[h+1]=A[y].y,x[h+2]=A[y].z,i&&p&&(o=i[d],p[m]=o[y].r,p[m+1]=o[y].g,p[m+2]=o[y].b,p[m+3]=o[y].a,m+=4),h+=3}return s.updateVerticesData(K.PositionKind,x,!1,!1),i&&p&&s.updateVerticesData(K.ColorKind,p,!1,!1),s.refreshBoundingInfo(),s}const n=!!i,c=new dt(a,e,null,void 0,void 0,n,t.useVertexAlpha,t.material);return be(t).applyToMesh(c,t.updatable),c}function Ie(a,t,e=null){const s=t.colors?[t.colors]:null;return Te(a,{lines:[t.points],updatable:t.updatable,instance:t.instance,colors:s,useVertexAlpha:t.useVertexAlpha,material:t.material},e)}function we(a,t,e=null){const s=t.points,r=t.instance,i=t.gapSize||1,n=t.dashSize||3;if(r){const x=p=>{const o=F.Zero(),h=p.length/6;let m=0,d=0,A=0,y=0,v=0,w=0,C=0,b=0;for(C=0;C<s.length-1;C++)s[C+1].subtractToRef(s[C],o),m+=o.length();A=m/h;const f=r._creationDataStorage.dashSize,_=r._creationDataStorage.gapSize;for(y=f*A/(f+_),C=0;C<s.length-1;C++)for(s[C+1].subtractToRef(s[C],o),d=Math.floor(o.length()/A),o.normalize(),b=0;b<d&&w<p.length;)v=A*b,p[w]=s[C].x+v*o.x,p[w+1]=s[C].y+v*o.y,p[w+2]=s[C].z+v*o.z,p[w+3]=s[C].x+(v+y)*o.x,p[w+4]=s[C].y+(v+y)*o.y,p[w+5]=s[C].z+(v+y)*o.z,w+=6,b++;for(;w<p.length;)p[w]=s[C].x,p[w+1]=s[C].y,p[w+2]=s[C].z,w+=3};return(t.dashNb||t.dashSize||t.gapSize||t.useVertexAlpha||t.material)&&ot.Warn("You have used an option other than points with the instance option. Please be aware that these other options will be ignored."),r.updateMeshPositions(x,!1),r}const c=new dt(a,e,null,void 0,void 0,void 0,t.useVertexAlpha,t.material);return Oe(t).applyToMesh(c,t.updatable),c._creationDataStorage=new $t,c._creationDataStorage.dashSize=n,c._creationDataStorage.gapSize=i,c}U.CreateLineSystem=be;U.CreateDashedLines=Oe;T.CreateLines=(a,t,e=null,s=!1,r=null)=>Ie(a,{points:t,updatable:s,instance:r},e);T.CreateDashedLines=(a,t,e,s,r,i=null,n,c)=>we(a,{points:t,dashSize:e,gapSize:s,dashNb:r,updatable:n,instance:c},i);class hs extends nt{constructor(t,e){super(t.x,t.y),this.index=e}}class Nt{constructor(){this.elements=[]}add(t){const e=[];for(const s of t){const r=new hs(s,this.elements.length);e.push(r),this.elements.push(r)}return e}computeBounds(){const t=new nt(this.elements[0].x,this.elements[0].y),e=new nt(this.elements[0].x,this.elements[0].y);for(const s of this.elements)s.x<t.x?t.x=s.x:s.x>e.x&&(e.x=s.x),s.y<t.y?t.y=s.y:s.y>e.y&&(e.y=s.y);return{min:t,max:e,width:e.x-t.x,height:e.y-t.y}}}class us{_addToepoint(t){for(const e of t)this._epoints.push(e.x,e.y)}constructor(t,e,s,r=earcut){this._points=new Nt,this._outlinepoints=new Nt,this._holes=new Array,this._epoints=new Array,this._eholes=new Array,this.bjsEarcut=r,this._name=t,this._scene=s||It.LastCreatedScene;let i;e instanceof ee?i=e.getPoints():i=e,this._addToepoint(i),this._points.add(i),this._outlinepoints.add(i),typeof this.bjsEarcut>"u"&&ot.Warn("Earcut was not found, the polygon will not be built.")}addHole(t){this._points.add(t);const e=new Nt;return e.add(t),this._holes.push(e),this._eholes.push(this._epoints.length/2),this._addToepoint(t),this}build(t=!1,e=0,s=2){const r=new T(this._name,this._scene),i=this.buildVertexData(e,s);return r.setVerticesData(K.PositionKind,i.positions,t),r.setVerticesData(K.NormalKind,i.normals,t),r.setVerticesData(K.UVKind,i.uvs,t),r.setIndices(i.indices),r}buildVertexData(t=0,e=2){const s=new U,r=[],i=[],n=[],c=this._points.computeBounds();for(const p of this._points.elements)r.push(0,1,0),i.push(p.x,0,p.y),n.push((p.x-c.min.x)/c.width,(p.y-c.min.y)/c.height);const u=[],x=this.bjsEarcut(this._epoints,this._eholes,2);for(let p=0;p<x.length;p++)u.push(x[p]);if(t>0){const p=i.length/3;for(const h of this._points.elements)r.push(0,-1,0),i.push(h.x,-t,h.y),n.push(1-(h.x-c.min.x)/c.width,1-(h.y-c.min.y)/c.height);const o=u.length;for(let h=0;h<o;h+=3){const m=u[h+0],d=u[h+1],A=u[h+2];u.push(A+p),u.push(d+p),u.push(m+p)}this._addSide(i,r,n,u,c,this._outlinepoints,t,!1,e);for(const h of this._holes)this._addSide(i,r,n,u,c,h,t,!0,e)}return s.indices=u,s.positions=i,s.normals=r,s.uvs=n,s}_addSide(t,e,s,r,i,n,c,u,x){let p=t.length/3,o=0;for(let h=0;h<n.elements.length;h++){const m=n.elements[h],d=n.elements[(h+1)%n.elements.length];t.push(m.x,0,m.y),t.push(m.x,-c,m.y),t.push(d.x,0,d.y),t.push(d.x,-c,d.y);const A=n.elements[(h+n.elements.length-1)%n.elements.length],y=n.elements[(h+2)%n.elements.length];let v=new F(-(d.y-m.y),0,d.x-m.x),w=new F(-(m.y-A.y),0,m.x-A.x),C=new F(-(y.y-d.y),0,y.x-d.x);u||(v=v.scale(-1),w=w.scale(-1),C=C.scale(-1));const b=v.normalizeToNew();let f=w.normalizeToNew(),_=C.normalizeToNew();const g=F.Dot(f,b);g>x?g<Ut-1?f=new F(m.x,0,m.y).subtract(new F(d.x,0,d.y)).normalize():f=w.add(v).normalize():f=b;const P=F.Dot(C,v);P>x?P<Ut-1?_=new F(d.x,0,d.y).subtract(new F(m.x,0,m.y)).normalize():_=C.add(v).normalize():_=b,s.push(o/i.width,0),s.push(o/i.width,1),o+=v.length(),s.push(o/i.width,0),s.push(o/i.width,1),e.push(f.x,f.y,f.z),e.push(f.x,f.y,f.z),e.push(_.x,_.y,_.z),e.push(_.x,_.y,_.z),u?(r.push(p),r.push(p+2),r.push(p+1),r.push(p+1),r.push(p+2),r.push(p+3)):(r.push(p),r.push(p+1),r.push(p+2),r.push(p+1),r.push(p+3),r.push(p+2)),p+=4}}}function Ce(a,t,e,s,r,i,n){const c=e||new Array(3),u=s,x=[],p=n||!1;for(let D=0;D<3;D++)c[D]===void 0&&(c[D]=new mt(0,0,1,1)),u&&u[D]===void 0&&(u[D]=new pt(1,1,1,1));const o=a.getVerticesData(K.PositionKind),h=a.getVerticesData(K.NormalKind),m=a.getVerticesData(K.UVKind),d=a.getIndices(),A=o.length/9;let y=0,v=0,w=0,C=0,b=0;const f=[0];if(p)for(let D=A;D<o.length/3;D+=4)v=o[3*(D+2)]-o[3*D],w=o[3*(D+2)+2]-o[3*D+2],C=Math.sqrt(v*v+w*w),b+=C,f.push(b);let _=0,g=0;for(let D=0;D<h.length;D+=3)Math.abs(h[D+1])<.001&&(g=1),Math.abs(h[D+1]-1)<.001&&(g=0),Math.abs(h[D+1]+1)<.001&&(g=2),_=D/3,g===1?(y=_-A,y%4<1.5?p?m[2*_]=c[g].x+(c[g].z-c[g].x)*f[Math.floor(y/4)]/b:m[2*_]=c[g].x:p?m[2*_]=c[g].x+(c[g].z-c[g].x)*f[Math.floor(y/4)+1]/b:m[2*_]=c[g].z,y%2===0?m[2*_+1]=c[g].w:m[2*_+1]=c[g].y):(m[2*_]=(1-m[2*_])*c[g].x+m[2*_]*c[g].z,m[2*_+1]=(1-m[2*_+1])*c[g].y+m[2*_+1]*c[g].w),u&&x.push(u[g].r,u[g].g,u[g].b,u[g].a);U._ComputeSides(t,o,d,h,m,r,i);const P=new U;if(P.indices=d,P.positions=o,P.normals=h,P.uvs=m,u){const D=t===U.DOUBLESIDE?x.concat(x):x;P.colors=D}return P}function Xt(a,t,e=null,s=earcut){t.sideOrientation=T._GetDefaultSideOrientation(t.sideOrientation);const r=t.shape,i=t.holes||[],n=t.depth||0,c=t.smoothingThreshold||2,u=[];let x=[];for(let d=0;d<r.length;d++)u[d]=new nt(r[d].x,r[d].z);u[0].equalsWithEpsilon(u[u.length-1],1e-8)&&u.pop();const o=new us(a,u,e||It.LastCreatedScene,s);for(let d=0;d<i.length;d++){x=[];for(let A=0;A<i[d].length;A++)x.push(new nt(i[d][A].x,i[d][A].z));o.addHole(x)}const h=o.build(!1,n,c);return h._originalBuilderSideOrientation=t.sideOrientation,Ce(h,t.sideOrientation,t.faceUV,t.faceColors,t.frontUVs,t.backUVs,t.wrap).applyToMesh(h,t.updatable),h}function Zt(a,t,e=null,s=earcut){return Xt(a,t,e,s)}U.CreatePolygon=Ce;T.CreatePolygon=(a,t,e,s,r,i,n=earcut)=>Xt(a,{shape:t,holes:s,updatable:r,sideOrientation:i},e,n);T.ExtrudePolygon=(a,t,e,s,r,i,n,c=earcut)=>Zt(a,{shape:t,holes:r,depth:e,updatable:i,sideOrientation:n},s,c);function De(a,t,e=null){const s=t.path,r=t.shape,i=t.scale||1,n=t.rotation||0,c=t.cap===0?0:t.cap||T.NO_CAP,u=t.updatable,x=T._GetDefaultSideOrientation(t.sideOrientation),p=t.instance||null,o=t.invertUV||!1,h=t.closeShape||!1,m=t.closePath||!1,d=t.capFunction||null;return Ve(a,r,s,i,n,null,null,m,h,c,!1,e,!!u,x,p,o,t.frontUVs||null,t.backUVs||null,t.firstNormal||null,!!t.adjustFrame,d)}function Pe(a,t,e=null){const s=t.path,r=t.shape,i=t.scaleFunction||(()=>1),n=t.rotationFunction||(()=>0),c=t.closePath||t.ribbonCloseArray||!1,u=t.closeShape||t.ribbonClosePath||!1,x=t.cap===0?0:t.cap||T.NO_CAP,p=t.updatable,o=t.firstNormal||null,h=t.adjustFrame||!1,m=T._GetDefaultSideOrientation(t.sideOrientation),d=t.instance,A=t.invertUV||!1,y=t.capFunction||null;return Ve(a,r,s,null,null,i,n,c,u,x,!0,e,!!p,m,d||null,A,t.frontUVs||null,t.backUVs||null,o,h,y||null)}function Ve(a,t,e,s,r,i,n,c,u,x,p,o,h,m,d,A,y,v,w,C,b){const f=(V,M,L,R,q,W,Y,N,X,B,E)=>{const l=L.getTangents(),O=L.getNormals(),I=L.getBinormals(),S=L.getDistances();if(E){for(let G=0;G<l.length;G++)if(l[G].x==0&&l[G].y==0&&l[G].z==0&&l[G].copyFrom(l[G-1]),O[G].x==0&&O[G].y==0&&O[G].z==0&&O[G].copyFrom(O[G-1]),I[G].x==0&&I[G].y==0&&I[G].z==0&&I[G].copyFrom(I[G-1]),G>0){let at=l[G-1];F.Dot(at,l[G])<0&&l[G].scaleInPlace(-1),at=O[G-1],F.Dot(at,O[G])<0&&O[G].scaleInPlace(-1),at=I[G-1],F.Dot(at,I[G])<0&&I[G].scaleInPlace(-1)}}let Z=0;const z=()=>q!==null?q:1,Q=B&&N?N:()=>W!==null?W:0,et=B&&Y?Y:z;let $=X===T.NO_CAP||X===T.CAP_END?0:2;const st=rt.Matrix[0];for(let G=0;G<M.length;G++){const at=[],lt=Q(G,S[G]),ct=et(G,S[G]);it.RotationAxisToRef(l[G],Z,st);for(let ht=0;ht<V.length;ht++){const yt=l[G].scale(V[ht].z).add(O[G].scale(V[ht].x)).add(I[G].scale(V[ht].y)),ft=F.Zero();F.TransformCoordinatesToRef(yt,st,ft),ft.scaleInPlace(ct).addInPlace(M[G]),at[ht]=ft}R[$]=at,Z+=lt,$++}const j=b||(G=>{const at=Array(),lt=F.Zero();let ct;for(ct=0;ct<G.length;ct++)lt.addInPlace(G[ct]);for(lt.scaleInPlace(1/G.length),ct=0;ct<G.length;ct++)at.push(lt);return at});switch(X){case T.NO_CAP:break;case T.CAP_START:R[0]=j(R[2]),R[1]=R[2];break;case T.CAP_END:R[$]=R[$-1],R[$+1]=j(R[$-1]);break;case T.CAP_ALL:R[0]=j(R[2]),R[1]=R[2],R[$]=R[$-1],R[$+1]=j(R[$-1]);break}return R};let _,g;if(d){const V=d._creationDataStorage;return _=w?V.path3D.update(e,w):V.path3D.update(e),g=f(t,e,V.path3D,V.pathArray,s,r,i,n,V.cap,p,C),d=_t("",{pathArray:g,closeArray:!1,closePath:!1,offset:0,updatable:!1,sideOrientation:0,instance:d},o||void 0),d}_=w?new Wt(e,w):new Wt(e);const P=new Array;x=x<0||x>3?0:x,g=f(t,e,_,P,s,r,i,n,x,p,C);const D=_t(a,{pathArray:g,closeArray:c,closePath:u,updatable:h,sideOrientation:m,invertUV:A,frontUVs:y||void 0,backUVs:v||void 0},o);return D._creationDataStorage.pathArray=g,D._creationDataStorage.path3D=_,D._creationDataStorage.cap=x,D}T.ExtrudeShape=(a,t,e,s,r,i,n=null,c,u,x)=>{const p={shape:t,path:e,scale:s,rotation:r,cap:i===0?0:i||T.NO_CAP,sideOrientation:u,instance:x,updatable:c};return De(a,p,n)};T.ExtrudeShapeCustom=(a,t,e,s,r,i,n,c,u,x,p,o)=>{const h={shape:t,path:e,scaleFunction:s,rotationFunction:r,ribbonCloseArray:i,ribbonClosePath:n,cap:c===0?0:c||T.NO_CAP,sideOrientation:p,instance:o,updatable:x};return Pe(a,h,u)};function Fe(a,t,e=null){const s=t.arc?t.arc<=0||t.arc>1?1:t.arc:1,r=t.closed===void 0?!0:t.closed,i=t.shape,n=t.radius||1,c=t.tessellation||64,u=t.clip||0,x=t.updatable,p=T._GetDefaultSideOrientation(t.sideOrientation),o=t.cap||T.NO_CAP,h=Math.PI*2,m=[],d=t.invertUV||!1;let A=0,y=0;const v=h/c*s;let w,C;for(A=0;A<=c-u;A++){for(C=[],(o==T.CAP_START||o==T.CAP_ALL)&&(C.push(new F(0,i[0].y,0)),C.push(new F(Math.cos(A*v)*i[0].x*n,i[0].y,Math.sin(A*v)*i[0].x*n))),y=0;y<i.length;y++)w=new F(Math.cos(A*v)*i[y].x*n,i[y].y,Math.sin(A*v)*i[y].x*n),C.push(w);(o==T.CAP_END||o==T.CAP_ALL)&&(C.push(new F(Math.cos(A*v)*i[i.length-1].x*n,i[i.length-1].y,Math.sin(A*v)*i[i.length-1].x*n)),C.push(new F(0,i[i.length-1].y,0))),m.push(C)}return _t(a,{pathArray:m,closeArray:r,sideOrientation:p,updatable:x,invertUV:d,frontUVs:t.frontUVs,backUVs:t.backUVs},e)}T.CreateLathe=(a,t,e,s,r,i,n)=>Fe(a,{shape:t,radius:e,tessellation:s,sideOrientation:n,updatable:i},r);function Ee(a){const t=[],e=[],s=[],r=[],i=a.width!==void 0?a.width:a.size!==void 0?a.size:1,n=a.height!==void 0?a.height:a.size!==void 0?a.size:1,c=a.sideOrientation===0?0:a.sideOrientation||U.DEFAULTSIDE,u=i/2,x=n/2;e.push(-u,-x,0),s.push(0,0,-1),r.push(0,0),e.push(u,-x,0),s.push(0,0,-1),r.push(1,0),e.push(u,x,0),s.push(0,0,-1),r.push(1,1),e.push(-u,x,0),s.push(0,0,-1),r.push(0,1),t.push(0),t.push(1),t.push(2),t.push(0),t.push(2),t.push(3),U._ComputeSides(c,e,t,s,r,a.frontUVs,a.backUVs);const p=new U;return p.indices=t,p.positions=e,p.normals=s,p.uvs=r,p}function Be(a,t={},e=null){const s=new T(a,e);return t.sideOrientation=T._GetDefaultSideOrientation(t.sideOrientation),s._originalBuilderSideOrientation=t.sideOrientation,Ee(t).applyToMesh(s,t.updatable),t.sourcePlane&&(s.translate(t.sourcePlane.normal,-t.sourcePlane.d),s.setDirection(t.sourcePlane.normal.scale(-1))),s}U.CreatePlane=Ee;T.CreatePlane=(a,t,e,s,r)=>Be(a,{size:t,width:t,height:t,sideOrientation:r,updatable:s},e);function Se(a,t,e=null){const s=t.path;let r=t.instance,i=1;t.radius!==void 0?i=t.radius:r&&(i=r._creationDataStorage.radius);const n=t.tessellation||64,c=t.radiusFunction||null;let u=t.cap||T.NO_CAP;const x=t.invertUV||!1,p=t.updatable,o=T._GetDefaultSideOrientation(t.sideOrientation);t.arc=t.arc&&(t.arc<=0||t.arc>1)?1:t.arc||1;const h=(v,w,C,b,f,_,g,P)=>{const D=w.getTangents(),V=w.getNormals(),M=w.getDistances(),R=Math.PI*2/f*P,W=_||(()=>b);let Y,N,X,B;const E=rt.Matrix[0];let l=g===T.NO_CAP||g===T.CAP_END?0:2;for(let I=0;I<v.length;I++){N=W(I,M[I]),Y=Array(),X=V[I];for(let S=0;S<f;S++)it.RotationAxisToRef(D[I],R*S,E),B=Y[S]?Y[S]:F.Zero(),F.TransformCoordinatesToRef(X,E,B),B.scaleInPlace(N).addInPlace(v[I]),Y[S]=B;C[l]=Y,l++}const O=(I,S)=>{const Z=Array();for(let z=0;z<I;z++)Z.push(v[S]);return Z};switch(g){case T.NO_CAP:break;case T.CAP_START:C[0]=O(f,0),C[1]=C[2].slice(0);break;case T.CAP_END:C[l]=C[l-1].slice(0),C[l+1]=O(f,v.length-1);break;case T.CAP_ALL:C[0]=O(f,0),C[1]=C[2].slice(0),C[l]=C[l-1].slice(0),C[l+1]=O(f,v.length-1);break}return C};let m,d;if(r){const v=r._creationDataStorage,w=t.arc||v.arc;return m=v.path3D.update(s),d=h(s,m,v.pathArray,i,v.tessellation,c,v.cap,w),r=_t("",{pathArray:d,instance:r}),v.path3D=m,v.pathArray=d,v.arc=w,v.radius=i,r}m=new Wt(s);const A=new Array;u=u<0||u>3?0:u,d=h(s,m,A,i,n,c,u,t.arc);const y=_t(a,{pathArray:d,closePath:!0,closeArray:!1,updatable:p,sideOrientation:o,invertUV:x,frontUVs:t.frontUVs,backUVs:t.backUVs},e);return y._creationDataStorage.pathArray=d,y._creationDataStorage.path3D=m,y._creationDataStorage.tessellation=n,y._creationDataStorage.cap=u,y._creationDataStorage.arc=t.arc,y._creationDataStorage.radius=i,y}T.CreateTube=(a,t,e,s,r,i,n,c,u,x)=>Se(a,{path:t,radius:e,tessellation:s,radiusFunction:r,arc:1,cap:i,updatable:c,sideOrientation:u,instance:x},n);function Me(a){const t=[];t[0]={vertex:[[0,0,1.732051],[1.632993,0,-.5773503],[-.8164966,1.414214,-.5773503],[-.8164966,-1.414214,-.5773503]],face:[[0,1,2],[0,2,3],[0,3,1],[1,3,2]]},t[1]={vertex:[[0,0,1.414214],[1.414214,0,0],[0,1.414214,0],[-1.414214,0,0],[0,-1.414214,0],[0,0,-1.414214]],face:[[0,1,2],[0,2,3],[0,3,4],[0,4,1],[1,4,5],[1,5,2],[2,5,3],[3,5,4]]},t[2]={vertex:[[0,0,1.070466],[.7136442,0,.7978784],[-.3568221,.618034,.7978784],[-.3568221,-.618034,.7978784],[.7978784,.618034,.3568221],[.7978784,-.618034,.3568221],[-.9341724,.381966,.3568221],[.1362939,1,.3568221],[.1362939,-1,.3568221],[-.9341724,-.381966,.3568221],[.9341724,.381966,-.3568221],[.9341724,-.381966,-.3568221],[-.7978784,.618034,-.3568221],[-.1362939,1,-.3568221],[-.1362939,-1,-.3568221],[-.7978784,-.618034,-.3568221],[.3568221,.618034,-.7978784],[.3568221,-.618034,-.7978784],[-.7136442,0,-.7978784],[0,0,-1.070466]],face:[[0,1,4,7,2],[0,2,6,9,3],[0,3,8,5,1],[1,5,11,10,4],[2,7,13,12,6],[3,9,15,14,8],[4,10,16,13,7],[5,8,14,17,11],[6,12,18,15,9],[10,11,17,19,16],[12,13,16,19,18],[14,15,18,19,17]]},t[3]={vertex:[[0,0,1.175571],[1.051462,0,.5257311],[.3249197,1,.5257311],[-.8506508,.618034,.5257311],[-.8506508,-.618034,.5257311],[.3249197,-1,.5257311],[.8506508,.618034,-.5257311],[.8506508,-.618034,-.5257311],[-.3249197,1,-.5257311],[-1.051462,0,-.5257311],[-.3249197,-1,-.5257311],[0,0,-1.175571]],face:[[0,1,2],[0,2,3],[0,3,4],[0,4,5],[0,5,1],[1,5,7],[1,7,6],[1,6,2],[2,6,8],[2,8,3],[3,8,9],[3,9,4],[4,9,10],[4,10,5],[5,10,7],[6,7,11],[6,11,8],[7,10,11],[8,11,9],[9,11,10]]},t[4]={vertex:[[0,0,1.070722],[.7148135,0,.7971752],[-.104682,.7071068,.7971752],[-.6841528,.2071068,.7971752],[-.104682,-.7071068,.7971752],[.6101315,.7071068,.5236279],[1.04156,.2071068,.1367736],[.6101315,-.7071068,.5236279],[-.3574067,1,.1367736],[-.7888348,-.5,.5236279],[-.9368776,.5,.1367736],[-.3574067,-1,.1367736],[.3574067,1,-.1367736],[.9368776,-.5,-.1367736],[.7888348,.5,-.5236279],[.3574067,-1,-.1367736],[-.6101315,.7071068,-.5236279],[-1.04156,-.2071068,-.1367736],[-.6101315,-.7071068,-.5236279],[.104682,.7071068,-.7971752],[.6841528,-.2071068,-.7971752],[.104682,-.7071068,-.7971752],[-.7148135,0,-.7971752],[0,0,-1.070722]],face:[[0,2,3],[1,6,5],[4,9,11],[7,15,13],[8,16,10],[12,14,19],[17,22,18],[20,21,23],[0,1,5,2],[0,3,9,4],[0,4,7,1],[1,7,13,6],[2,5,12,8],[2,8,10,3],[3,10,17,9],[4,11,15,7],[5,6,14,12],[6,13,20,14],[8,12,19,16],[9,17,18,11],[10,16,22,17],[11,18,21,15],[13,15,21,20],[14,20,23,19],[16,19,23,22],[18,22,23,21]]},t[5]={vertex:[[0,0,1.322876],[1.309307,0,.1889822],[-.9819805,.8660254,.1889822],[.1636634,-1.299038,.1889822],[.3273268,.8660254,-.9449112],[-.8183171,-.4330127,-.9449112]],face:[[0,3,1],[2,4,5],[0,1,4,2],[0,2,5,3],[1,3,5,4]]},t[6]={vertex:[[0,0,1.159953],[1.013464,0,.5642542],[-.3501431,.9510565,.5642542],[-.7715208,-.6571639,.5642542],[.6633206,.9510565,-.03144481],[.8682979,-.6571639,-.3996071],[-1.121664,.2938926,-.03144481],[-.2348831,-1.063314,-.3996071],[.5181548,.2938926,-.9953061],[-.5850262,-.112257,-.9953061]],face:[[0,1,4,2],[0,2,6,3],[1,5,8,4],[3,6,9,7],[5,7,9,8],[0,3,7,5,1],[2,4,8,9,6]]},t[7]={vertex:[[0,0,1.118034],[.8944272,0,.6708204],[-.2236068,.8660254,.6708204],[-.7826238,-.4330127,.6708204],[.6708204,.8660254,.2236068],[1.006231,-.4330127,-.2236068],[-1.006231,.4330127,.2236068],[-.6708204,-.8660254,-.2236068],[.7826238,.4330127,-.6708204],[.2236068,-.8660254,-.6708204],[-.8944272,0,-.6708204],[0,0,-1.118034]],face:[[0,1,4,2],[0,2,6,3],[1,5,8,4],[3,6,10,7],[5,9,11,8],[7,10,11,9],[0,3,7,9,5,1],[2,4,8,11,10,6]]},t[8]={vertex:[[-.729665,.670121,.319155],[-.655235,-.29213,-.754096],[-.093922,-.607123,.537818],[.702196,.595691,.485187],[.776626,-.36656,-.588064]],face:[[1,4,2],[0,1,2],[3,0,2],[4,3,2],[4,1,0,3]]},t[9]={vertex:[[-.868849,-.100041,.61257],[-.329458,.976099,.28078],[-.26629,-.013796,-.477654],[-.13392,-1.034115,.229829],[.738834,.707117,-.307018],[.859683,-.535264,-.338508]],face:[[3,0,2],[5,3,2],[4,5,2],[1,4,2],[0,1,2],[0,3,5,4,1]]},t[10]={vertex:[[-.610389,.243975,.531213],[-.187812,-.48795,-.664016],[-.187812,.9759,-.664016],[.187812,-.9759,.664016],[.798201,.243975,.132803]],face:[[1,3,0],[3,4,0],[3,1,4],[0,2,1],[0,4,2],[2,4,1]]},t[11]={vertex:[[-1.028778,.392027,-.048786],[-.640503,-.646161,.621837],[-.125162,-.395663,-.540059],[.004683,.888447,-.651988],[.125161,.395663,.540059],[.632925,-.791376,.433102],[1.031672,.157063,-.354165]],face:[[3,2,0],[2,1,0],[2,5,1],[0,4,3],[0,1,4],[4,1,5],[2,3,6],[3,4,6],[5,2,6],[4,5,6]]},t[12]={vertex:[[-.669867,.334933,-.529576],[-.669867,.334933,.529577],[-.4043,1.212901,0],[-.334933,-.669867,-.529576],[-.334933,-.669867,.529577],[.334933,.669867,-.529576],[.334933,.669867,.529577],[.4043,-1.212901,0],[.669867,-.334933,-.529576],[.669867,-.334933,.529577]],face:[[8,9,7],[6,5,2],[3,8,7],[5,0,2],[4,3,7],[0,1,2],[9,4,7],[1,6,2],[9,8,5,6],[8,3,0,5],[3,4,1,0],[4,9,6,1]]},t[13]={vertex:[[-.931836,.219976,-.264632],[-.636706,.318353,.692816],[-.613483,-.735083,-.264632],[-.326545,.979634,0],[-.318353,-.636706,.692816],[-.159176,.477529,-.856368],[.159176,-.477529,-.856368],[.318353,.636706,.692816],[.326545,-.979634,0],[.613482,.735082,-.264632],[.636706,-.318353,.692816],[.931835,-.219977,-.264632]],face:[[11,10,8],[7,9,3],[6,11,8],[9,5,3],[2,6,8],[5,0,3],[4,2,8],[0,1,3],[10,4,8],[1,7,3],[10,11,9,7],[11,6,5,9],[6,2,0,5],[2,4,1,0],[4,10,7,1]]},t[14]={vertex:[[-.93465,.300459,-.271185],[-.838689,-.260219,-.516017],[-.711319,.717591,.128359],[-.710334,-.156922,.080946],[-.599799,.556003,-.725148],[-.503838,-.004675,-.969981],[-.487004,.26021,.48049],[-.460089,-.750282,-.512622],[-.376468,.973135,-.325605],[-.331735,-.646985,.084342],[-.254001,.831847,.530001],[-.125239,-.494738,-.966586],[.029622,.027949,.730817],[.056536,-.982543,-.262295],[.08085,1.087391,.076037],[.125583,-.532729,.485984],[.262625,.599586,.780328],[.391387,-.726999,-.716259],[.513854,-.868287,.139347],[.597475,.85513,.326364],[.641224,.109523,.783723],[.737185,-.451155,.538891],[.848705,-.612742,-.314616],[.976075,.365067,.32976],[1.072036,-.19561,.084927]],face:[[15,18,21],[12,20,16],[6,10,2],[3,0,1],[9,7,13],[2,8,4,0],[0,4,5,1],[1,5,11,7],[7,11,17,13],[13,17,22,18],[18,22,24,21],[21,24,23,20],[20,23,19,16],[16,19,14,10],[10,14,8,2],[15,9,13,18],[12,15,21,20],[6,12,16,10],[3,6,2,0],[9,3,1,7],[9,15,12,6,3],[22,17,11,5,4,8,14,19,23,24]]};const e=a.type&&(a.type<0||a.type>=t.length)?0:a.type||0,s=a.size,r=a.sizeX||s||1,i=a.sizeY||s||1,n=a.sizeZ||s||1,c=a.custom||t[e],u=c.face.length,x=a.faceUV||new Array(u),p=a.faceColors,o=a.flat===void 0?!0:a.flat,h=a.sideOrientation===0?0:a.sideOrientation||U.DEFAULTSIDE,m=[],d=[],A=[],y=[],v=[];let w=0,C=0;const b=[];let f=0,_=0,g,P,D,V,M,L;if(o)for(_=0;_<u;_++)p&&p[_]===void 0&&(p[_]=new pt(1,1,1,1)),x&&x[_]===void 0&&(x[_]=new mt(0,0,1,1));if(o)for(_=0;_<u;_++){const q=c.face[_].length;for(D=2*Math.PI/q,V=.5*Math.tan(D/2),M=.5,f=0;f<q;f++)m.push(c.vertex[c.face[_][f]][0]*r,c.vertex[c.face[_][f]][1]*i,c.vertex[c.face[_][f]][2]*n),b.push(w),w++,g=x[_].x+(x[_].z-x[_].x)*(.5+V),P=x[_].y+(x[_].w-x[_].y)*(M-.5),y.push(g,P),L=V*Math.cos(D)-M*Math.sin(D),M=V*Math.sin(D)+M*Math.cos(D),V=L,p&&v.push(p[_].r,p[_].g,p[_].b,p[_].a);for(f=0;f<q-2;f++)d.push(b[0+C],b[f+2+C],b[f+1+C]);C+=q}else{for(f=0;f<c.vertex.length;f++)m.push(c.vertex[f][0]*r,c.vertex[f][1]*i,c.vertex[f][2]*n),y.push(0,0);for(_=0;_<u;_++)for(f=0;f<c.face[_].length-2;f++)d.push(c.face[_][0],c.face[_][f+2],c.face[_][f+1])}U.ComputeNormals(m,d,A),U._ComputeSides(h,m,d,A,y,a.frontUVs,a.backUVs);const R=new U;return R.positions=m,R.indices=d,R.normals=A,R.uvs=y,p&&o&&(R.colors=v),R}function Gt(a,t={},e=null){const s=new T(a,e);return t.sideOrientation=T._GetDefaultSideOrientation(t.sideOrientation),s._originalBuilderSideOrientation=t.sideOrientation,Me(t).applyToMesh(s,t.updatable),s}U.CreatePolyhedron=Me;T.CreatePolyhedron=(a,t,e)=>Gt(a,t,e);function ze(a){const t=a.sideOrientation||U.DEFAULTSIDE,e=a.radius||1,s=a.flat===void 0?!0:a.flat,r=(a.subdivisions||4)|0,i=a.radiusX||e,n=a.radiusY||e,c=a.radiusZ||e,u=(1+Math.sqrt(5))/2,x=[-1,u,-0,1,u,0,-1,-u,0,1,-u,0,0,-1,-u,0,1,-u,0,-1,u,0,1,u,u,0,1,u,0,-1,-u,0,1,-u,0,-1],p=[0,11,5,0,5,1,0,1,7,0,7,10,12,22,23,1,5,20,5,11,4,23,22,13,22,18,6,7,1,8,14,21,4,14,4,2,16,13,6,15,6,19,3,8,9,4,21,5,13,17,23,6,13,22,19,6,18,9,8,1],o=[0,1,2,3,4,5,6,7,8,9,10,11,0,2,3,3,3,4,7,8,9,9,10,11],h=[5,1,3,1,6,4,0,0,5,3,4,2,2,2,4,0,2,0,1,1,6,0,6,2,0,4,3,3,4,4,3,1,4,2,4,4,0,2,1,1,2,2,3,3,1,3,2,4],m=138/1024,d=239/1024,A=60/1024,y=26/1024,v=-40/1024,w=20/1024,C=[0,0,0,0,1,0,0,1,1,0,0,0,1,1,0,0,1,1,1,0],b=[],f=[],_=[],g=[];let P=0;const D=new Array(3),V=new Array(3);let M;for(M=0;M<3;M++)D[M]=F.Zero(),V[M]=nt.Zero();for(let R=0;R<20;R++){for(M=0;M<3;M++){const W=p[3*R+M];D[M].copyFromFloats(x[3*o[W]],x[3*o[W]+1],x[3*o[W]+2]),D[M].normalize(),V[M].copyFromFloats(h[2*W]*m+A+C[R]*v,h[2*W+1]*d+y+C[R]*w)}const q=(W,Y,N,X)=>{const B=F.Lerp(D[0],D[2],Y/r),E=F.Lerp(D[1],D[2],Y/r),l=r===Y?D[2]:F.Lerp(B,E,W/(r-Y));l.normalize();let O;if(s){const z=F.Lerp(D[0],D[2],X/r),H=F.Lerp(D[1],D[2],X/r);O=F.Lerp(z,H,N/(r-X))}else O=new F(l.x,l.y,l.z);O.x/=i,O.y/=n,O.z/=c,O.normalize();const I=nt.Lerp(V[0],V[2],Y/r),S=nt.Lerp(V[1],V[2],Y/r),Z=r===Y?V[2]:nt.Lerp(I,S,W/(r-Y));f.push(l.x*i,l.y*n,l.z*c),_.push(O.x,O.y,O.z),g.push(Z.x,Z.y),b.push(P),P++};for(let W=0;W<r;W++)for(let Y=0;Y+W<r;Y++)q(Y,W,Y+1/3,W+1/3),q(Y+1,W,Y+1/3,W+1/3),q(Y,W+1,Y+1/3,W+1/3),Y+W+1<r&&(q(Y+1,W,Y+2/3,W+2/3),q(Y+1,W+1,Y+2/3,W+2/3),q(Y,W+1,Y+2/3,W+2/3))}U._ComputeSides(t,f,b,_,g,a.frontUVs,a.backUVs);const L=new U;return L.indices=b,L.positions=f,L.normals=_,L.uvs=g,L}function Le(a,t={},e=null){const s=new T(a,e);return t.sideOrientation=T._GetDefaultSideOrientation(t.sideOrientation),s._originalBuilderSideOrientation=t.sideOrientation,ze(t).applyToMesh(s,t.updatable),s}U.CreateIcoSphere=ze;T.CreateIcoSphere=(a,t,e)=>Le(a,t,e);const fs=new F(1,0,0),ds=new F(-1,0,0),xs=new F(0,1,0),ps=new F(0,-1,0),gs=new F(0,0,1),ms=new F(0,0,-1);class Vt{constructor(t=F.Zero(),e=F.Up(),s=nt.Zero(),r=0,i=0,n=null,c=null,u=null,x=null){this.position=t,this.normal=e,this.uv=s,this.vertexIdx=r,this.vertexIdxForBones=i,this.localPositionOverride=n,this.localNormalOverride=c,this.matrixIndicesOverride=u,this.matrixWeightsOverride=x}clone(){return new Vt(this.position.clone(),this.normal.clone(),this.uv.clone(),this.vertexIdx,this.vertexIdxForBones,this.localPositionOverride?.slice(),this.localNormalOverride?.slice(),this.matrixIndicesOverride?.slice(),this.matrixWeightsOverride?.slice())}}function Re(a,t,e){const s=!!t.skeleton,r=!!t.morphTargetManager?.numTargets,i=e.localMode||s,n=t.getIndices(),c=s||r?t.getPositionData(!0,!0):t.getVerticesData(K.PositionKind),u=s||r?t.getNormalsData(!0,!0):t.getVerticesData(K.NormalKind),x=i?s?t.getVerticesData(K.PositionKind):c:null,p=i?s?t.getVerticesData(K.NormalKind):u:null,o=t.getVerticesData(K.UVKind),h=s?t.getVerticesData(K.MatricesIndicesKind):null,m=s?t.getVerticesData(K.MatricesWeightsKind):null,d=s?t.getVerticesData(K.MatricesIndicesExtraKind):null,A=s?t.getVerticesData(K.MatricesWeightsExtraKind):null,y=e.position||F.Zero();let v=e.normal||F.Up();const w=e.size||F.One(),C=e.angle||0;if(!v){const N=new F(0,0,1),X=t.getScene().activeCamera,B=F.TransformCoordinates(N,X.getWorldMatrix());v=X.globalPosition.subtract(B)}const b=-Math.atan2(v.z,v.x)-Math.PI/2,f=Math.sqrt(v.x*v.x+v.z*v.z),_=Math.atan2(v.y,f),g=new U;g.indices=[],g.positions=[],g.normals=[],g.uvs=[],g.matricesIndices=s?[]:null,g.matricesWeights=s?[]:null,g.matricesIndicesExtra=d?[]:null,g.matricesWeightsExtra=A?[]:null;let P=0;const D=(N,X)=>{const B=new Vt;if(!n||!c||!u)return B;const E=n[N];if(B.vertexIdx=E*3,B.vertexIdxForBones=E*4,B.position=new F(c[E*3],c[E*3+1],c[E*3+2]),F.TransformCoordinatesToRef(B.position,X,B.position),B.normal=new F(u[E*3],u[E*3+1],u[E*3+2]),F.TransformNormalToRef(B.normal,X,B.normal),e.captureUVS&&o){const l=o[E*2+1];B.uv=new nt(o[E*2],l)}return B},V=[0,0,0,0],M=(N,X)=>{if(N.length===0)return N;const B=.5*Math.abs(F.Dot(w,X)),E=(I,S,Z,z)=>{for(let H=0;H<z;++H)if(I[Z+H]===S)return Z+H;return-1},l=(I,S)=>{const Z=F.GetClipFactor(I.position,S.position,X,B);let z=V,H=V;if(h&&m){const bt=I.matrixIndicesOverride?0:I.vertexIdxForBones,St=I.matrixIndicesOverride??h,Ht=I.matrixWeightsOverride??m,Mt=S.matrixIndicesOverride?0:S.vertexIdxForBones,Yt=S.matrixIndicesOverride??h,qt=S.matrixWeightsOverride??m;z=[0,0,0,0],H=[0,0,0,0];let gt=0;for(let ut=0;ut<4;++ut)if(Ht[bt+ut]>0){const Ot=E(Yt,St[bt+ut],Mt,4);z[gt]=St[bt+ut],H[gt]=Qt(Ht[bt+ut],Ot>=0?qt[Ot]:0,Z),gt++}for(let ut=0;ut<4&&gt<4;++ut){const Ot=Yt[Mt+ut];E(St,Ot,bt,4)===-1&&(z[gt]=Ot,H[gt]=Qt(0,qt[Mt+ut],Z),gt++)}const Ct=H[0]+H[1]+H[2]+H[3];H[0]/=Ct,H[1]/=Ct,H[2]/=Ct,H[3]/=Ct}const Q=I.localPositionOverride?I.localPositionOverride[0]:x?.[I.vertexIdx]??0,et=I.localPositionOverride?I.localPositionOverride[1]:x?.[I.vertexIdx+1]??0,$=I.localPositionOverride?I.localPositionOverride[2]:x?.[I.vertexIdx+2]??0,st=S.localPositionOverride?S.localPositionOverride[0]:x?.[S.vertexIdx]??0,k=S.localPositionOverride?S.localPositionOverride[1]:x?.[S.vertexIdx+1]??0,j=S.localPositionOverride?S.localPositionOverride[2]:x?.[S.vertexIdx+2]??0,G=I.localNormalOverride?I.localNormalOverride[0]:p?.[I.vertexIdx]??0,at=I.localNormalOverride?I.localNormalOverride[1]:p?.[I.vertexIdx+1]??0,lt=I.localNormalOverride?I.localNormalOverride[2]:p?.[I.vertexIdx+2]??0,ct=S.localNormalOverride?S.localNormalOverride[0]:p?.[S.vertexIdx]??0,ht=S.localNormalOverride?S.localNormalOverride[1]:p?.[S.vertexIdx+1]??0,yt=S.localNormalOverride?S.localNormalOverride[2]:p?.[S.vertexIdx+2]??0,ft=G+(ct-G)*Z,At=at+(ht-at)*Z,vt=lt+(yt-lt)*Z,Bt=Math.sqrt(ft*ft+At*At+vt*vt);return new Vt(F.Lerp(I.position,S.position,Z),F.Lerp(I.normal,S.normal,Z).normalize(),nt.Lerp(I.uv,S.uv,Z),-1,-1,x?[Q+(st-Q)*Z,et+(k-et)*Z,$+(j-$)*Z]:null,p?[ft/Bt,At/Bt,vt/Bt]:null,z,H)};let O=null;N.length>3&&(O=[]);for(let I=0;I<N.length;I+=3){let S=0,Z=null,z=null,H=null,Q=null;const et=F.Dot(N[I].position,X)-B,$=F.Dot(N[I+1].position,X)-B,st=F.Dot(N[I+2].position,X)-B,k=et>0,j=$>0,G=st>0;switch(S=(k?1:0)+(j?1:0)+(G?1:0),S){case 0:N.length>3?(O.push(N[I]),O.push(N[I+1]),O.push(N[I+2])):O=N;break;case 1:if(O=O??new Array,k&&(Z=N[I+1],z=N[I+2],H=l(N[I],Z),Q=l(N[I],z)),j){Z=N[I],z=N[I+2],H=l(N[I+1],Z),Q=l(N[I+1],z),O.push(H),O.push(z.clone()),O.push(Z.clone()),O.push(z.clone()),O.push(H.clone()),O.push(Q);break}G&&(Z=N[I],z=N[I+1],H=l(N[I+2],Z),Q=l(N[I+2],z)),Z&&z&&H&&Q&&(O.push(Z.clone()),O.push(z.clone()),O.push(H),O.push(Q),O.push(H.clone()),O.push(z.clone()));break;case 2:O=O??new Array,k||(Z=N[I].clone(),z=l(Z,N[I+1]),H=l(Z,N[I+2]),O.push(Z),O.push(z),O.push(H)),j||(Z=N[I+1].clone(),z=l(Z,N[I+2]),H=l(Z,N[I]),O.push(Z),O.push(z),O.push(H)),G||(Z=N[I+2].clone(),z=l(Z,N[I]),H=l(Z,N[I+1]),O.push(Z),O.push(z),O.push(H));break}}return O},L=t instanceof T?t:null,R=L?._thinInstanceDataStorage.matrixData,q=L?.thinInstanceCount||1,W=rt.Matrix[0];W.copyFrom(it.IdentityReadOnly);for(let N=0;N<q;++N){if(L?.hasThinInstances&&R){const I=N*16;W.setRowFromFloats(0,R[I+0],R[I+1],R[I+2],R[I+3]),W.setRowFromFloats(1,R[I+4],R[I+5],R[I+6],R[I+7]),W.setRowFromFloats(2,R[I+8],R[I+9],R[I+10],R[I+11]),W.setRowFromFloats(3,R[I+12],R[I+13],R[I+14],R[I+15])}const X=it.RotationYawPitchRoll(b,_,C).multiply(it.Translation(y.x,y.y,y.z)),B=it.Invert(X),E=t.getWorldMatrix(),l=W.multiply(E).multiply(B),O=new Array(3);for(let I=0;I<n.length;I+=3){let S=O;if(S[0]=D(I,l),S[1]=D(I+1,l),S[2]=D(I+2,l),!(e.cullBackFaces&&-S[0].normal.z<=0&&-S[1].normal.z<=0&&-S[2].normal.z<=0)&&(S=M(S,fs),!!S&&(S=M(S,ds),!!S&&(S=M(S,xs),!!S&&(S=M(S,ps),!!S&&(S=M(S,gs),!!S&&(S=M(S,ms),!!S)))))))for(let Z=0;Z<S.length;Z++){const z=S[Z];if(g.indices.push(P),i?(z.localPositionOverride?(g.positions[P*3]=z.localPositionOverride[0],g.positions[P*3+1]=z.localPositionOverride[1],g.positions[P*3+2]=z.localPositionOverride[2]):x&&(g.positions[P*3]=x[z.vertexIdx],g.positions[P*3+1]=x[z.vertexIdx+1],g.positions[P*3+2]=x[z.vertexIdx+2]),z.localNormalOverride?(g.normals[P*3]=z.localNormalOverride[0],g.normals[P*3+1]=z.localNormalOverride[1],g.normals[P*3+2]=z.localNormalOverride[2]):p&&(g.normals[P*3]=p[z.vertexIdx],g.normals[P*3+1]=p[z.vertexIdx+1],g.normals[P*3+2]=p[z.vertexIdx+2])):(z.position.toArray(g.positions,P*3),z.normal.toArray(g.normals,P*3)),g.matricesIndices&&g.matricesWeights&&(z.matrixIndicesOverride?(g.matricesIndices[P*4]=z.matrixIndicesOverride[0],g.matricesIndices[P*4+1]=z.matrixIndicesOverride[1],g.matricesIndices[P*4+2]=z.matrixIndicesOverride[2],g.matricesIndices[P*4+3]=z.matrixIndicesOverride[3]):(h&&(g.matricesIndices[P*4]=h[z.vertexIdxForBones],g.matricesIndices[P*4+1]=h[z.vertexIdxForBones+1],g.matricesIndices[P*4+2]=h[z.vertexIdxForBones+2],g.matricesIndices[P*4+3]=h[z.vertexIdxForBones+3]),d&&g.matricesIndicesExtra&&(g.matricesIndicesExtra[P*4]=d[z.vertexIdxForBones],g.matricesIndicesExtra[P*4+1]=d[z.vertexIdxForBones+1],g.matricesIndicesExtra[P*4+2]=d[z.vertexIdxForBones+2],g.matricesIndicesExtra[P*4+3]=d[z.vertexIdxForBones+3])),z.matrixWeightsOverride?(g.matricesWeights[P*4]=z.matrixWeightsOverride[0],g.matricesWeights[P*4+1]=z.matrixWeightsOverride[1],g.matricesWeights[P*4+2]=z.matrixWeightsOverride[2],g.matricesWeights[P*4+3]=z.matrixWeightsOverride[3]):(m&&(g.matricesWeights[P*4]=m[z.vertexIdxForBones],g.matricesWeights[P*4+1]=m[z.vertexIdxForBones+1],g.matricesWeights[P*4+2]=m[z.vertexIdxForBones+2],g.matricesWeights[P*4+3]=m[z.vertexIdxForBones+3]),A&&g.matricesWeightsExtra&&(g.matricesWeightsExtra[P*4]=A[z.vertexIdxForBones],g.matricesWeightsExtra[P*4+1]=A[z.vertexIdxForBones+1],g.matricesWeightsExtra[P*4+2]=A[z.vertexIdxForBones+2],g.matricesWeightsExtra[P*4+3]=A[z.vertexIdxForBones+3]))),e.captureUVS)z.uv.toArray(g.uvs,P*2);else{g.uvs.push(.5+z.position.x/w.x);const H=.5+z.position.y/w.y;g.uvs.push(H)}P++}}}g.indices.length===0&&(g.indices=null),g.positions.length===0&&(g.positions=null),g.normals.length===0&&(g.normals=null),g.uvs.length===0&&(g.uvs=null),g.matricesIndices?.length===0&&(g.matricesIndices=null),g.matricesWeights?.length===0&&(g.matricesWeights=null),g.matricesIndicesExtra?.length===0&&(g.matricesIndicesExtra=null),g.matricesWeightsExtra?.length===0&&(g.matricesWeightsExtra=null);const Y=new T(a,t.getScene());return g.applyToMesh(Y),i?(Y.skeleton=t.skeleton,Y.parent=t):(Y.position=y.clone(),Y.rotation=new F(_,b,C)),Y.computeWorldMatrix(!0),Y.refreshBoundingInfo(!0,!0),Y}T.CreateDecal=(a,t,e,s,r,i)=>Re(a,t,{position:e,normal:s,size:r,angle:i});function Ne(a={subdivisions:2,tessellation:16,height:1,radius:.25,capSubdivisions:6}){const t=Math.max(a.subdivisions?a.subdivisions:2,1)|0,e=Math.max(a.tessellation?a.tessellation:16,3)|0,s=Math.max(a.height?a.height:1,0),r=Math.max(a.radius?a.radius:.25,0),i=Math.max(a.capSubdivisions?a.capSubdivisions:6,1)|0,n=e,c=t,u=Math.max(a.radiusTop?a.radiusTop:r,0),x=Math.max(a.radiusBottom?a.radiusBottom:r,0),p=s-(u+x),o=0,h=2*Math.PI,m=Math.max(a.topCapSubdivisions?a.topCapSubdivisions:i,1),d=Math.max(a.bottomCapSubdivisions?a.bottomCapSubdivisions:i,1),A=Math.acos((x-u)/s);let y=[];const v=[],w=[],C=[];let b=0;const f=[],_=p*.5,g=Math.PI*.5;let P,D;const V=F.Zero(),M=F.Zero(),L=Math.cos(A),R=Math.sin(A),q=new nt(u*R,_+u*L).subtract(new nt(x*R,-_+x*L)).length(),W=u*A+q+x*(g-A);let Y=0;for(D=0;D<=m;D++){const E=[],l=g-A*(D/m);Y+=u*A/m;const O=Math.cos(l),I=Math.sin(l),S=O*u;for(P=0;P<=n;P++){const Z=P/n,z=Z*h+o,H=Math.sin(z),Q=Math.cos(z);M.x=S*H,M.y=_+I*u,M.z=S*Q,v.push(M.x,M.y,M.z),V.set(O*H,I,O*Q),w.push(V.x,V.y,V.z),C.push(Z,1-Y/W),E.push(b),b++}f.push(E)}const N=s-u-x+L*u-L*x,X=R*(x-u)/N;for(D=1;D<=c;D++){const E=[];Y+=q/c;const l=R*(D*(x-u)/c+u);for(P=0;P<=n;P++){const O=P/n,I=O*h+o,S=Math.sin(I),Z=Math.cos(I);M.x=l*S,M.y=_+L*u-D*N/c,M.z=l*Z,v.push(M.x,M.y,M.z),V.set(S,X,Z).normalize(),w.push(V.x,V.y,V.z),C.push(O,1-Y/W),E.push(b),b++}f.push(E)}for(D=1;D<=d;D++){const E=[],l=g-A-(Math.PI-A)*(D/d);Y+=x*A/d;const O=Math.cos(l),I=Math.sin(l),S=O*x;for(P=0;P<=n;P++){const Z=P/n,z=Z*h+o,H=Math.sin(z),Q=Math.cos(z);M.x=S*H,M.y=-_+I*x,M.z=S*Q,v.push(M.x,M.y,M.z),V.set(O*H,I,O*Q),w.push(V.x,V.y,V.z),C.push(Z,1-Y/W),E.push(b),b++}f.push(E)}for(P=0;P<n;P++)for(D=0;D<m+c+d;D++){const E=f[D][P],l=f[D+1][P],O=f[D+1][P+1],I=f[D][P+1];y.push(E),y.push(l),y.push(I),y.push(l),y.push(O),y.push(I)}if(y=y.reverse(),a.orientation&&!a.orientation.equals(F.Up())){const E=new it;a.orientation.clone().scale(Math.PI*.5).cross(F.Up()).toQuaternion().toRotationMatrix(E);const l=F.Zero();for(let O=0;O<v.length;O+=3)l.set(v[O],v[O+1],v[O+2]),F.TransformCoordinatesToRef(l.clone(),E,l),v[O]=l.x,v[O+1]=l.y,v[O+2]=l.z}const B=new U;return B.positions=v,B.normals=w,B.uvs=C,B.indices=y,B}function Ue(a,t={orientation:F.Up(),subdivisions:2,tessellation:16,height:1,radius:.25,capSubdivisions:6,updatable:!1},e=null){const s=new T(a,e);return Ne(t).applyToMesh(s,t.updatable),s}T.CreateCapsule=(a,t,e)=>Ue(a,t,e);U.CreateCapsule=Ne;class J{constructor(t=0,e=0){this.x=t,this.y=e,t!==Math.floor(t)&&(t=Math.floor(t),ot.Warn("x is not an integer, floor(x) used")),e!==Math.floor(e)&&(e=Math.floor(e),ot.Warn("y is not an integer, floor(y) used"))}clone(){return new J(this.x,this.y)}rotate60About(t){const e=this.x;return this.x=t.x+t.y-this.y,this.y=e+this.y-t.x,this}rotateNeg60About(t){const e=this.x;return this.x=e+this.y-t.y,this.y=t.x+t.y-e,this}rotate120(t,e){t!==Math.floor(t)&&(t=Math.floor(t),ot.Warn("m not an integer only floor(m) used")),e!==Math.floor(e)&&(e=Math.floor(e),ot.Warn("n not an integer only floor(n) used"));const s=this.x;return this.x=t-s-this.y,this.y=e+s,this}rotateNeg120(t,e){t!==Math.floor(t)&&(t=Math.floor(t),ot.Warn("m is not an integer, floor(m) used")),e!==Math.floor(e)&&(e=Math.floor(e),ot.Warn("n is not an integer,   floor(n) used"));const s=this.x;return this.x=this.y-e,this.y=t+e-s-this.y,this}toCartesianOrigin(t,e){const s=F.Zero();return s.x=t.x+2*this.x*e+this.y*e,s.y=t.y+Math.sqrt(3)*this.y*e,s}static Zero(){return new J(0,0)}}class We{constructor(){this.cartesian=[],this.vertices=[],this.max=[],this.min=[],this.closestTo=[],this.innerFacets=[],this.isoVecsABOB=[],this.isoVecsOBOA=[],this.isoVecsBAOA=[],this.vertexTypes=[],this.IDATA=new kt("icosahedron","Regular",[[0,tt,-1],[-tt,1,0],[-1,0,-tt],[1,0,-tt],[tt,1,0],[0,tt,1],[-1,0,tt],[-tt,-1,0],[0,-tt,-1],[tt,-1,0],[1,0,tt],[0,-tt,1]],[[0,2,1],[0,3,2],[0,4,3],[0,5,4],[0,1,5],[7,6,1],[8,7,2],[9,8,3],[10,9,4],[6,10,5],[2,7,1],[3,8,2],[4,9,3],[5,10,4],[1,6,5],[11,6,7],[11,7,8],[11,8,9],[11,9,10],[11,10,6]])}setIndices(){let t=12;const e={},s=this.m,r=this.n;let i=s,n=1,c=0;r!==0&&(i=Jt(s,r)),n=s/i,c=r/i;let u,x,p,o,h;const m=J.Zero(),d=new J(s,r),A=new J(-r,s+r),y=J.Zero(),v=J.Zero(),w=J.Zero();let C=[],b,f,_,g;const P=[],D=this.vertByDist,V=(M,L,R,q)=>{b=M+"|"+R,f=L+"|"+q,b in e||f in e?b in e&&!(f in e)?e[f]=e[b]:f in e&&!(b in e)&&(e[b]=e[f]):(e[b]=t,e[f]=t,t++),D[R][0]>2?P[e[b]]=[-D[R][0],D[R][1],e[b]]:P[e[b]]=[C[D[R][0]],D[R][1],e[b]]};this.IDATA.edgematch=[[1,"B"],[2,"B"],[3,"B"],[4,"B"],[0,"B"],[10,"O",14,"A"],[11,"O",10,"A"],[12,"O",11,"A"],[13,"O",12,"A"],[14,"O",13,"A"],[0,"O"],[1,"O"],[2,"O"],[3,"O"],[4,"O"],[19,"B",5,"A"],[15,"B",6,"A"],[16,"B",7,"A"],[17,"B",8,"A"],[18,"B",9,"A"]];for(let M=0;M<20;M++){if(C=this.IDATA.face[M],p=C[2],o=C[1],h=C[0],_=m.x+"|"+m.y,b=M+"|"+_,b in e||(e[b]=p,P[p]=[C[D[_][0]],D[_][1]]),_=d.x+"|"+d.y,b=M+"|"+_,b in e||(e[b]=o,P[o]=[C[D[_][0]],D[_][1]]),_=A.x+"|"+A.y,b=M+"|"+_,b in e||(e[b]=h,P[h]=[C[D[_][0]],D[_][1]]),u=this.IDATA.edgematch[M][0],x=this.IDATA.edgematch[M][1],x==="B")for(let L=1;L<i;L++)v.x=s-L*(n+c),v.y=r+L*n,w.x=-L*c,w.y=L*(n+c),_=v.x+"|"+v.y,g=w.x+"|"+w.y,V(M,u,_,g);if(x==="O")for(let L=1;L<i;L++)w.x=-L*c,w.y=L*(n+c),y.x=L*n,y.y=L*c,_=w.x+"|"+w.y,g=y.x+"|"+y.y,V(M,u,_,g);if(u=this.IDATA.edgematch[M][2],x=this.IDATA.edgematch[M][3],x&&x==="A")for(let L=1;L<i;L++)y.x=L*n,y.y=L*c,v.x=s-(i-L)*(n+c),v.y=r+(i-L)*n,_=y.x+"|"+y.y,g=v.x+"|"+v.y,V(M,u,_,g);for(let L=0;L<this.vertices.length;L++)_=this.vertices[L].x+"|"+this.vertices[L].y,b=M+"|"+_,b in e||(e[b]=t++,D[_][0]>2?P[e[b]]=[-D[_][0],D[_][1],e[b]]:P[e[b]]=[C[D[_][0]],D[_][1],e[b]])}this.closestTo=P,this.vecToidx=e}calcCoeffs(){const t=this.m,e=this.n,s=Math.sqrt(3)/3,r=t*t+e*e+t*e;this.coau=(t+e)/r,this.cobu=-e/r,this.coav=-s*(t-e)/r,this.cobv=s*(2*t+e)/r}createInnerFacets(){const t=this.m,e=this.n;for(let s=0;s<e+t+1;s++)for(let r=this.min[s];r<this.max[s]+1;r++)r<this.max[s]&&r<this.max[s+1]+1&&this.innerFacets.push(["|"+r+"|"+s,"|"+r+"|"+(s+1),"|"+(r+1)+"|"+s]),s>0&&r<this.max[s-1]&&r+1<this.max[s]+1&&this.innerFacets.push(["|"+r+"|"+s,"|"+(r+1)+"|"+s,"|"+(r+1)+"|"+(s-1)])}edgeVecsABOB(){const t=this.m,e=this.n,s=new J(-e,t+e);for(let r=1;r<t+e;r++){const i=new J(this.min[r],r),n=new J(this.min[r-1],r-1),c=new J(this.min[r+1],r+1),u=i.clone(),x=n.clone(),p=c.clone();u.rotate60About(s),x.rotate60About(s),p.rotate60About(s);const o=new J(this.max[u.y],u.y),h=new J(this.max[u.y-1],u.y-1),m=new J(this.max[u.y-1]-1,u.y-1);(u.x!==o.x||u.y!==o.y)&&(u.x!==h.x?(this.vertexTypes.push([1,0,0]),this.isoVecsABOB.push([i,h,m]),this.vertexTypes.push([1,0,0]),this.isoVecsABOB.push([i,m,o])):u.y===p.y?(this.vertexTypes.push([1,1,0]),this.isoVecsABOB.push([i,n,h]),this.vertexTypes.push([1,0,1]),this.isoVecsABOB.push([i,h,c])):(this.vertexTypes.push([1,1,0]),this.isoVecsABOB.push([i,n,h]),this.vertexTypes.push([1,0,0]),this.isoVecsABOB.push([i,h,o])))}}mapABOBtoOBOA(){const t=new J(0,0);for(let e=0;e<this.isoVecsABOB.length;e++){const s=[];for(let r=0;r<3;r++)t.x=this.isoVecsABOB[e][r].x,t.y=this.isoVecsABOB[e][r].y,this.vertexTypes[e][r]===0&&t.rotateNeg120(this.m,this.n),s.push(t.clone());this.isoVecsOBOA.push(s)}}mapABOBtoBAOA(){const t=new J(0,0);for(let e=0;e<this.isoVecsABOB.length;e++){const s=[];for(let r=0;r<3;r++)t.x=this.isoVecsABOB[e][r].x,t.y=this.isoVecsABOB[e][r].y,this.vertexTypes[e][r]===1&&t.rotate120(this.m,this.n),s.push(t.clone());this.isoVecsBAOA.push(s)}}MapToFace(t,e){const s=this.IDATA.face[t],r=s[2],i=s[1],n=s[0],c=F.FromArray(this.IDATA.vertex[r]),u=F.FromArray(this.IDATA.vertex[i]),x=F.FromArray(this.IDATA.vertex[n]),p=u.subtract(c),o=x.subtract(c),h=p.scale(this.coau).add(o.scale(this.cobu)),m=p.scale(this.coav).add(o.scale(this.cobv));let d,A=rt.Vector3[0];for(let y=0;y<this.cartesian.length;y++)A=h.scale(this.cartesian[y].x).add(m.scale(this.cartesian[y].y)).add(c),A.x,A.y,A.z,d=t+"|"+this.vertices[y].x+"|"+this.vertices[y].y,e.vertex[this.vecToidx[d]]=[A.x,A.y,A.z]}build(t,e){const s=[],r=J.Zero(),i=new J(t,e),n=new J(-e,t+e);s.push(r,i,n);for(let f=e;f<t+1;f++)for(let _=0;_<t+1-f;_++)s.push(new J(_,f));if(e>0){const f=Jt(t,e),_=t/f,g=e/f;for(let D=1;D<f;D++)s.push(new J(D*_,D*g)),s.push(new J(-D*g,D*(_+g))),s.push(new J(t-D*(_+g),e+D*_));const P=t/e;for(let D=1;D<e;D++)for(let V=0;V<D*P;V++)s.push(new J(V,D)),s.push(new J(V,D).rotate120(t,e)),s.push(new J(V,D).rotateNeg120(t,e))}s.sort((f,_)=>f.x-_.x),s.sort((f,_)=>f.y-_.y);const c=new Array(t+e+1),u=new Array(t+e+1);for(let f=0;f<c.length;f++)c[f]=1/0,u[f]=-1/0;let x=0,p=0;const o=s.length;for(let f=0;f<o;f++)p=s[f].x,x=s[f].y,c[x]=Math.min(p,c[x]),u[x]=Math.max(p,u[x]);const h=(f,_)=>{const g=f.clone();return _==="A"&&g.rotateNeg120(t,e),_==="B"&&g.rotate120(t,e),g.x<0?g.y:g.x+g.y},m=[],d=[],A=[],y=[],v={},w=[];let C=-1,b=-1;for(let f=0;f<o;f++)m[f]=s[f].toCartesianOrigin(new J(0,0),.5),d[f]=h(s[f],"O"),A[f]=h(s[f],"A"),y[f]=h(s[f],"B"),d[f]===A[f]&&A[f]===y[f]?(C=3,b=d[f]):d[f]===A[f]?(C=4,b=d[f]):A[f]===y[f]?(C=5,b=A[f]):y[f]===d[f]&&(C=6,b=d[f]),d[f]<A[f]&&d[f]<y[f]&&(C=2,b=d[f]),A[f]<d[f]&&A[f]<y[f]&&(C=1,b=A[f]),y[f]<A[f]&&y[f]<d[f]&&(C=0,b=y[f]),w.push([C,b,s[f].x,s[f].y]);w.sort((f,_)=>f[2]-_[2]),w.sort((f,_)=>f[3]-_[3]),w.sort((f,_)=>f[1]-_[1]),w.sort((f,_)=>f[0]-_[0]);for(let f=0;f<w.length;f++)v[w[f][2]+"|"+w[f][3]]=[w[f][0],w[f][1],f];return this.m=t,this.n=e,this.vertices=s,this.vertByDist=v,this.cartesian=m,this.min=c,this.max=u,this}}class kt{constructor(t,e,s,r){this.name=t,this.category=e,this.vertex=s,this.face=r}}class Ft extends kt{innerToData(t,e){for(let s=0;s<e.innerFacets.length;s++)this.face.push(e.innerFacets[s].map(r=>e.vecToidx[t+r]))}mapABOBtoDATA(t,e){const s=e.IDATA.edgematch[t][0];for(let r=0;r<e.isoVecsABOB.length;r++){const i=[];for(let n=0;n<3;n++)e.vertexTypes[r][n]===0?i.push(t+"|"+e.isoVecsABOB[r][n].x+"|"+e.isoVecsABOB[r][n].y):i.push(s+"|"+e.isoVecsABOB[r][n].x+"|"+e.isoVecsABOB[r][n].y);this.face.push([e.vecToidx[i[0]],e.vecToidx[i[1]],e.vecToidx[i[2]]])}}mapOBOAtoDATA(t,e){const s=e.IDATA.edgematch[t][0];for(let r=0;r<e.isoVecsOBOA.length;r++){const i=[];for(let n=0;n<3;n++)e.vertexTypes[r][n]===1?i.push(t+"|"+e.isoVecsOBOA[r][n].x+"|"+e.isoVecsOBOA[r][n].y):i.push(s+"|"+e.isoVecsOBOA[r][n].x+"|"+e.isoVecsOBOA[r][n].y);this.face.push([e.vecToidx[i[0]],e.vecToidx[i[1]],e.vecToidx[i[2]]])}}mapBAOAtoDATA(t,e){const s=e.IDATA.edgematch[t][2];for(let r=0;r<e.isoVecsBAOA.length;r++){const i=[];for(let n=0;n<3;n++)e.vertexTypes[r][n]===1?i.push(t+"|"+e.isoVecsBAOA[r][n].x+"|"+e.isoVecsBAOA[r][n].y):i.push(s+"|"+e.isoVecsBAOA[r][n].x+"|"+e.isoVecsBAOA[r][n].y);this.face.push([e.vecToidx[i[0]],e.vecToidx[i[1]],e.vecToidx[i[2]]])}}orderData(t){const e=[];for(let n=0;n<13;n++)e[n]=[];const s=t.closestTo;for(let n=0;n<s.length;n++)s[n][0]>-1?s[n][1]>0&&e[s[n][0]].push([n,s[n][1]]):e[12].push([n,s[n][0]]);const r=[];for(let n=0;n<12;n++)r[n]=n;let i=12;for(let n=0;n<12;n++){e[n].sort((c,u)=>c[1]-u[1]);for(let c=0;c<e[n].length;c++)r[e[n][c][0]]=i++}for(let n=0;n<e[12].length;n++)r[e[12][n][0]]=i++;for(let n=0;n<this.vertex.length;n++)this.vertex[n].push(r[n]);this.vertex.sort((n,c)=>n[3]-c[3]);for(let n=0;n<this.vertex.length;n++)this.vertex[n].pop();for(let n=0;n<this.face.length;n++)for(let c=0;c<this.face[n].length;c++)this.face[n][c]=r[this.face[n][c]];this.sharedNodes=e[12].length,this.poleNodes=this.vertex.length-this.sharedNodes}setOrder(t,e){const s=[],r=[];let i=e.pop();r.push(i);let n=this.face[i].indexOf(t);n=(n+2)%3;let c=this.face[i][n];s.push(c);let u=0;for(;e.length>0;)i=e[u],this.face[i].indexOf(c)>-1?(n=(this.face[i].indexOf(c)+1)%3,c=this.face[i][n],s.push(c),r.push(i),e.splice(u,1),u=0):u++;return this.adjacentFaces.push(s),r}toGoldbergPolyhedronData(){const t=new kt("GeoDual","Goldberg",[],[]);t.name="GD dual";const e=this.vertex.length,s=new Array(e);for(let x=0;x<e;x++)s[x]=[];for(let x=0;x<this.face.length;x++)for(let p=0;p<3;p++)s[this.face[x][p]].push(x);let r=0,i=0,n=0,c=[],u=[];this.adjacentFaces=[];for(let x=0;x<s.length;x++){t.face[x]=this.setOrder(x,s[x].concat([]));for(const p of s[x]){r=0,i=0,n=0,c=this.face[p];for(let o=0;o<3;o++)u=this.vertex[c[o]],r+=u[0],i+=u[1],n+=u[2];t.vertex[p]=[r/3,i/3,n/3]}}return t}static BuildGeodesicData(t){const e=new Ft("Geodesic-m-n","Geodesic",[[0,tt,-1],[-tt,1,0],[-1,0,-tt],[1,0,-tt],[tt,1,0],[0,tt,1],[-1,0,tt],[-tt,-1,0],[0,-tt,-1],[tt,-1,0],[1,0,tt],[0,-tt,1]],[]);t.setIndices(),t.calcCoeffs(),t.createInnerFacets(),t.edgeVecsABOB(),t.mapABOBtoOBOA(),t.mapABOBtoBAOA();for(let r=0;r<t.IDATA.face.length;r++)t.MapToFace(r,e),e.innerToData(r,t),t.IDATA.edgematch[r][1]==="B"&&e.mapABOBtoDATA(r,t),t.IDATA.edgematch[r][1]==="O"&&e.mapOBOAtoDATA(r,t),t.IDATA.edgematch[r][3]==="A"&&e.mapBAOAtoDATA(r,t);e.orderData(t);const s=1;return e.vertex=e.vertex.map(function(r){const i=r[0],n=r[1],c=r[2],u=Math.sqrt(i*i+n*n+c*c);return r[0]*=s/u,r[1]*=s/u,r[2]*=s/u,r}),e}}function _s(a,t,e=null){let s=t.m||1;s!==Math.floor(s)&&(s=Math.floor(s),ot.Warn("m not an integer only floor(m) used"));let r=t.n||0;if(r!==Math.floor(r)&&(r=Math.floor(r),ot.Warn("n not an integer only floor(n) used")),r>s){const x=r;r=s,s=x,ot.Warn("n > m therefore m and n swapped")}const i=new We;i.build(s,r);const c={custom:Ft.BuildGeodesicData(i),size:t.size,sizeX:t.sizeX,sizeY:t.sizeY,sizeZ:t.sizeZ,faceUV:t.faceUV,faceColors:t.faceColors,flat:t.flat,updatable:t.updatable,sideOrientation:t.sideOrientation,frontUVs:t.frontUVs,backUVs:t.backUVs};return Gt(a,c,e)}T._GoldbergMeshParser=(a,t)=>Et.Parse(a,t);class Et extends T{constructor(){super(...arguments),this.goldbergData={faceColors:[],faceCenters:[],faceZaxis:[],faceXaxis:[],faceYaxis:[],nbSharedFaces:0,nbUnsharedFaces:0,nbFaces:0,nbFacesAtPole:0,adjacentFaces:[]}}relatedGoldbergFace(t,e){return e===void 0?(t>this.goldbergData.nbUnsharedFaces-1&&(ot.Warn("Maximum number of unshared faces used"),t=this.goldbergData.nbUnsharedFaces-1),this.goldbergData.nbUnsharedFaces+t):(t>11&&(ot.Warn("Last pole used"),t=11),e>this.goldbergData.nbFacesAtPole-1&&(ot.Warn("Maximum number of faces at a pole used"),e=this.goldbergData.nbFacesAtPole-1),12+t*this.goldbergData.nbFacesAtPole+e)}_changeGoldbergFaceColors(t){for(let s=0;s<t.length;s++){const r=t[s][0],i=t[s][1],n=t[s][2];for(let c=r;c<i+1;c++)this.goldbergData.faceColors[c]=n}const e=[];for(let s=0;s<12;s++)for(let r=0;r<5;r++)e.push(this.goldbergData.faceColors[s].r,this.goldbergData.faceColors[s].g,this.goldbergData.faceColors[s].b,this.goldbergData.faceColors[s].a);for(let s=12;s<this.goldbergData.faceColors.length;s++)for(let r=0;r<6;r++)e.push(this.goldbergData.faceColors[s].r,this.goldbergData.faceColors[s].g,this.goldbergData.faceColors[s].b,this.goldbergData.faceColors[s].a);return e}setGoldbergFaceColors(t){const e=this._changeGoldbergFaceColors(t);this.setVerticesData(K.ColorKind,e)}updateGoldbergFaceColors(t){const e=this._changeGoldbergFaceColors(t);this.updateVerticesData(K.ColorKind,e)}_changeGoldbergFaceUVs(t){const e=this.getVerticesData(K.UVKind);for(let s=0;s<t.length;s++){const r=t[s][0],i=t[s][1],n=t[s][2],c=t[s][3],u=t[s][4],x=[],p=[];let o,h;for(let m=0;m<5;m++)o=n.x+c*Math.cos(u+m*Math.PI/2.5),h=n.y+c*Math.sin(u+m*Math.PI/2.5),o<0&&(o=0),o>1&&(o=1),x.push(o,h);for(let m=0;m<6;m++)o=n.x+c*Math.cos(u+m*Math.PI/3),h=n.y+c*Math.sin(u+m*Math.PI/3),o<0&&(o=0),o>1&&(o=1),p.push(o,h);for(let m=r;m<Math.min(12,i+1);m++)for(let d=0;d<5;d++)e[10*m+2*d]=x[2*d],e[10*m+2*d+1]=x[2*d+1];for(let m=Math.max(12,r);m<i+1;m++)for(let d=0;d<6;d++)e[12*m-24+2*d]=p[2*d],e[12*m-23+2*d]=p[2*d+1]}return e}setGoldbergFaceUVs(t){const e=this._changeGoldbergFaceUVs(t);this.setVerticesData(K.UVKind,e)}updateGoldbergFaceUVs(t){const e=this._changeGoldbergFaceUVs(t);this.updateVerticesData(K.UVKind,e)}placeOnGoldbergFaceAt(t,e,s){const r=F.RotationFromAxis(this.goldbergData.faceXaxis[e],this.goldbergData.faceYaxis[e],this.goldbergData.faceZaxis[e]);t.rotation=r,t.position=this.goldbergData.faceCenters[e].add(this.goldbergData.faceXaxis[e].scale(s.x)).add(this.goldbergData.faceYaxis[e].scale(s.y)).add(this.goldbergData.faceZaxis[e].scale(s.z))}serialize(t){super.serialize(t),t.type="GoldbergMesh";const e={};if(e.adjacentFaces=this.goldbergData.adjacentFaces,e.nbSharedFaces=this.goldbergData.nbSharedFaces,e.nbUnsharedFaces=this.goldbergData.nbUnsharedFaces,e.nbFaces=this.goldbergData.nbFaces,e.nbFacesAtPole=this.goldbergData.nbFacesAtPole,this.goldbergData.faceColors){e.faceColors=[];for(const s of this.goldbergData.faceColors)e.faceColors.push(s.asArray())}if(this.goldbergData.faceCenters){e.faceCenters=[];for(const s of this.goldbergData.faceCenters)e.faceCenters.push(s.asArray())}if(this.goldbergData.faceZaxis){e.faceZaxis=[];for(const s of this.goldbergData.faceZaxis)e.faceZaxis.push(s.asArray())}if(this.goldbergData.faceYaxis){e.faceYaxis=[];for(const s of this.goldbergData.faceYaxis)e.faceYaxis.push(s.asArray())}if(this.goldbergData.faceXaxis){e.faceXaxis=[];for(const s of this.goldbergData.faceXaxis)e.faceXaxis.push(s.asArray())}t.goldbergData=e}static Parse(t,e){const s=t.goldbergData;s.faceColors=s.faceColors.map(i=>pt.FromArray(i)),s.faceCenters=s.faceCenters.map(i=>F.FromArray(i)),s.faceZaxis=s.faceZaxis.map(i=>F.FromArray(i)),s.faceXaxis=s.faceXaxis.map(i=>F.FromArray(i)),s.faceYaxis=s.faceYaxis.map(i=>F.FromArray(i));const r=new Et(t.name,e);return r.goldbergData=s,r}}function ys(a,t){const e=a.size,s=a.sizeX||e||1,r=a.sizeY||e||1,i=a.sizeZ||e||1,n=a.sideOrientation===0?0:a.sideOrientation||U.DEFAULTSIDE,c=[],u=[],x=[],p=[];let o=1/0,h=-1/0,m=1/0,d=-1/0;for(let v=0;v<t.vertex.length;v++)o=Math.min(o,t.vertex[v][0]*s),h=Math.max(h,t.vertex[v][0]*s),m=Math.min(m,t.vertex[v][1]*r),d=Math.max(d,t.vertex[v][1]*r);let A=0;for(let v=0;v<t.face.length;v++){const w=t.face[v],C=F.FromArray(t.vertex[w[0]]),b=F.FromArray(t.vertex[w[2]]),f=F.FromArray(t.vertex[w[1]]),_=b.subtract(C),g=f.subtract(C),P=F.Cross(g,_).normalize();for(let D=0;D<w.length;D++){x.push(P.x,P.y,P.z);const V=t.vertex[w[D]];c.push(V[0]*s,V[1]*r,V[2]*i);const M=(V[1]*r-m)/(d-m);p.push((V[0]*s-o)/(h-o),M)}for(let D=0;D<w.length-2;D++)u.push(A,A+D+2,A+D+1);A+=w.length}U._ComputeSides(n,c,u,x,p);const y=new U;return y.positions=c,y.indices=u,y.normals=x,y.uvs=p,y}function As(a,t,e=null){const s=t.size,r=t.sizeX||s||1,i=t.sizeY||s||1,n=t.sizeZ||s||1;let c=t.m||1;c!==Math.floor(c)&&(c=Math.floor(c),ot.Warn("m not an integer only floor(m) used"));let u=t.n||0;if(u!==Math.floor(u)&&(u=Math.floor(u),ot.Warn("n not an integer only floor(n) used")),u>c){const d=u;u=c,c=d,ot.Warn("n > m therefore m and n swapped")}const x=new We;x.build(c,u);const p=Ft.BuildGeodesicData(x),o=p.toGoldbergPolyhedronData(),h=new Et(a,e);t.sideOrientation=T._GetDefaultSideOrientation(t.sideOrientation),h._originalBuilderSideOrientation=t.sideOrientation,ys(t,o).applyToMesh(h,t.updatable),h.goldbergData.nbSharedFaces=p.sharedNodes,h.goldbergData.nbUnsharedFaces=p.poleNodes,h.goldbergData.adjacentFaces=p.adjacentFaces,h.goldbergData.nbFaces=h.goldbergData.nbSharedFaces+h.goldbergData.nbUnsharedFaces,h.goldbergData.nbFacesAtPole=(h.goldbergData.nbUnsharedFaces-12)/12;for(let d=0;d<p.vertex.length;d++)h.goldbergData.faceCenters.push(F.FromArray(p.vertex[d])),h.goldbergData.faceCenters[d].x*=r,h.goldbergData.faceCenters[d].y*=i,h.goldbergData.faceCenters[d].z*=n,h.goldbergData.faceColors.push(new pt(1,1,1,1));for(let d=0;d<o.face.length;d++){const A=o.face[d],y=F.FromArray(o.vertex[A[0]]),v=F.FromArray(o.vertex[A[2]]),w=F.FromArray(o.vertex[A[1]]),C=v.subtract(y),b=w.subtract(y),f=F.Cross(b,C).normalize(),_=F.Cross(b,f).normalize();h.goldbergData.faceXaxis.push(b.normalize()),h.goldbergData.faceYaxis.push(f),h.goldbergData.faceZaxis.push(_)}return h}class vs{constructor(t){this._paths=[],this._tempPaths=[],this._holes=[],this._resolution=t}moveTo(t,e){this._currentPath=new ee(t,e),this._tempPaths.push(this._currentPath)}lineTo(t,e){this._currentPath.addLineTo(t,e)}quadraticCurveTo(t,e,s,r){this._currentPath.addQuadraticCurveTo(t,e,s,r,this._resolution)}bezierCurveTo(t,e,s,r,i,n){this._currentPath.addBezierCurveTo(t,e,s,r,i,n,this._resolution)}extractHoles(){for(const t of this._tempPaths)t.area()>0?this._holes.push(t):this._paths.push(t);if(!this._paths.length&&this._holes.length){const t=this._holes;this._holes=this._paths,this._paths=t}this._tempPaths.length=0}get paths(){return this._paths}get holes(){return this._holes}}function bs(a,t,e,s,r,i){const n=i.glyphs[a]||i.glyphs["?"];if(!n)return null;const c=new vs(r);if(n.o){const u=n.o.split(" ");for(let x=0,p=u.length;x<p;)switch(u[x++]){case"m":{const h=parseInt(u[x++])*t+e,m=parseInt(u[x++])*t+s;c.moveTo(h,m);break}case"l":{const h=parseInt(u[x++])*t+e,m=parseInt(u[x++])*t+s;c.lineTo(h,m);break}case"q":{const h=parseInt(u[x++])*t+e,m=parseInt(u[x++])*t+s,d=parseInt(u[x++])*t+e,A=parseInt(u[x++])*t+s;c.quadraticCurveTo(d,A,h,m);break}case"b":{const h=parseInt(u[x++])*t+e,m=parseInt(u[x++])*t+s,d=parseInt(u[x++])*t+e,A=parseInt(u[x++])*t+s,y=parseInt(u[x++])*t+e,v=parseInt(u[x++])*t+s;c.bezierCurveTo(d,A,y,v,h,m);break}}}return c.extractHoles(),{offsetX:n.ha*t,shapePath:c}}function Os(a,t,e,s){const r=Array.from(a),i=t/s.resolution,n=(s.boundingBox.yMax-s.boundingBox.yMin+s.underlineThickness)*i,c=[];let u=0,x=0;for(let p=0;p<r.length;p++){const o=r[p];if(o===`
`)u=0,x-=n;else{const h=bs(o,i,u,x,e,s);h&&(u+=h.offsetX,c.push(h.shapePath))}}return c}function Ts(a,t,e,s={size:50,resolution:8,depth:1},r=null,i=earcut){const n=Os(t,s.size||50,s.resolution||8,e),c=[];let u=0;for(const p of n){if(!p.paths.length)continue;const o=p.holes.slice();for(const h of p.paths){const m=[],d=[],A=h.getPoints();for(const w of A)d.push(new F(w.x,0,w.y));const y=o.slice();for(const w of y){const C=w.getPoints();let b=!1;for(const _ of C)if(h.isPointInside(_)){b=!0;break}if(!b)continue;const f=[];for(const _ of C)f.push(new F(_.x,0,_.y));m.push(f),o.splice(o.indexOf(w),1)}if(!m.length&&o.length)for(const w of o){const C=w.getPoints(),b=[];for(const f of C)b.push(new F(f.x,0,f.y));m.push(b)}const v=Zt(a,{shape:d,holes:m.length?m:void 0,depth:s.depth||1,faceUV:s.faceUV||s.perLetterFaceUV?.(u),faceColors:s.faceColors||s.perLetterFaceColors?.(u),sideOrientation:T._GetDefaultSideOrientation(s.sideOrientation||T.DOUBLESIDE)},r,i);c.push(v),u++}}const x=T.MergeMeshes(c,!0,!0);if(x){const p=x.getBoundingInfo().boundingBox;x.position.x+=-(p.minimumWorld.x+p.maximumWorld.x)/2,x.position.y+=-(p.minimumWorld.y+p.maximumWorld.y)/2,x.position.z+=-(p.minimumWorld.z+p.maximumWorld.z)/2+p.extendSize.z,x.name=a;const o=new as("pivot",r);o.rotation.x=-Math.PI/2,x.parent=o,x.bakeCurrentTransformIntoVertices(),x.parent=null,o.dispose()}return x}const ws={CreateBox:fe,CreateTiledBox:cs,CreateSphere:pe,CreateDisc:ie,CreateIcoSphere:Le,CreateRibbon:_t,CreateCylinder:me,CreateTorus:ye,CreateTorusKnot:ve,CreateLineSystem:Te,CreateLines:Ie,CreateDashedLines:we,ExtrudeShape:De,ExtrudeShapeCustom:Pe,CreateLathe:Fe,CreateTiledPlane:os,CreatePlane:Be,CreateGround:ce,CreateTiledGround:le,CreateGroundFromHeightMap:he,CreatePolygon:Xt,ExtrudePolygon:Zt,CreateTube:Se,CreatePolyhedron:Gt,CreateGeodesic:_s,CreateGoldberg:As,CreateDecal:Re,CreateCapsule:Ue,CreateText:Ts};export{ws as M};
