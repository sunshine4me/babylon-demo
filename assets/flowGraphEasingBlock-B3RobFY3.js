import{ae as h,af as i,ai as E,d as o,aP as d,aQ as w,aR as B,B as n,aS as C,aT as m,R as f}from"./index-dzV0rMYg.js";var l;(function(e){e[e.CircleEase=0]="CircleEase",e[e.BackEase=1]="BackEase",e[e.BounceEase=2]="BounceEase",e[e.CubicEase=3]="CubicEase",e[e.ElasticEase=4]="ElasticEase",e[e.ExponentialEase=5]="ExponentialEase",e[e.PowerEase=6]="PowerEase",e[e.QuadraticEase=7]="QuadraticEase",e[e.QuarticEase=8]="QuarticEase",e[e.QuinticEase=9]="QuinticEase",e[e.SineEase=10]="SineEase",e[e.BezierCurveEase=11]="BezierCurveEase"})(l||(l={}));function k(e,...a){switch(e){case 11:return new m(...a);case 0:return new C;case 1:return new n(...a);case 2:return new B(...a);case 3:return new w;case 4:return new d(...a);case 5:return new o(...a);default:throw new Error("Easing type not yet implemented")}}class Q extends h{constructor(a){super(a),this.config=a,this._easingFunctions={},this.type=this.registerDataInput("type",i,11),this.mode=this.registerDataInput("mode",E,0),this.parameters=this.registerDataInput("parameters",i,[1,0,0,1]),this.easingFunction=this.registerDataOutput("easingFunction",i)}_updateOutputs(a){const s=this.type.getValue(a),t=this.mode.getValue(a),u=this.parameters.getValue(a);if(s===void 0||t===void 0)return;const r=`${s}-${t}-${u.join("-")}`;if(!this._easingFunctions[r]){const c=k(s,...u);c.setEasingMode(t),this._easingFunctions[r]=c}this.easingFunction.setValue(this._easingFunctions[r],a)}getClassName(){return"FlowGraphEasingBlock"}}f("FlowGraphEasingBlock",Q);export{l as EasingFunctionType,Q as FlowGraphEasingBlock};
