import{J as m,K as N,g as R,N as C,O as G,U as X,X as H,V as l,Y as q,f as S,Z as r,$ as h,a0 as V,a1 as Q,a2 as J,a3 as E,a4 as $,i as I,T as P,a5 as j,a6 as tt,d as L,Q as F,M as z,a7 as O,a8 as Z,a9 as U,aa as et,ab as it,R as W,ac as Y,C as st,ad as at}from"./index-DHuikXXi.js";class nt{constructor(){this._zoomStopsAnimation=!1,this._idleRotationSpeed=.05,this._idleRotationWaitTime=2e3,this._idleRotationSpinupTime=2e3,this.targetAlpha=null,this._isPointerDown=!1,this._lastFrameTime=null,this._lastInteractionTime=-1/0,this._cameraRotationSpeed=0,this._lastFrameRadius=0}get name(){return"AutoRotation"}set zoomStopsAnimation(t){this._zoomStopsAnimation=t}get zoomStopsAnimation(){return this._zoomStopsAnimation}set idleRotationSpeed(t){this._idleRotationSpeed=t}get idleRotationSpeed(){return this._idleRotationSpeed}set idleRotationWaitTime(t){this._idleRotationWaitTime=t}get idleRotationWaitTime(){return this._idleRotationWaitTime}set idleRotationSpinupTime(t){this._idleRotationSpinupTime=t}get idleRotationSpinupTime(){return this._idleRotationSpinupTime}get rotationInProgress(){return Math.abs(this._cameraRotationSpeed)>0}init(){}attach(t){this._attachedCamera=t;const e=this._attachedCamera.getScene();this._onPrePointerObservableObserver=e.onPrePointerObservable.add(i=>{if(i.type===m.POINTERDOWN){this._isPointerDown=!0;return}i.type===m.POINTERUP&&(this._isPointerDown=!1)}),this._onAfterCheckInputsObserver=t.onAfterCheckInputsObservable.add(()=>{if(this._reachTargetAlpha())return;const i=N.Now;let s=0;this._lastFrameTime!=null&&(s=i-this._lastFrameTime),this._lastFrameTime=i,this._applyUserInteraction();const n=i-this._lastInteractionTime-this._idleRotationWaitTime,o=Math.max(Math.min(n/this._idleRotationSpinupTime,1),0);this._cameraRotationSpeed=this._idleRotationSpeed*o,this._attachedCamera&&(this._attachedCamera.alpha-=this._cameraRotationSpeed*(s/1e3))})}detach(){if(!this._attachedCamera)return;const t=this._attachedCamera.getScene();this._onPrePointerObservableObserver&&t.onPrePointerObservable.remove(this._onPrePointerObservableObserver),this._attachedCamera.onAfterCheckInputsObservable.remove(this._onAfterCheckInputsObserver),this._attachedCamera=null,this._lastFrameTime=null}resetLastInteractionTime(t){this._lastInteractionTime=t??N.Now}_reachTargetAlpha(){return this._attachedCamera&&this.targetAlpha?Math.abs(this._attachedCamera.alpha-this.targetAlpha)<R:!1}_userIsZooming(){return this._attachedCamera?this._attachedCamera.inertialRadiusOffset!==0:!1}_shouldAnimationStopForInteraction(){if(!this._attachedCamera)return!1;let t=!1;return this._lastFrameRadius===this._attachedCamera.radius&&this._attachedCamera.inertialRadiusOffset!==0&&(t=!0),this._lastFrameRadius=this._attachedCamera.radius,this._zoomStopsAnimation?t:this._userIsZooming()}_applyUserInteraction(){this._userIsMoving()&&!this._shouldAnimationStopForInteraction()&&(this._lastInteractionTime=N.Now)}_userIsMoving(){return this._attachedCamera?this._attachedCamera.inertialAlphaOffset!==0||this._attachedCamera.inertialBetaOffset!==0||this._attachedCamera.inertialRadiusOffset!==0||this._attachedCamera.inertialPanningX!==0||this._attachedCamera.inertialPanningY!==0||this._isPointerDown:!1}}class M{constructor(){this.transitionDuration=450,this.lowerRadiusTransitionRange=2,this.upperRadiusTransitionRange=-2,this._autoTransitionRange=!1,this._radiusIsAnimating=!1,this._radiusBounceTransition=null,this._animatables=new Array}get name(){return"Bouncing"}get autoTransitionRange(){return this._autoTransitionRange}set autoTransitionRange(t){if(this._autoTransitionRange===t)return;this._autoTransitionRange=t;const e=this._attachedCamera;e&&(t?this._onMeshTargetChangedObserver=e.onMeshTargetChangedObservable.add(i=>{if(i&&(i.computeWorldMatrix(!0),i.getBoundingInfo)){const s=i.getBoundingInfo().diagonalLength;this.lowerRadiusTransitionRange=s*.05,this.upperRadiusTransitionRange=s*.05}}):this._onMeshTargetChangedObserver&&e.onMeshTargetChangedObservable.remove(this._onMeshTargetChangedObserver))}init(){}attach(t){this._attachedCamera=t,this._onAfterCheckInputsObserver=t.onAfterCheckInputsObservable.add(()=>{this._attachedCamera&&(this._isRadiusAtLimit(this._attachedCamera.lowerRadiusLimit)&&this._applyBoundRadiusAnimation(this.lowerRadiusTransitionRange),this._isRadiusAtLimit(this._attachedCamera.upperRadiusLimit)&&this._applyBoundRadiusAnimation(this.upperRadiusTransitionRange))})}detach(){this._attachedCamera&&(this._onAfterCheckInputsObserver&&this._attachedCamera.onAfterCheckInputsObservable.remove(this._onAfterCheckInputsObserver),this._onMeshTargetChangedObserver&&this._attachedCamera.onMeshTargetChangedObservable.remove(this._onMeshTargetChangedObserver),this._attachedCamera=null)}_isRadiusAtLimit(t){return this._attachedCamera?this._attachedCamera.radius===t&&!this._radiusIsAnimating:!1}_applyBoundRadiusAnimation(t){if(!this._attachedCamera)return;this._radiusBounceTransition||(M.EasingFunction.setEasingMode(M.EasingMode),this._radiusBounceTransition=C.CreateAnimation("radius",C.ANIMATIONTYPE_FLOAT,60,M.EasingFunction)),this._cachedWheelPrecision=this._attachedCamera.wheelPrecision,this._attachedCamera.wheelPrecision=1/0,this._attachedCamera.inertialRadiusOffset=0,this.stopAllAnimations(),this._radiusIsAnimating=!0;const e=C.TransitionTo("radius",this._attachedCamera.radius+t,this._attachedCamera,this._attachedCamera.getScene(),60,this._radiusBounceTransition,this.transitionDuration,()=>this._clearAnimationLocks());e&&this._animatables.push(e)}_clearAnimationLocks(){this._radiusIsAnimating=!1,this._attachedCamera&&(this._attachedCamera.wheelPrecision=this._cachedWheelPrecision)}stopAllAnimations(){for(this._attachedCamera&&(this._attachedCamera.animations=[]);this._animatables.length;)this._animatables[0].onAnimationEnd=null,this._animatables[0].stop(),this._animatables.shift()}}M.EasingFunction=new G(.3);M.EasingMode=X.EASINGMODE_EASEOUT;class b{constructor(){this.onTargetFramingAnimationEndObservable=new H,this._mode=b.FitFrustumSidesMode,this._radiusScale=1,this._positionScale=.5,this._defaultElevation=.3,this._elevationReturnTime=1500,this._elevationReturnWaitTime=1e3,this._zoomStopsAnimation=!1,this._framingTime=1500,this.autoCorrectCameraLimitsAndSensibility=!0,this._isPointerDown=!1,this._lastInteractionTime=-1/0,this._animatables=new Array,this._betaIsAnimating=!1}get name(){return"Framing"}set mode(t){this._mode=t}get mode(){return this._mode}set radiusScale(t){this._radiusScale=t}get radiusScale(){return this._radiusScale}set positionScale(t){this._positionScale=t}get positionScale(){return this._positionScale}set defaultElevation(t){this._defaultElevation=t}get defaultElevation(){return this._defaultElevation}set elevationReturnTime(t){this._elevationReturnTime=t}get elevationReturnTime(){return this._elevationReturnTime}set elevationReturnWaitTime(t){this._elevationReturnWaitTime=t}get elevationReturnWaitTime(){return this._elevationReturnWaitTime}set zoomStopsAnimation(t){this._zoomStopsAnimation=t}get zoomStopsAnimation(){return this._zoomStopsAnimation}set framingTime(t){this._framingTime=t}get framingTime(){return this._framingTime}init(){}attach(t){this._attachedCamera=t;const e=this._attachedCamera.getScene();b.EasingFunction.setEasingMode(b.EasingMode),this._onPrePointerObservableObserver=e.onPrePointerObservable.add(i=>{if(i.type===m.POINTERDOWN){this._isPointerDown=!0;return}i.type===m.POINTERUP&&(this._isPointerDown=!1)}),this._onMeshTargetChangedObserver=t.onMeshTargetChangedObservable.add(i=>{i&&i.getBoundingInfo&&this.zoomOnMesh(i,void 0,()=>{this.onTargetFramingAnimationEndObservable.notifyObservers()})}),this._onAfterCheckInputsObserver=t.onAfterCheckInputsObservable.add(()=>{this._applyUserInteraction(),this._maintainCameraAboveGround()})}detach(){if(!this._attachedCamera)return;const t=this._attachedCamera.getScene();this._onPrePointerObservableObserver&&t.onPrePointerObservable.remove(this._onPrePointerObservableObserver),this._onAfterCheckInputsObserver&&this._attachedCamera.onAfterCheckInputsObservable.remove(this._onAfterCheckInputsObserver),this._onMeshTargetChangedObserver&&this._attachedCamera.onMeshTargetChangedObservable.remove(this._onMeshTargetChangedObserver),this._attachedCamera=null}zoomOnMesh(t,e=!1,i=null){t.computeWorldMatrix(!0);const s=t.getBoundingInfo().boundingBox;this.zoomOnBoundingInfo(s.minimumWorld,s.maximumWorld,e,i)}zoomOnMeshHierarchy(t,e=!1,i=null){t.computeWorldMatrix(!0);const s=t.getHierarchyBoundingVectors(!0);this.zoomOnBoundingInfo(s.min,s.max,e,i)}zoomOnMeshesHierarchy(t,e=!1,i=null){const s=new l(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE),n=new l(-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE);for(let o=0;o<t.length;o++){const c=t[o].getHierarchyBoundingVectors(!0);l.CheckExtends(c.min,s,n),l.CheckExtends(c.max,s,n)}this.zoomOnBoundingInfo(s,n,e,i)}zoomOnBoundingInfo(t,e,i=!1,s=null){let n;if(!this._attachedCamera)return!1;const o=t.y,c=e.y,a=o+(c-o)*this._positionScale,p=e.subtract(t).scale(.5);if(!isFinite(a))return!1;if(i)n=new l(0,a,0);else{const g=t.add(p);n=new l(g.x,a,g.z)}this._vectorTransition||(this._vectorTransition=C.CreateAnimation("target",C.ANIMATIONTYPE_VECTOR3,60,b.EasingFunction)),this._betaIsAnimating=!0;let _=C.TransitionTo("target",n,this._attachedCamera,this._attachedCamera.getScene(),60,this._vectorTransition,this._framingTime);_&&this._animatables.push(_);let f=0;if(this._mode===b.FitFrustumSidesMode){const g=this._calculateLowerRadiusFromModelBoundingSphere(t,e);this.autoCorrectCameraLimitsAndSensibility&&(this._attachedCamera.lowerRadiusLimit=p.length()+this._attachedCamera.minZ),f=g}else this._mode===b.IgnoreBoundsSizeMode&&(f=this._calculateLowerRadiusFromModelBoundingSphere(t,e),this.autoCorrectCameraLimitsAndSensibility&&this._attachedCamera.lowerRadiusLimit===null&&(this._attachedCamera.lowerRadiusLimit=this._attachedCamera.minZ));if(this.autoCorrectCameraLimitsAndSensibility){const g=e.subtract(t).length();this._attachedCamera.panningSensibility=5e3/g,this._attachedCamera.wheelPrecision=100/f}return this._radiusTransition||(this._radiusTransition=C.CreateAnimation("radius",C.ANIMATIONTYPE_FLOAT,60,b.EasingFunction)),_=C.TransitionTo("radius",f,this._attachedCamera,this._attachedCamera.getScene(),60,this._radiusTransition,this._framingTime,()=>{this.stopAllAnimations(),s&&s(),this._attachedCamera&&this._attachedCamera.useInputToRestoreState&&this._attachedCamera.storeState()}),_&&this._animatables.push(_),!0}_calculateLowerRadiusFromModelBoundingSphere(t,e){const i=this._attachedCamera;if(!i)return 0;let s=i._calculateLowerRadiusFromModelBoundingSphere(t,e,this._radiusScale);return i.lowerRadiusLimit&&this._mode===b.IgnoreBoundsSizeMode&&(s=s<i.lowerRadiusLimit?i.lowerRadiusLimit:s),i.upperRadiusLimit&&(s=s>i.upperRadiusLimit?i.upperRadiusLimit:s),s}_maintainCameraAboveGround(){if(this._elevationReturnTime<0)return;const t=N.Now-this._lastInteractionTime,e=Math.PI*.5-this._defaultElevation,i=Math.PI*.5;if(this._attachedCamera&&!this._betaIsAnimating&&this._attachedCamera.beta>i&&t>=this._elevationReturnWaitTime){this._betaIsAnimating=!0,this.stopAllAnimations(),this._betaTransition||(this._betaTransition=C.CreateAnimation("beta",C.ANIMATIONTYPE_FLOAT,60,b.EasingFunction));const s=C.TransitionTo("beta",e,this._attachedCamera,this._attachedCamera.getScene(),60,this._betaTransition,this._elevationReturnTime,()=>{this._clearAnimationLocks(),this.stopAllAnimations()});s&&this._animatables.push(s)}}_clearAnimationLocks(){this._betaIsAnimating=!1}_applyUserInteraction(){this.isUserIsMoving&&(this._lastInteractionTime=N.Now,this.stopAllAnimations(),this._clearAnimationLocks())}stopAllAnimations(){for(this._attachedCamera&&(this._attachedCamera.animations=[]);this._animatables.length;)this._animatables[0]&&(this._animatables[0].onAnimationEnd=null,this._animatables[0].stop()),this._animatables.shift()}get isUserIsMoving(){return this._attachedCamera?this._attachedCamera.inertialAlphaOffset!==0||this._attachedCamera.inertialBetaOffset!==0||this._attachedCamera.inertialRadiusOffset!==0||this._attachedCamera.inertialPanningX!==0||this._attachedCamera.inertialPanningY!==0||this._isPointerDown:!1}}b.EasingFunction=new q;b.EasingMode=X.EASINGMODE_EASEINOUT;b.IgnoreBoundsSizeMode=0;b.FitFrustumSidesMode=1;class K{constructor(){this._currentMousePointerIdDown=-1,this.buttons=[0,1,2]}attachControl(t){t=S.BackCompatCameraNoPreventDefault(arguments);const e=this.camera.getEngine(),i=e.getInputElement();let s=0,n=null;this._pointA=null,this._pointB=null,this._altKey=!1,this._ctrlKey=!1,this._metaKey=!1,this._shiftKey=!1,this._buttonsPressed=0,this._pointerInput=c=>{const a=c.event,p=a.pointerType==="touch";if(c.type!==m.POINTERMOVE&&this.buttons.indexOf(a.button)===-1)return;const _=a.target;if(this._altKey=a.altKey,this._ctrlKey=a.ctrlKey,this._metaKey=a.metaKey,this._shiftKey=a.shiftKey,this._buttonsPressed=a.buttons,e.isPointerLock){const f=a.movementX,g=a.movementY;this.onTouch(null,f,g),this._pointA=null,this._pointB=null}else{if(c.type!==m.POINTERDOWN&&c.type!==m.POINTERDOUBLETAP&&p&&this._pointA?.pointerId!==a.pointerId&&this._pointB?.pointerId!==a.pointerId)return;if(c.type===m.POINTERDOWN&&(this._currentMousePointerIdDown===-1||p)){try{_?.setPointerCapture(a.pointerId)}catch{}if(this._pointA===null)this._pointA={x:a.clientX,y:a.clientY,pointerId:a.pointerId,type:a.pointerType};else if(this._pointB===null)this._pointB={x:a.clientX,y:a.clientY,pointerId:a.pointerId,type:a.pointerType};else return;this._currentMousePointerIdDown===-1&&!p&&(this._currentMousePointerIdDown=a.pointerId),this.onButtonDown(a),t||(a.preventDefault(),i&&i.focus())}else if(c.type===m.POINTERDOUBLETAP)this.onDoubleTap(a.pointerType);else if(c.type===m.POINTERUP&&(this._currentMousePointerIdDown===a.pointerId||p)){try{_?.releasePointerCapture(a.pointerId)}catch{}p||(this._pointB=null),e._badOS?this._pointA=this._pointB=null:this._pointB&&this._pointA&&this._pointA.pointerId==a.pointerId?(this._pointA=this._pointB,this._pointB=null):this._pointA&&this._pointB&&this._pointB.pointerId==a.pointerId?this._pointB=null:this._pointA=this._pointB=null,(s!==0||n)&&(this.onMultiTouch(this._pointA,this._pointB,s,0,n,null),s=0,n=null),this._currentMousePointerIdDown=-1,this.onButtonUp(a),t||a.preventDefault()}else if(c.type===m.POINTERMOVE){if(t||a.preventDefault(),this._pointA&&this._pointB===null){const f=a.clientX-this._pointA.x,g=a.clientY-this._pointA.y;this._pointA.x=a.clientX,this._pointA.y=a.clientY,this.onTouch(this._pointA,f,g)}else if(this._pointA&&this._pointB){const f=this._pointA.pointerId===a.pointerId?this._pointA:this._pointB;f.x=a.clientX,f.y=a.clientY;const g=this._pointA.x-this._pointB.x,D=this._pointA.y-this._pointB.y,v=g*g+D*D,w={x:(this._pointA.x+this._pointB.x)/2,y:(this._pointA.y+this._pointB.y)/2,pointerId:a.pointerId,type:c.type};this.onMultiTouch(this._pointA,this._pointB,s,v,n,w),n=w,s=v}}}},this._observer=this.camera.getScene()._inputManager._addCameraPointerObserver(this._pointerInput,m.POINTERDOWN|m.POINTERUP|m.POINTERMOVE|m.POINTERDOUBLETAP),this._onLostFocus=()=>{this._pointA=this._pointB=null,s=0,n=null,this.onLostFocus()},this._contextMenuBind=c=>this.onContextMenu(c),i&&i.addEventListener("contextmenu",this._contextMenuBind,!1);const o=this.camera.getScene().getEngine().getHostWindow();o&&S.RegisterTopRootEvents(o,[{name:"blur",handler:this._onLostFocus}])}detachControl(){if(this._onLostFocus){const t=this.camera.getScene().getEngine().getHostWindow();t&&S.UnregisterTopRootEvents(t,[{name:"blur",handler:this._onLostFocus}])}if(this._observer){if(this.camera.getScene()._inputManager._removeCameraPointerObserver(this._observer),this._observer=null,this._contextMenuBind){const t=this.camera.getScene().getEngine().getInputElement();t&&t.removeEventListener("contextmenu",this._contextMenuBind)}this._onLostFocus=null}this._altKey=!1,this._ctrlKey=!1,this._metaKey=!1,this._shiftKey=!1,this._buttonsPressed=0,this._currentMousePointerIdDown=-1}getClassName(){return"BaseCameraPointersInput"}getSimpleName(){return"pointers"}onDoubleTap(t){}onTouch(t,e,i){}onMultiTouch(t,e,i,s,n,o){}onContextMenu(t){t.preventDefault()}onButtonDown(t){}onButtonUp(t){}onLostFocus(){}}r([h()],K.prototype,"buttons",void 0);class T extends K{constructor(){super(...arguments),this.buttons=[0,1,2],this.angularSensibilityX=1e3,this.angularSensibilityY=1e3,this.pinchPrecision=12,this.pinchDeltaPercentage=0,this.useNaturalPinchZoom=!1,this.pinchZoom=!0,this.panningSensibility=1e3,this.multiTouchPanning=!0,this.multiTouchPanAndZoom=!0,this.pinchInwards=!0,this._isPanClick=!1,this._twoFingerActivityCount=0,this._isPinching=!1}getClassName(){return"ArcRotateCameraPointersInput"}_computeMultiTouchPanning(t,e){if(this.panningSensibility!==0&&t&&e){const i=e.x-t.x,s=e.y-t.y;this.camera.inertialPanningX+=-i/this.panningSensibility,this.camera.inertialPanningY+=s/this.panningSensibility}}_computePinchZoom(t,e){const i=this.camera.radius||T.MinimumRadiusForPinch;this.useNaturalPinchZoom?this.camera.radius=i*Math.sqrt(t)/Math.sqrt(e):this.pinchDeltaPercentage?this.camera.inertialRadiusOffset+=(e-t)*.001*i*this.pinchDeltaPercentage:this.camera.inertialRadiusOffset+=(e-t)/(this.pinchPrecision*(this.pinchInwards?1:-1)*(this.angularSensibilityX+this.angularSensibilityY)/2)}onTouch(t,e,i){this.panningSensibility!==0&&(this._ctrlKey&&this.camera._useCtrlForPanning||this._isPanClick)?(this.camera.inertialPanningX+=-e/this.panningSensibility,this.camera.inertialPanningY+=i/this.panningSensibility):(this.camera.inertialAlphaOffset-=e/this.angularSensibilityX,this.camera.inertialBetaOffset-=i/this.angularSensibilityY)}onDoubleTap(){this.camera.useInputToRestoreState&&this.camera.restoreState()}onMultiTouch(t,e,i,s,n,o){i===0&&n===null||s===0&&o===null||(this.multiTouchPanAndZoom?(this._computePinchZoom(i,s),this._computeMultiTouchPanning(n,o)):this.multiTouchPanning&&this.pinchZoom?(this._twoFingerActivityCount++,this._isPinching||this._twoFingerActivityCount<20&&Math.abs(Math.sqrt(s)-Math.sqrt(i))>this.camera.pinchToPanMaxDistance?(this._computePinchZoom(i,s),this._isPinching=!0):this._computeMultiTouchPanning(n,o)):this.multiTouchPanning?this._computeMultiTouchPanning(n,o):this.pinchZoom&&this._computePinchZoom(i,s))}onButtonDown(t){this._isPanClick=t.button===this.camera._panningMouseButton}onButtonUp(t){this._twoFingerActivityCount=0,this._isPinching=!1}onLostFocus(){this._isPanClick=!1,this._twoFingerActivityCount=0,this._isPinching=!1}}T.MinimumRadiusForPinch=.001;r([h()],T.prototype,"buttons",void 0);r([h()],T.prototype,"angularSensibilityX",void 0);r([h()],T.prototype,"angularSensibilityY",void 0);r([h()],T.prototype,"pinchPrecision",void 0);r([h()],T.prototype,"pinchDeltaPercentage",void 0);r([h()],T.prototype,"useNaturalPinchZoom",void 0);r([h()],T.prototype,"pinchZoom",void 0);r([h()],T.prototype,"panningSensibility",void 0);r([h()],T.prototype,"multiTouchPanning",void 0);r([h()],T.prototype,"multiTouchPanAndZoom",void 0);V.ArcRotateCameraPointersInput=T;class A{constructor(){this.keysUp=[38],this.keysDown=[40],this.keysLeft=[37],this.keysRight=[39],this.keysReset=[220],this.panningSensibility=50,this.zoomingSensibility=25,this.useAltToZoom=!0,this.angularSpeed=.01,this._keys=new Array}attachControl(t){t=S.BackCompatCameraNoPreventDefault(arguments),!this._onCanvasBlurObserver&&(this._scene=this.camera.getScene(),this._engine=this._scene.getEngine(),this._onCanvasBlurObserver=this._engine.onCanvasBlurObservable.add(()=>{this._keys.length=0}),this._onKeyboardObserver=this._scene.onKeyboardObservable.add(e=>{const i=e.event;if(!i.metaKey){if(e.type===Q.KEYDOWN)this._ctrlPressed=i.ctrlKey,this._altPressed=i.altKey,(this.keysUp.indexOf(i.keyCode)!==-1||this.keysDown.indexOf(i.keyCode)!==-1||this.keysLeft.indexOf(i.keyCode)!==-1||this.keysRight.indexOf(i.keyCode)!==-1||this.keysReset.indexOf(i.keyCode)!==-1)&&(this._keys.indexOf(i.keyCode)===-1&&this._keys.push(i.keyCode),i.preventDefault&&(t||i.preventDefault()));else if(this.keysUp.indexOf(i.keyCode)!==-1||this.keysDown.indexOf(i.keyCode)!==-1||this.keysLeft.indexOf(i.keyCode)!==-1||this.keysRight.indexOf(i.keyCode)!==-1||this.keysReset.indexOf(i.keyCode)!==-1){const s=this._keys.indexOf(i.keyCode);s>=0&&this._keys.splice(s,1),i.preventDefault&&(t||i.preventDefault())}}}))}detachControl(){this._scene&&(this._onKeyboardObserver&&this._scene.onKeyboardObservable.remove(this._onKeyboardObserver),this._onCanvasBlurObserver&&this._engine.onCanvasBlurObservable.remove(this._onCanvasBlurObserver),this._onKeyboardObserver=null,this._onCanvasBlurObserver=null),this._keys.length=0}checkInputs(){if(this._onKeyboardObserver){const t=this.camera;for(let e=0;e<this._keys.length;e++){const i=this._keys[e];this.keysLeft.indexOf(i)!==-1?this._ctrlPressed&&this.camera._useCtrlForPanning?t.inertialPanningX-=1/this.panningSensibility:t.inertialAlphaOffset-=this.angularSpeed:this.keysUp.indexOf(i)!==-1?this._ctrlPressed&&this.camera._useCtrlForPanning?t.inertialPanningY+=1/this.panningSensibility:this._altPressed&&this.useAltToZoom?t.inertialRadiusOffset+=1/this.zoomingSensibility:t.inertialBetaOffset-=this.angularSpeed:this.keysRight.indexOf(i)!==-1?this._ctrlPressed&&this.camera._useCtrlForPanning?t.inertialPanningX+=1/this.panningSensibility:t.inertialAlphaOffset+=this.angularSpeed:this.keysDown.indexOf(i)!==-1?this._ctrlPressed&&this.camera._useCtrlForPanning?t.inertialPanningY-=1/this.panningSensibility:this._altPressed&&this.useAltToZoom?t.inertialRadiusOffset-=1/this.zoomingSensibility:t.inertialBetaOffset+=this.angularSpeed:this.keysReset.indexOf(i)!==-1&&t.useInputToRestoreState&&t.restoreState()}}}getClassName(){return"ArcRotateCameraKeyboardMoveInput"}getSimpleName(){return"keyboard"}}r([h()],A.prototype,"keysUp",void 0);r([h()],A.prototype,"keysDown",void 0);r([h()],A.prototype,"keysLeft",void 0);r([h()],A.prototype,"keysRight",void 0);r([h()],A.prototype,"keysReset",void 0);r([h()],A.prototype,"panningSensibility",void 0);r([h()],A.prototype,"zoomingSensibility",void 0);r([h()],A.prototype,"useAltToZoom",void 0);r([h()],A.prototype,"angularSpeed",void 0);V.ArcRotateCameraKeyboardMoveInput=A;const ot=40;class x{constructor(){this.wheelPrecision=3,this.zoomToMouseLocation=!1,this.wheelDeltaPercentage=0,this.customComputeDeltaFromMouseWheel=null,this._viewOffset=new l(0,0,0),this._globalOffset=new l(0,0,0),this._inertialPanning=l.Zero()}_computeDeltaFromMouseWheelLegacyEvent(t,e){let i=0;const s=t*.01*this.wheelDeltaPercentage*e;return t>0?i=s/(1+this.wheelDeltaPercentage):i=s*(1+this.wheelDeltaPercentage),i}attachControl(t){t=S.BackCompatCameraNoPreventDefault(arguments),this._wheel=e=>{if(e.type!==m.POINTERWHEEL)return;const i=e.event;let s=0;const n=i.deltaMode===J.DOM_DELTA_LINE?ot:1,o=-(i.deltaY*n);if(this.customComputeDeltaFromMouseWheel)s=this.customComputeDeltaFromMouseWheel(o,this,i);else if(this.wheelDeltaPercentage){if(s=this._computeDeltaFromMouseWheelLegacyEvent(o,this.camera.radius),s>0){let c=this.camera.radius,a=this.camera.inertialRadiusOffset+s;for(let p=0;p<20&&!(c<=a||Math.abs(a*this.camera.inertia)<.001);p++)c-=a,a*=this.camera.inertia;c=E(c,0,Number.MAX_VALUE),s=this._computeDeltaFromMouseWheelLegacyEvent(o,c)}}else s=o/(this.wheelPrecision*40);s&&(this.zoomToMouseLocation?(this._hitPlane||this._updateHitPlane(),this._zoomToMouse(s)):this.camera.inertialRadiusOffset+=s),i.preventDefault&&(t||i.preventDefault())},this._observer=this.camera.getScene()._inputManager._addCameraPointerObserver(this._wheel,m.POINTERWHEEL),this.zoomToMouseLocation&&this._inertialPanning.setAll(0)}detachControl(){this._observer&&(this.camera.getScene()._inputManager._removeCameraPointerObserver(this._observer),this._observer=null,this._wheel=null)}checkInputs(){if(!this.zoomToMouseLocation)return;const t=this.camera;0+t.inertialAlphaOffset+t.inertialBetaOffset+t.inertialRadiusOffset&&(this._updateHitPlane(),t.target.addInPlace(this._inertialPanning),this._inertialPanning.scaleInPlace(t.inertia),this._zeroIfClose(this._inertialPanning))}getClassName(){return"ArcRotateCameraMouseWheelInput"}getSimpleName(){return"mousewheel"}_updateHitPlane(){const t=this.camera,e=t.target.subtract(t.position);this._hitPlane=$.FromPositionAndNormal(t.target,e)}_getPosition(){const t=this.camera,e=t.getScene(),i=e.createPickingRay(e.pointerX,e.pointerY,I.Identity(),t,!1);(t.targetScreenOffset.x!==0||t.targetScreenOffset.y!==0)&&(this._viewOffset.set(t.targetScreenOffset.x,t.targetScreenOffset.y,0),t.getViewMatrix().invertToRef(t._cameraTransformMatrix),this._globalOffset=l.TransformNormal(this._viewOffset,t._cameraTransformMatrix),i.origin.addInPlace(this._globalOffset));let s=0;return this._hitPlane&&(s=i.intersectsPlane(this._hitPlane)??0),i.origin.addInPlace(i.direction.scaleInPlace(s))}_zoomToMouse(t){const e=this.camera,i=1-e.inertia;if(e.lowerRadiusLimit){const a=e.lowerRadiusLimit??0;e.radius-(e.inertialRadiusOffset+t)/i<a&&(t=(e.radius-a)*i-e.inertialRadiusOffset)}if(e.upperRadiusLimit){const a=e.upperRadiusLimit??0;e.radius-(e.inertialRadiusOffset+t)/i>a&&(t=(e.radius-a)*i-e.inertialRadiusOffset)}const n=t/i/e.radius,o=this._getPosition(),c=P.Vector3[6];o.subtractToRef(e.target,c),c.scaleInPlace(n),c.scaleInPlace(i),this._inertialPanning.addInPlace(c),e.inertialRadiusOffset+=t}_zeroIfClose(t){Math.abs(t.x)<R&&(t.x=0),Math.abs(t.y)<R&&(t.y=0),Math.abs(t.z)<R&&(t.z=0)}}r([h()],x.prototype,"wheelPrecision",void 0);r([h()],x.prototype,"zoomToMouseLocation",void 0);r([h()],x.prototype,"wheelDeltaPercentage",void 0);V.ArcRotateCameraMouseWheelInput=x;class rt extends j{constructor(t){super(t)}addMouseWheel(){return this.add(new x),this}addPointers(){return this.add(new T),this}addKeyboard(){return this.add(new A),this}}Z.AddNodeConstructor("ArcRotateCamera",(d,t)=>()=>new u(d,0,0,1,l.Zero(),t));function ht(d){let t=Math.PI/2;return d.x===0&&d.z===0||(t=Math.acos(d.x/Math.sqrt(Math.pow(d.x,2)+Math.pow(d.z,2)))),d.z<0&&(t=2*Math.PI-t),t}function lt(d,t){return Math.acos(d/t)}function y(d,t){return isNaN(d)?t:d}class u extends tt{get target(){return this._target}set target(t){this.setTarget(t)}get targetHost(){return this._targetHost}set targetHost(t){t&&this.setTarget(t)}getTarget(){return this.target}get position(){return this._position}set position(t){this.setPosition(t)}set upVector(t){this._upToYMatrix||(this._yToUpMatrix=new I,this._upToYMatrix=new I,this._upVector=l.Zero()),t.normalize(),this._upVector.copyFrom(t),this.setMatUp()}get upVector(){return this._upVector}setMatUp(){I.RotationAlignToRef(l.UpReadOnly,this._upVector,this._yToUpMatrix),I.RotationAlignToRef(this._upVector,l.UpReadOnly,this._upToYMatrix)}get angularSensibilityX(){const t=this.inputs.attached.pointers;return t?t.angularSensibilityX:0}set angularSensibilityX(t){const e=this.inputs.attached.pointers;e&&(e.angularSensibilityX=t)}get angularSensibilityY(){const t=this.inputs.attached.pointers;return t?t.angularSensibilityY:0}set angularSensibilityY(t){const e=this.inputs.attached.pointers;e&&(e.angularSensibilityY=t)}get pinchPrecision(){const t=this.inputs.attached.pointers;return t?t.pinchPrecision:0}set pinchPrecision(t){const e=this.inputs.attached.pointers;e&&(e.pinchPrecision=t)}get pinchDeltaPercentage(){const t=this.inputs.attached.pointers;return t?t.pinchDeltaPercentage:0}set pinchDeltaPercentage(t){const e=this.inputs.attached.pointers;e&&(e.pinchDeltaPercentage=t)}get useNaturalPinchZoom(){const t=this.inputs.attached.pointers;return t?t.useNaturalPinchZoom:!1}set useNaturalPinchZoom(t){const e=this.inputs.attached.pointers;e&&(e.useNaturalPinchZoom=t)}get panningSensibility(){const t=this.inputs.attached.pointers;return t?t.panningSensibility:0}set panningSensibility(t){const e=this.inputs.attached.pointers;e&&(e.panningSensibility=t)}get keysUp(){const t=this.inputs.attached.keyboard;return t?t.keysUp:[]}set keysUp(t){const e=this.inputs.attached.keyboard;e&&(e.keysUp=t)}get keysDown(){const t=this.inputs.attached.keyboard;return t?t.keysDown:[]}set keysDown(t){const e=this.inputs.attached.keyboard;e&&(e.keysDown=t)}get keysLeft(){const t=this.inputs.attached.keyboard;return t?t.keysLeft:[]}set keysLeft(t){const e=this.inputs.attached.keyboard;e&&(e.keysLeft=t)}get keysRight(){const t=this.inputs.attached.keyboard;return t?t.keysRight:[]}set keysRight(t){const e=this.inputs.attached.keyboard;e&&(e.keysRight=t)}get wheelPrecision(){const t=this.inputs.attached.mousewheel;return t?t.wheelPrecision:0}set wheelPrecision(t){const e=this.inputs.attached.mousewheel;e&&(e.wheelPrecision=t)}get zoomToMouseLocation(){const t=this.inputs.attached.mousewheel;return t?t.zoomToMouseLocation:!1}set zoomToMouseLocation(t){const e=this.inputs.attached.mousewheel;e&&(e.zoomToMouseLocation=t)}get wheelDeltaPercentage(){const t=this.inputs.attached.mousewheel;return t?t.wheelDeltaPercentage:0}set wheelDeltaPercentage(t){const e=this.inputs.attached.mousewheel;e&&(e.wheelDeltaPercentage=t)}get isInterpolating(){return this._isInterpolating}get bouncingBehavior(){return this._bouncingBehavior}get useBouncingBehavior(){return this._bouncingBehavior!=null}set useBouncingBehavior(t){t!==this.useBouncingBehavior&&(t?(this._bouncingBehavior=new M,this.addBehavior(this._bouncingBehavior)):this._bouncingBehavior&&(this.removeBehavior(this._bouncingBehavior),this._bouncingBehavior=null))}get framingBehavior(){return this._framingBehavior}get useFramingBehavior(){return this._framingBehavior!=null}set useFramingBehavior(t){t!==this.useFramingBehavior&&(t?(this._framingBehavior=new b,this.addBehavior(this._framingBehavior)):this._framingBehavior&&(this.removeBehavior(this._framingBehavior),this._framingBehavior=null))}get autoRotationBehavior(){return this._autoRotationBehavior}get useAutoRotationBehavior(){return this._autoRotationBehavior!=null}set useAutoRotationBehavior(t){t!==this.useAutoRotationBehavior&&(t?(this._autoRotationBehavior=new nt,this.addBehavior(this._autoRotationBehavior)):this._autoRotationBehavior&&(this.removeBehavior(this._autoRotationBehavior),this._autoRotationBehavior=null))}constructor(t,e,i,s,n,o,c=!0){super(t,l.Zero(),o,c),this.inertialAlphaOffset=0,this.inertialBetaOffset=0,this.inertialRadiusOffset=0,this.lowerAlphaLimit=null,this.upperAlphaLimit=null,this.lowerBetaLimit=.01,this.upperBetaLimit=Math.PI-.01,this.lowerRadiusLimit=null,this.upperRadiusLimit=null,this.lowerTargetYLimit=-1/0,this.inertialPanningX=0,this.inertialPanningY=0,this.pinchToPanMaxDistance=20,this.panningDistanceLimit=null,this.panningOriginTarget=l.Zero(),this.panningInertia=.9,this.zoomOnFactor=1,this.targetScreenOffset=L.Zero(),this.allowUpsideDown=!0,this.useInputToRestoreState=!0,this.restoreStateInterpolationFactor=0,this._currentInterpolationFactor=0,this._viewMatrix=new I,this.panningAxis=new l(1,1,0),this._transformedDirection=new l,this.mapPanning=!1,this._isInterpolating=!1,this.onMeshTargetChangedObservable=new H,this.checkCollisions=!1,this.collisionRadius=new l(.5,.5,.5),this._previousPosition=l.Zero(),this._collisionVelocity=l.Zero(),this._newPosition=l.Zero(),this._computationVector=l.Zero(),this._goalAlpha=NaN,this._goalBeta=NaN,this._goalRadius=NaN,this._goalTarget=new l(NaN,NaN,NaN),this._goalTargetScreenOffset=new L(NaN,NaN),this._onCollisionPositionChange=(a,p,_=null)=>{_?(this.setPosition(p),this.onCollide&&this.onCollide(_)):this._previousPosition.copyFrom(this._position);const f=Math.cos(this.alpha),g=Math.sin(this.alpha),D=Math.cos(this.beta);let v=Math.sin(this.beta);v===0&&(v=1e-4);const w=this._getTargetPosition();this._computationVector.copyFromFloats(this.radius*f*v,this.radius*D,this.radius*g*v),w.addToRef(this._computationVector,this._newPosition),this._position.copyFrom(this._newPosition);let B=this.upVector;this.allowUpsideDown&&this.beta<0&&(B=B.clone(),B=B.negate()),this._computeViewMatrix(this._position,w,B),this._viewMatrix.addAtIndex(12,this.targetScreenOffset.x),this._viewMatrix.addAtIndex(13,this.targetScreenOffset.y),this._collisionTriggered=!1},this._target=l.Zero(),n&&this.setTarget(n),this.alpha=e,this.beta=i,this.radius=s,this.getViewMatrix(),this.inputs=new rt(this),this.inputs.addKeyboard().addMouseWheel().addPointers()}_initCache(){super._initCache(),this._cache._target=new l(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE),this._cache.alpha=void 0,this._cache.beta=void 0,this._cache.radius=void 0,this._cache.targetScreenOffset=L.Zero()}_updateCache(t){t||super._updateCache(),this._cache._target.copyFrom(this._getTargetPosition()),this._cache.alpha=this.alpha,this._cache.beta=this.beta,this._cache.radius=this.radius,this._cache.targetScreenOffset.copyFrom(this.targetScreenOffset)}_getTargetPosition(){if(this._targetHost&&this._targetHost.getAbsolutePosition){const e=this._targetHost.getAbsolutePosition();this._targetBoundingCenter?e.addToRef(this._targetBoundingCenter,this._target):this._target.copyFrom(e)}const t=this._getLockedTargetPosition();return t||this._target}storeState(){return this._storedAlpha=this.alpha,this._storedBeta=this.beta,this._storedRadius=this.radius,this._storedTarget=this._getTargetPosition().clone(),this._storedTargetScreenOffset=this.targetScreenOffset.clone(),super.storeState()}_restoreStateValues(){return this.hasStateStored()&&this.restoreStateInterpolationFactor>R&&this.restoreStateInterpolationFactor<1?(this.interpolateTo(this._storedAlpha,this._storedBeta,this._storedRadius,this._storedTarget,this._storedTargetScreenOffset,this.restoreStateInterpolationFactor),!0):super._restoreStateValues()?(this.setTarget(this._storedTarget.clone()),this.alpha=this._storedAlpha,this.beta=this._storedBeta,this.radius=this._storedRadius,this.targetScreenOffset=this._storedTargetScreenOffset.clone(),this.inertialAlphaOffset=0,this.inertialBetaOffset=0,this.inertialRadiusOffset=0,this.inertialPanningX=0,this.inertialPanningY=0,!0):!1}stopInterpolation(){this._goalAlpha=NaN,this._goalBeta=NaN,this._goalRadius=NaN,this._goalTarget.set(NaN,NaN,NaN),this._goalTargetScreenOffset.set(NaN,NaN)}interpolateTo(t=this.alpha,e=this.beta,i=this.radius,s=this.target,n=this.targetScreenOffset,o){this.inertialAlphaOffset=0,this.inertialBetaOffset=0,this.inertialRadiusOffset=0,this.inertialPanningX=0,this.inertialPanningY=0,o!=null?this._currentInterpolationFactor=o:this.restoreStateInterpolationFactor!==0?this._currentInterpolationFactor=this.restoreStateInterpolationFactor:this._currentInterpolationFactor=.1,this._goalAlpha=y(t,this._goalAlpha),this._goalBeta=y(e,this._goalBeta),this._goalRadius=y(i,this._goalRadius),this._goalTarget.set(y(s.x,this._goalTarget.x),y(s.y,this._goalTarget.y),y(s.z,this._goalTarget.z)),this._goalTargetScreenOffset.set(y(n.x,this._goalTargetScreenOffset.x),y(n.y,this._goalTargetScreenOffset.y)),this._goalAlpha=E(this._goalAlpha,this.lowerAlphaLimit??-1/0,this.upperAlphaLimit??1/0),this._goalBeta=E(this._goalBeta,this.lowerBetaLimit??-1/0,this.upperBetaLimit??1/0),this._goalRadius=E(this._goalRadius,this.lowerRadiusLimit??-1/0,this.upperRadiusLimit??1/0),this._goalTarget.y=E(this._goalTarget.y,this.lowerTargetYLimit??-1/0,1/0),this._isInterpolating=!0}_isSynchronizedViewMatrix(){return super._isSynchronizedViewMatrix()?this._cache._target.equals(this._getTargetPosition())&&this._cache.alpha===this.alpha&&this._cache.beta===this.beta&&this._cache.radius===this.radius&&this._cache.targetScreenOffset.equals(this.targetScreenOffset):!1}attachControl(t,e,i=!0,s=2){const n=arguments;e=S.BackCompatCameraNoPreventDefault(n),this._useCtrlForPanning=i,this._panningMouseButton=s,typeof n[0]=="boolean"&&(n.length>1&&(this._useCtrlForPanning=n[1]),n.length>2&&(this._panningMouseButton=n[2])),this.inputs.attachElement(e),this._reset=()=>{this.inertialAlphaOffset=0,this.inertialBetaOffset=0,this.inertialRadiusOffset=0,this.inertialPanningX=0,this.inertialPanningY=0}}detachControl(){this.inputs.detachElement(),this._reset&&this._reset()}_checkInputs(){if(this._collisionTriggered)return;this.inputs.checkInputs();let t=!1;if(this.inertialAlphaOffset!==0||this.inertialBetaOffset!==0||this.inertialRadiusOffset!==0){t=!0;const e=this.invertRotation?-1:1,i=this._calculateHandednessMultiplier();let s=this.inertialAlphaOffset*i;this.beta<0&&(s*=-1),this.alpha+=s*e,this.beta+=this.inertialBetaOffset*e,this.radius-=this.inertialRadiusOffset,this.inertialAlphaOffset*=this.inertia,this.inertialBetaOffset*=this.inertia,this.inertialRadiusOffset*=this.inertia,Math.abs(this.inertialAlphaOffset)<R&&(this.inertialAlphaOffset=0),Math.abs(this.inertialBetaOffset)<R&&(this.inertialBetaOffset=0),Math.abs(this.inertialRadiusOffset)<this.speed*R&&(this.inertialRadiusOffset=0)}if(this.inertialPanningX!==0||this.inertialPanningY!==0){t=!0;const e=new l(this.inertialPanningX,this.inertialPanningY,this.inertialPanningY);if(this._viewMatrix.invertToRef(this._cameraTransformMatrix),e.multiplyInPlace(this.panningAxis),l.TransformNormalToRef(e,this._cameraTransformMatrix,this._transformedDirection),this.mapPanning){const i=this.upVector,s=l.CrossToRef(this._transformedDirection,i,this._transformedDirection);l.CrossToRef(i,s,this._transformedDirection)}else this.panningAxis.y||(this._transformedDirection.y=0);if(!this._targetHost)if(this.panningDistanceLimit)this._transformedDirection.addInPlace(this._target),l.DistanceSquared(this._transformedDirection,this.panningOriginTarget)<=this.panningDistanceLimit*this.panningDistanceLimit&&this._target.copyFrom(this._transformedDirection);else{if(this.parent){const i=P.Matrix[0];this.parent.getWorldMatrix().getRotationMatrixToRef(i),i.transposeToRef(i),l.TransformCoordinatesToRef(this._transformedDirection,i,this._transformedDirection)}this._target.addInPlace(this._transformedDirection)}this.inertialPanningX*=this.panningInertia,this.inertialPanningY*=this.panningInertia,Math.abs(this.inertialPanningX)<this.speed*R&&(this.inertialPanningX=0),Math.abs(this.inertialPanningY)<this.speed*R&&(this.inertialPanningY=0)}if(t)this.stopInterpolation();else if(this._isInterpolating){let e=!1;const i=this._scene.getEngine().getDeltaTime()/1e3,s=1-Math.pow(2,-i/this._currentInterpolationFactor),n=y(this._goalRadius,this.radius);if(!isNaN(this._goalTarget.x)||!isNaN(this._goalTarget.y)||!isNaN(this._goalTarget.z)){const o=P.Vector3[0].set(y(this._goalTarget.x,this._target.x),y(this._goalTarget.y,this._target.y),y(this._goalTarget.z,this._target.z));l.LerpToRef(this.target,o,s,this._target),l.Distance(this.target,o)*10/n<R?(this._goalTarget.set(NaN,NaN,NaN),this.target.copyFrom(o),this.setTarget(this.target,!1,!0,!0)):e=!0}if(!isNaN(this._goalAlpha)||!isNaN(this._goalBeta)){const o=F.RotationAlphaBetaGammaToRef(y(this._goalAlpha,this.alpha),y(this._goalBeta,this.beta),0,P.Quaternion[0]),c=F.RotationAlphaBetaGammaToRef(this.alpha,this.beta,0,P.Quaternion[1]),a=F.SlerpToRef(c,o,s,P.Quaternion[2]);a.normalize();const p=a.toAlphaBetaGammaToRef(P.Vector3[0]);if(this.alpha=p.x,this.beta=p.y,a.isApprox(o,R/5)){this._goalAlpha=NaN,this._goalBeta=NaN;const _=o.toAlphaBetaGammaToRef(P.Vector3[0]);this.alpha=_.x,this.beta=_.y}else e=!0}if(isNaN(this._goalRadius)||(this.radius+=(n-this.radius)*s,Math.abs(n/this.radius-1)<R?(this._goalRadius=NaN,this.radius=n):e=!0),!isNaN(this._goalTargetScreenOffset.x)||!isNaN(this._goalTargetScreenOffset.y)){const o=P.Vector2[0].set(y(this._goalTargetScreenOffset.x,this.targetScreenOffset.x),y(this._goalTargetScreenOffset.y,this.targetScreenOffset.y));L.LerpToRef(this.targetScreenOffset,o,s,this.targetScreenOffset),L.Distance(this.targetScreenOffset,o)<R?(this._goalTargetScreenOffset.set(NaN,NaN),this.targetScreenOffset.copyFrom(o)):e=!0}this._isInterpolating=e}this._checkLimits(),super._checkInputs()}_checkLimits(){this.lowerBetaLimit===null||this.lowerBetaLimit===void 0?this.allowUpsideDown&&this.beta>Math.PI&&(this.beta=this.beta-2*Math.PI):this.beta<this.lowerBetaLimit&&(this.beta=this.lowerBetaLimit),this.upperBetaLimit===null||this.upperBetaLimit===void 0?this.allowUpsideDown&&this.beta<-Math.PI&&(this.beta=this.beta+2*Math.PI):this.beta>this.upperBetaLimit&&(this.beta=this.upperBetaLimit),this.lowerAlphaLimit!==null&&this.alpha<this.lowerAlphaLimit&&(this.alpha=this.lowerAlphaLimit),this.upperAlphaLimit!==null&&this.alpha>this.upperAlphaLimit&&(this.alpha=this.upperAlphaLimit),this.lowerRadiusLimit!==null&&this.radius<this.lowerRadiusLimit&&(this.radius=this.lowerRadiusLimit,this.inertialRadiusOffset=0),this.upperRadiusLimit!==null&&this.radius>this.upperRadiusLimit&&(this.radius=this.upperRadiusLimit,this.inertialRadiusOffset=0),this.target.y=Math.max(this.target.y,this.lowerTargetYLimit)}rebuildAnglesAndRadius(){this._position.subtractToRef(this._getTargetPosition(),this._computationVector),(this._upVector.x!==0||this._upVector.y!==1||this._upVector.z!==0)&&l.TransformCoordinatesToRef(this._computationVector,this._upToYMatrix,this._computationVector),this.radius=this._computationVector.length(),this.radius===0&&(this.radius=1e-4);const t=this.alpha;this.alpha=ht(this._computationVector),this.beta=lt(this._computationVector.y,this.radius);const e=Math.round((t-this.alpha)/(2*Math.PI));this.alpha+=e*2*Math.PI,this._checkLimits()}setPosition(t){this._position.equals(t)||(this._position.copyFrom(t),this.rebuildAnglesAndRadius())}setTarget(t,e=!1,i=!1,s=!1){if(s=this.overrideCloneAlphaBetaRadius??s,t.computeWorldMatrix)e&&t.getBoundingInfo?this._targetBoundingCenter=t.getBoundingInfo().boundingBox.centerWorld.clone():this._targetBoundingCenter=null,t.computeWorldMatrix(),this._targetHost=t,this._target=this._getTargetPosition(),this.onMeshTargetChangedObservable.notifyObservers(this._targetHost);else{const n=t,o=this._getTargetPosition();if(o&&!i&&o.equals(n))return;this._targetHost=null,this._target=n,this._targetBoundingCenter=null,this.onMeshTargetChangedObservable.notifyObservers(null)}s||this.rebuildAnglesAndRadius()}_getViewMatrix(){const t=Math.cos(this.alpha),e=Math.sin(this.alpha),i=Math.cos(this.beta);let s=Math.sin(this.beta);s===0&&(s=1e-4),this.radius===0&&(this.radius=1e-4);const n=this._getTargetPosition();if(this._computationVector.copyFromFloats(this.radius*t*s,this.radius*i,this.radius*e*s),(this._upVector.x!==0||this._upVector.y!==1||this._upVector.z!==0)&&l.TransformCoordinatesToRef(this._computationVector,this._yToUpMatrix,this._computationVector),n.addToRef(this._computationVector,this._newPosition),this.getScene().collisionsEnabled&&this.checkCollisions){const o=this.getScene().collisionCoordinator;this._collider||(this._collider=o.createCollider()),this._collider._radius=this.collisionRadius,this._newPosition.subtractToRef(this._position,this._collisionVelocity),this._collisionTriggered=!0,o.getNewPosition(this._position,this._collisionVelocity,this._collider,3,null,this._onCollisionPositionChange,this.uniqueId)}else{this._position.copyFrom(this._newPosition);let o=this.upVector;this.allowUpsideDown&&s<0&&(o=o.negate()),this._computeViewMatrix(this._position,n,o),this._viewMatrix.addAtIndex(12,this.targetScreenOffset.x),this._viewMatrix.addAtIndex(13,this.targetScreenOffset.y)}return this._currentTarget.copyFrom(n),this._viewMatrix}zoomOn(t,e=!1){t=t||this.getScene().meshes;const i=z.MinMax(t);let s=this._calculateLowerRadiusFromModelBoundingSphere(i.min,i.max);if(s=Math.max(Math.min(s,this.upperRadiusLimit||Number.MAX_VALUE),this.lowerRadiusLimit||0),this.radius=s*this.zoomOnFactor,this.mode===O.ORTHOGRAPHIC_CAMERA){const n=this.getScene().getEngine().getAspectRatio(this),o=s*this.zoomOnFactor/2;this.orthoLeft=-o*n,this.orthoRight=o*n,this.orthoBottom=-o,this.orthoTop=o}this.focusOn({min:i.min,max:i.max,distance:s},e)}focusOn(t,e=!1){let i,s;if(t.min===void 0){const n=t||this.getScene().meshes;i=z.MinMax(n),s=l.Distance(i.min,i.max)}else{const n=t;i=n,s=n.distance}this._target=z.Center(i),e||(this.maxZ=s*2)}createRigCamera(t,e){let i=0;switch(this.cameraRigMode){case O.RIG_MODE_STEREOSCOPIC_ANAGLYPH:case O.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL:case O.RIG_MODE_STEREOSCOPIC_OVERUNDER:case O.RIG_MODE_STEREOSCOPIC_INTERLACED:case O.RIG_MODE_VR:i=this._cameraRigParams.stereoHalfAngle*(e===0?1:-1);break;case O.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED:i=this._cameraRigParams.stereoHalfAngle*(e===0?-1:1);break}const s=new u(t,this.alpha+i,this.beta,this.radius,this._target,this.getScene());return s._cameraRigParams={},s.isRigCamera=!0,s.rigParent=this,s.upVector=this.upVector,s.mode=this.mode,s.orthoLeft=this.orthoLeft,s.orthoRight=this.orthoRight,s.orthoBottom=this.orthoBottom,s.orthoTop=this.orthoTop,s}_updateRigCameras(){const t=this._rigCameras[0],e=this._rigCameras[1];switch(t.beta=e.beta=this.beta,this.cameraRigMode){case O.RIG_MODE_STEREOSCOPIC_ANAGLYPH:case O.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL:case O.RIG_MODE_STEREOSCOPIC_OVERUNDER:case O.RIG_MODE_STEREOSCOPIC_INTERLACED:case O.RIG_MODE_VR:t.alpha=this.alpha-this._cameraRigParams.stereoHalfAngle,e.alpha=this.alpha+this._cameraRigParams.stereoHalfAngle;break;case O.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED:t.alpha=this.alpha+this._cameraRigParams.stereoHalfAngle,e.alpha=this.alpha-this._cameraRigParams.stereoHalfAngle;break}super._updateRigCameras()}_calculateLowerRadiusFromModelBoundingSphere(t,e,i=1){const s=l.Distance(t,e),o=this.getScene().getEngine().getAspectRatio(this),c=Math.tan(this.fov/2),a=c*o,_=s*.5*i,f=_*Math.sqrt(1+1/(a*a)),g=_*Math.sqrt(1+1/(c*c));return Math.max(f,g)}dispose(){this.inputs.clear(),super.dispose()}getClassName(){return"ArcRotateCamera"}}r([h()],u.prototype,"alpha",void 0);r([h()],u.prototype,"beta",void 0);r([h()],u.prototype,"radius",void 0);r([h()],u.prototype,"overrideCloneAlphaBetaRadius",void 0);r([U("target")],u.prototype,"_target",void 0);r([et("targetHost")],u.prototype,"_targetHost",void 0);r([h()],u.prototype,"inertialAlphaOffset",void 0);r([h()],u.prototype,"inertialBetaOffset",void 0);r([h()],u.prototype,"inertialRadiusOffset",void 0);r([h()],u.prototype,"lowerAlphaLimit",void 0);r([h()],u.prototype,"upperAlphaLimit",void 0);r([h()],u.prototype,"lowerBetaLimit",void 0);r([h()],u.prototype,"upperBetaLimit",void 0);r([h()],u.prototype,"lowerRadiusLimit",void 0);r([h()],u.prototype,"upperRadiusLimit",void 0);r([h()],u.prototype,"lowerTargetYLimit",void 0);r([h()],u.prototype,"inertialPanningX",void 0);r([h()],u.prototype,"inertialPanningY",void 0);r([h()],u.prototype,"pinchToPanMaxDistance",void 0);r([h()],u.prototype,"panningDistanceLimit",void 0);r([U()],u.prototype,"panningOriginTarget",void 0);r([h()],u.prototype,"panningInertia",void 0);r([h()],u.prototype,"zoomToMouseLocation",null);r([h()],u.prototype,"zoomOnFactor",void 0);r([it()],u.prototype,"targetScreenOffset",void 0);r([h()],u.prototype,"allowUpsideDown",void 0);r([h()],u.prototype,"useInputToRestoreState",void 0);r([h()],u.prototype,"restoreStateInterpolationFactor",void 0);W("BABYLON.ArcRotateCamera",u);Z.AddNodeConstructor("Light_Type_3",(d,t)=>()=>new k(d,l.Zero(),t));class k extends Y{constructor(t,e,i){super(t,i),this.groundColor=new st(0,0,0),this.direction=e||l.Up()}_buildUniformLayout(){this._uniformBuffer.addUniform("vLightData",4),this._uniformBuffer.addUniform("vLightDiffuse",4),this._uniformBuffer.addUniform("vLightSpecular",4),this._uniformBuffer.addUniform("vLightGround",3),this._uniformBuffer.addUniform("shadowsInfo",3),this._uniformBuffer.addUniform("depthValues",2),this._uniformBuffer.create()}getClassName(){return"HemisphericLight"}setDirectionToTarget(t){return this.direction=l.Normalize(t.subtract(l.Zero())),this.direction}getShadowGenerator(){return null}transferToEffect(t,e){const i=l.Normalize(this.direction);return this._uniformBuffer.updateFloat4("vLightData",i.x,i.y,i.z,0,e),this._uniformBuffer.updateColor3("vLightGround",this.groundColor.scale(this.intensity),e),this}transferToNodeMaterialEffect(t,e){const i=l.Normalize(this.direction);return t.setFloat3(e,i.x,i.y,i.z),this}computeWorldMatrix(){return this._worldMatrix||(this._worldMatrix=I.Identity()),this._worldMatrix}getTypeID(){return Y.LIGHTTYPEID_HEMISPHERICLIGHT}prepareLightSpecificDefines(t,e){t["HEMILIGHT"+e]=!0}}r([at()],k.prototype,"groundColor",void 0);r([U()],k.prototype,"direction",void 0);W("BABYLON.HemisphericLight",k);export{u as A,k as H};
