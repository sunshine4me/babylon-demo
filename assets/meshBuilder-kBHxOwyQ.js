const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["./color.vertex-T-eS24_s.js","./index-dzV0rMYg.js","./index-CvfNw8bG.css","./vertexColorMixing-DO5oU60k.js","./fogVertex-BhRT7xSc.js","./color.fragment-CuwxTslN.js","./fogFragment-B0DWsvhZ.js","./color.vertex-C9BE824k.js","./fogVertex-Dxe9fgVj.js","./vertexColorMixing-DSf6f0gZ.js","./color.fragment-2fwIaQJ6.js","./fogFragment-CG6k5SyA.js"])))=>i.map(i=>d[i]);
import{P as lt,b as Nt,E as ut,A as yt,B as fs,c as Ae,O as be,V as P,d as ps,T as Pt,_ as K,s as j,e as re,K as gs,f as ms,g as Vt,h as _s,M as at,i as st,j as xs,k as ys,l as rt,Q as Ht,m as O,n as _t,N as ve,o as oe,p as As,q as bs,R as he,L as ge,C as kt,r as vs,t as Q,u as k,v as Oe,w as Mt,x as Ut,y as It,z as Os,S as Te,D as Ts,F as Cs,G as Is,H as ws,I as Ps,J as Rs,U as Ms,W as Ds,X as Ss,Y as Bs,Z as Es,$ as Ls,a0 as te,a1 as me,a2 as _e,a3 as Fs,a4 as ee,a5 as Zt,a6 as Vs,a7 as dt,a8 as Ce,a9 as ae,aa as xe,ab as nt,ac as ye,ad as Ns}from"./index-dzV0rMYg.js";class zs{constructor(){this._zoomStopsAnimation=!1,this._idleRotationSpeed=.05,this._idleRotationWaitTime=2e3,this._idleRotationSpinupTime=2e3,this.targetAlpha=null,this._isPointerDown=!1,this._lastFrameTime=null,this._lastInteractionTime=-1/0,this._cameraRotationSpeed=0,this._lastFrameRadius=0}get name(){return"AutoRotation"}set zoomStopsAnimation(t){this._zoomStopsAnimation=t}get zoomStopsAnimation(){return this._zoomStopsAnimation}set idleRotationSpeed(t){this._idleRotationSpeed=t}get idleRotationSpeed(){return this._idleRotationSpeed}set idleRotationWaitTime(t){this._idleRotationWaitTime=t}get idleRotationWaitTime(){return this._idleRotationWaitTime}set idleRotationSpinupTime(t){this._idleRotationSpinupTime=t}get idleRotationSpinupTime(){return this._idleRotationSpinupTime}get rotationInProgress(){return Math.abs(this._cameraRotationSpeed)>0}init(){}attach(t){this._attachedCamera=t;const e=this._attachedCamera.getScene();this._onPrePointerObservableObserver=e.onPrePointerObservable.add(s=>{if(s.type===lt.POINTERDOWN){this._isPointerDown=!0;return}s.type===lt.POINTERUP&&(this._isPointerDown=!1)}),this._onAfterCheckInputsObserver=t.onAfterCheckInputsObservable.add(()=>{if(this._reachTargetAlpha())return;const s=Nt.Now;let i=0;this._lastFrameTime!=null&&(i=s-this._lastFrameTime),this._lastFrameTime=s,this._applyUserInteraction();const a=s-this._lastInteractionTime-this._idleRotationWaitTime,n=Math.max(Math.min(a/this._idleRotationSpinupTime,1),0);this._cameraRotationSpeed=this._idleRotationSpeed*n,this._attachedCamera&&(this._attachedCamera.alpha-=this._cameraRotationSpeed*(i/1e3))})}detach(){if(!this._attachedCamera)return;const t=this._attachedCamera.getScene();this._onPrePointerObservableObserver&&t.onPrePointerObservable.remove(this._onPrePointerObservableObserver),this._attachedCamera.onAfterCheckInputsObservable.remove(this._onAfterCheckInputsObserver),this._attachedCamera=null,this._lastFrameTime=null}resetLastInteractionTime(t){this._lastInteractionTime=t??Nt.Now}_reachTargetAlpha(){return this._attachedCamera&&this.targetAlpha?Math.abs(this._attachedCamera.alpha-this.targetAlpha)<ut:!1}_userIsZooming(){return this._attachedCamera?this._attachedCamera.inertialRadiusOffset!==0:!1}_shouldAnimationStopForInteraction(){if(!this._attachedCamera)return!1;let t=!1;return this._lastFrameRadius===this._attachedCamera.radius&&this._attachedCamera.inertialRadiusOffset!==0&&(t=!0),this._lastFrameRadius=this._attachedCamera.radius,this._zoomStopsAnimation?t:this._userIsZooming()}_applyUserInteraction(){this._userIsMoving()&&!this._shouldAnimationStopForInteraction()&&(this._lastInteractionTime=Nt.Now)}_userIsMoving(){return this._attachedCamera?this._attachedCamera.inertialAlphaOffset!==0||this._attachedCamera.inertialBetaOffset!==0||this._attachedCamera.inertialRadiusOffset!==0||this._attachedCamera.inertialPanningX!==0||this._attachedCamera.inertialPanningY!==0||this._isPointerDown:!1}}class Rt{constructor(){this.transitionDuration=450,this.lowerRadiusTransitionRange=2,this.upperRadiusTransitionRange=-2,this._autoTransitionRange=!1,this._radiusIsAnimating=!1,this._radiusBounceTransition=null,this._animatables=new Array}get name(){return"Bouncing"}get autoTransitionRange(){return this._autoTransitionRange}set autoTransitionRange(t){if(this._autoTransitionRange===t)return;this._autoTransitionRange=t;const e=this._attachedCamera;e&&(t?this._onMeshTargetChangedObserver=e.onMeshTargetChangedObservable.add(s=>{if(s&&(s.computeWorldMatrix(!0),s.getBoundingInfo)){const i=s.getBoundingInfo().diagonalLength;this.lowerRadiusTransitionRange=i*.05,this.upperRadiusTransitionRange=i*.05}}):this._onMeshTargetChangedObserver&&e.onMeshTargetChangedObservable.remove(this._onMeshTargetChangedObserver))}init(){}attach(t){this._attachedCamera=t,this._onAfterCheckInputsObserver=t.onAfterCheckInputsObservable.add(()=>{this._attachedCamera&&(this._isRadiusAtLimit(this._attachedCamera.lowerRadiusLimit)&&this._applyBoundRadiusAnimation(this.lowerRadiusTransitionRange),this._isRadiusAtLimit(this._attachedCamera.upperRadiusLimit)&&this._applyBoundRadiusAnimation(this.upperRadiusTransitionRange))})}detach(){this._attachedCamera&&(this._onAfterCheckInputsObserver&&this._attachedCamera.onAfterCheckInputsObservable.remove(this._onAfterCheckInputsObserver),this._onMeshTargetChangedObserver&&this._attachedCamera.onMeshTargetChangedObservable.remove(this._onMeshTargetChangedObserver),this._attachedCamera=null)}_isRadiusAtLimit(t){return this._attachedCamera?this._attachedCamera.radius===t&&!this._radiusIsAnimating:!1}_applyBoundRadiusAnimation(t){if(!this._attachedCamera)return;this._radiusBounceTransition||(Rt.EasingFunction.setEasingMode(Rt.EasingMode),this._radiusBounceTransition=yt.CreateAnimation("radius",yt.ANIMATIONTYPE_FLOAT,60,Rt.EasingFunction)),this._cachedWheelPrecision=this._attachedCamera.wheelPrecision,this._attachedCamera.wheelPrecision=1/0,this._attachedCamera.inertialRadiusOffset=0,this.stopAllAnimations(),this._radiusIsAnimating=!0;const e=yt.TransitionTo("radius",this._attachedCamera.radius+t,this._attachedCamera,this._attachedCamera.getScene(),60,this._radiusBounceTransition,this.transitionDuration,()=>this._clearAnimationLocks());e&&this._animatables.push(e)}_clearAnimationLocks(){this._radiusIsAnimating=!1,this._attachedCamera&&(this._attachedCamera.wheelPrecision=this._cachedWheelPrecision)}stopAllAnimations(){for(this._attachedCamera&&(this._attachedCamera.animations=[]);this._animatables.length;)this._animatables[0].onAnimationEnd=null,this._animatables[0].stop(),this._animatables.shift()}}Rt.EasingFunction=new fs(.3);Rt.EasingMode=Ae.EASINGMODE_EASEOUT;class pt{constructor(){this.onTargetFramingAnimationEndObservable=new be,this._mode=pt.FitFrustumSidesMode,this._radiusScale=1,this._positionScale=.5,this._defaultElevation=.3,this._elevationReturnTime=1500,this._elevationReturnWaitTime=1e3,this._zoomStopsAnimation=!1,this._framingTime=1500,this.autoCorrectCameraLimitsAndSensibility=!0,this._isPointerDown=!1,this._lastInteractionTime=-1/0,this._animatables=new Array,this._betaIsAnimating=!1}get name(){return"Framing"}set mode(t){this._mode=t}get mode(){return this._mode}set radiusScale(t){this._radiusScale=t}get radiusScale(){return this._radiusScale}set positionScale(t){this._positionScale=t}get positionScale(){return this._positionScale}set defaultElevation(t){this._defaultElevation=t}get defaultElevation(){return this._defaultElevation}set elevationReturnTime(t){this._elevationReturnTime=t}get elevationReturnTime(){return this._elevationReturnTime}set elevationReturnWaitTime(t){this._elevationReturnWaitTime=t}get elevationReturnWaitTime(){return this._elevationReturnWaitTime}set zoomStopsAnimation(t){this._zoomStopsAnimation=t}get zoomStopsAnimation(){return this._zoomStopsAnimation}set framingTime(t){this._framingTime=t}get framingTime(){return this._framingTime}init(){}attach(t){this._attachedCamera=t;const e=this._attachedCamera.getScene();pt.EasingFunction.setEasingMode(pt.EasingMode),this._onPrePointerObservableObserver=e.onPrePointerObservable.add(s=>{if(s.type===lt.POINTERDOWN){this._isPointerDown=!0;return}s.type===lt.POINTERUP&&(this._isPointerDown=!1)}),this._onMeshTargetChangedObserver=t.onMeshTargetChangedObservable.add(s=>{s&&s.getBoundingInfo&&this.zoomOnMesh(s,void 0,()=>{this.onTargetFramingAnimationEndObservable.notifyObservers()})}),this._onAfterCheckInputsObserver=t.onAfterCheckInputsObservable.add(()=>{this._applyUserInteraction(),this._maintainCameraAboveGround()})}detach(){if(!this._attachedCamera)return;const t=this._attachedCamera.getScene();this._onPrePointerObservableObserver&&t.onPrePointerObservable.remove(this._onPrePointerObservableObserver),this._onAfterCheckInputsObserver&&this._attachedCamera.onAfterCheckInputsObservable.remove(this._onAfterCheckInputsObserver),this._onMeshTargetChangedObserver&&this._attachedCamera.onMeshTargetChangedObservable.remove(this._onMeshTargetChangedObserver),this._attachedCamera=null}zoomOnMesh(t,e=!1,s=null){t.computeWorldMatrix(!0);const i=t.getBoundingInfo().boundingBox;this.zoomOnBoundingInfo(i.minimumWorld,i.maximumWorld,e,s)}zoomOnMeshHierarchy(t,e=!1,s=null){t.computeWorldMatrix(!0);const i=t.getHierarchyBoundingVectors(!0);this.zoomOnBoundingInfo(i.min,i.max,e,s)}zoomOnMeshesHierarchy(t,e=!1,s=null){const i=new P(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE),a=new P(-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE);for(let n=0;n<t.length;n++){const o=t[n].getHierarchyBoundingVectors(!0);P.CheckExtends(o.min,i,a),P.CheckExtends(o.max,i,a)}this.zoomOnBoundingInfo(i,a,e,s)}zoomOnBoundingInfo(t,e,s=!1,i=null){let a;if(!this._attachedCamera)return!1;const n=t.y,o=e.y,c=n+(o-n)*this._positionScale,f=e.subtract(t).scale(.5);if(!isFinite(c))return!1;if(s)a=new P(0,c,0);else{const u=t.add(f);a=new P(u.x,c,u.z)}this._vectorTransition||(this._vectorTransition=yt.CreateAnimation("target",yt.ANIMATIONTYPE_VECTOR3,60,pt.EasingFunction)),this._betaIsAnimating=!0;let g=yt.TransitionTo("target",a,this._attachedCamera,this._attachedCamera.getScene(),60,this._vectorTransition,this._framingTime);g&&this._animatables.push(g);let h=0;if(this._mode===pt.FitFrustumSidesMode){const u=this._calculateLowerRadiusFromModelBoundingSphere(t,e);this.autoCorrectCameraLimitsAndSensibility&&(this._attachedCamera.lowerRadiusLimit=f.length()+this._attachedCamera.minZ),h=u}else this._mode===pt.IgnoreBoundsSizeMode&&(h=this._calculateLowerRadiusFromModelBoundingSphere(t,e),this.autoCorrectCameraLimitsAndSensibility&&this._attachedCamera.lowerRadiusLimit===null&&(this._attachedCamera.lowerRadiusLimit=this._attachedCamera.minZ));if(this.autoCorrectCameraLimitsAndSensibility){const u=e.subtract(t).length();this._attachedCamera.panningSensibility=5e3/u,this._attachedCamera.wheelPrecision=100/h}return this._radiusTransition||(this._radiusTransition=yt.CreateAnimation("radius",yt.ANIMATIONTYPE_FLOAT,60,pt.EasingFunction)),g=yt.TransitionTo("radius",h,this._attachedCamera,this._attachedCamera.getScene(),60,this._radiusTransition,this._framingTime,()=>{this.stopAllAnimations(),i&&i(),this._attachedCamera&&this._attachedCamera.useInputToRestoreState&&this._attachedCamera.storeState()}),g&&this._animatables.push(g),!0}_calculateLowerRadiusFromModelBoundingSphere(t,e){const s=this._attachedCamera;if(!s)return 0;let i=s._calculateLowerRadiusFromModelBoundingSphere(t,e,this._radiusScale);return s.lowerRadiusLimit&&this._mode===pt.IgnoreBoundsSizeMode&&(i=i<s.lowerRadiusLimit?s.lowerRadiusLimit:i),s.upperRadiusLimit&&(i=i>s.upperRadiusLimit?s.upperRadiusLimit:i),i}_maintainCameraAboveGround(){if(this._elevationReturnTime<0)return;const t=Nt.Now-this._lastInteractionTime,e=Math.PI*.5-this._defaultElevation,s=Math.PI*.5;if(this._attachedCamera&&!this._betaIsAnimating&&this._attachedCamera.beta>s&&t>=this._elevationReturnWaitTime){this._betaIsAnimating=!0,this.stopAllAnimations(),this._betaTransition||(this._betaTransition=yt.CreateAnimation("beta",yt.ANIMATIONTYPE_FLOAT,60,pt.EasingFunction));const i=yt.TransitionTo("beta",e,this._attachedCamera,this._attachedCamera.getScene(),60,this._betaTransition,this._elevationReturnTime,()=>{this._clearAnimationLocks(),this.stopAllAnimations()});i&&this._animatables.push(i)}}_clearAnimationLocks(){this._betaIsAnimating=!1}_applyUserInteraction(){this.isUserIsMoving&&(this._lastInteractionTime=Nt.Now,this.stopAllAnimations(),this._clearAnimationLocks())}stopAllAnimations(){for(this._attachedCamera&&(this._attachedCamera.animations=[]);this._animatables.length;)this._animatables[0]&&(this._animatables[0].onAnimationEnd=null,this._animatables[0].stop()),this._animatables.shift()}get isUserIsMoving(){return this._attachedCamera?this._attachedCamera.inertialAlphaOffset!==0||this._attachedCamera.inertialBetaOffset!==0||this._attachedCamera.inertialRadiusOffset!==0||this._attachedCamera.inertialPanningX!==0||this._attachedCamera.inertialPanningY!==0||this._isPointerDown:!1}}pt.EasingFunction=new ps;pt.EasingMode=Ae.EASINGMODE_EASEINOUT;pt.IgnoreBoundsSizeMode=0;pt.FitFrustumSidesMode=1;class Ie{constructor(){this._currentMousePointerIdDown=-1,this.buttons=[0,1,2]}attachControl(t){t=Pt.BackCompatCameraNoPreventDefault(arguments);const e=this.camera.getEngine(),s=e.getInputElement();let i=0,a=null;this._pointA=null,this._pointB=null,this._altKey=!1,this._ctrlKey=!1,this._metaKey=!1,this._shiftKey=!1,this._buttonsPressed=0,this._pointerInput=o=>{const c=o.event,f=c.pointerType==="touch";if(o.type!==lt.POINTERMOVE&&this.buttons.indexOf(c.button)===-1)return;const g=c.target;if(this._altKey=c.altKey,this._ctrlKey=c.ctrlKey,this._metaKey=c.metaKey,this._shiftKey=c.shiftKey,this._buttonsPressed=c.buttons,e.isPointerLock){const h=c.movementX,u=c.movementY;this.onTouch(null,h,u),this._pointA=null,this._pointB=null}else{if(o.type!==lt.POINTERDOWN&&o.type!==lt.POINTERDOUBLETAP&&f&&this._pointA?.pointerId!==c.pointerId&&this._pointB?.pointerId!==c.pointerId)return;if(o.type===lt.POINTERDOWN&&(this._currentMousePointerIdDown===-1||f)){try{g?.setPointerCapture(c.pointerId)}catch{}if(this._pointA===null)this._pointA={x:c.clientX,y:c.clientY,pointerId:c.pointerId,type:c.pointerType};else if(this._pointB===null)this._pointB={x:c.clientX,y:c.clientY,pointerId:c.pointerId,type:c.pointerType};else return;this._currentMousePointerIdDown===-1&&!f&&(this._currentMousePointerIdDown=c.pointerId),this.onButtonDown(c),t||(c.preventDefault(),s&&s.focus())}else if(o.type===lt.POINTERDOUBLETAP)this.onDoubleTap(c.pointerType);else if(o.type===lt.POINTERUP&&(this._currentMousePointerIdDown===c.pointerId||f)){try{g?.releasePointerCapture(c.pointerId)}catch{}f||(this._pointB=null),e._badOS?this._pointA=this._pointB=null:this._pointB&&this._pointA&&this._pointA.pointerId==c.pointerId?(this._pointA=this._pointB,this._pointB=null):this._pointA&&this._pointB&&this._pointB.pointerId==c.pointerId?this._pointB=null:this._pointA=this._pointB=null,(i!==0||a)&&(this.onMultiTouch(this._pointA,this._pointB,i,0,a,null),i=0,a=null),this._currentMousePointerIdDown=-1,this.onButtonUp(c),t||c.preventDefault()}else if(o.type===lt.POINTERMOVE){if(t||c.preventDefault(),this._pointA&&this._pointB===null){const h=c.clientX-this._pointA.x,u=c.clientY-this._pointA.y;this._pointA.x=c.clientX,this._pointA.y=c.clientY,this.onTouch(this._pointA,h,u)}else if(this._pointA&&this._pointB){const h=this._pointA.pointerId===c.pointerId?this._pointA:this._pointB;h.x=c.clientX,h.y=c.clientY;const u=this._pointA.x-this._pointB.x,_=this._pointA.y-this._pointB.y,d=u*u+_*_,A={x:(this._pointA.x+this._pointB.x)/2,y:(this._pointA.y+this._pointB.y)/2,pointerId:c.pointerId,type:o.type};this.onMultiTouch(this._pointA,this._pointB,i,d,a,A),a=A,i=d}}}},this._observer=this.camera.getScene()._inputManager._addCameraPointerObserver(this._pointerInput,lt.POINTERDOWN|lt.POINTERUP|lt.POINTERMOVE|lt.POINTERDOUBLETAP),this._onLostFocus=()=>{this._pointA=this._pointB=null,i=0,a=null,this.onLostFocus()},this._contextMenuBind=o=>this.onContextMenu(o),s&&s.addEventListener("contextmenu",this._contextMenuBind,!1);const n=this.camera.getScene().getEngine().getHostWindow();n&&Pt.RegisterTopRootEvents(n,[{name:"blur",handler:this._onLostFocus}])}detachControl(){if(this._onLostFocus){const t=this.camera.getScene().getEngine().getHostWindow();t&&Pt.UnregisterTopRootEvents(t,[{name:"blur",handler:this._onLostFocus}])}if(this._observer){if(this.camera.getScene()._inputManager._removeCameraPointerObserver(this._observer),this._observer=null,this._contextMenuBind){const t=this.camera.getScene().getEngine().getInputElement();t&&t.removeEventListener("contextmenu",this._contextMenuBind)}this._onLostFocus=null}this._altKey=!1,this._ctrlKey=!1,this._metaKey=!1,this._shiftKey=!1,this._buttonsPressed=0,this._currentMousePointerIdDown=-1}getClassName(){return"BaseCameraPointersInput"}getSimpleName(){return"pointers"}onDoubleTap(t){}onTouch(t,e,s){}onMultiTouch(t,e,s,i,a,n){}onContextMenu(t){t.preventDefault()}onButtonDown(t){}onButtonUp(t){}onLostFocus(){}}K([j()],Ie.prototype,"buttons",void 0);class gt extends Ie{constructor(){super(...arguments),this.buttons=[0,1,2],this.angularSensibilityX=1e3,this.angularSensibilityY=1e3,this.pinchPrecision=12,this.pinchDeltaPercentage=0,this.useNaturalPinchZoom=!1,this.pinchZoom=!0,this.panningSensibility=1e3,this.multiTouchPanning=!0,this.multiTouchPanAndZoom=!0,this.pinchInwards=!0,this._isPanClick=!1,this._twoFingerActivityCount=0,this._isPinching=!1}getClassName(){return"ArcRotateCameraPointersInput"}_computeMultiTouchPanning(t,e){if(this.panningSensibility!==0&&t&&e){const s=e.x-t.x,i=e.y-t.y;this.camera.inertialPanningX+=-s/this.panningSensibility,this.camera.inertialPanningY+=i/this.panningSensibility}}_computePinchZoom(t,e){const s=this.camera.radius||gt.MinimumRadiusForPinch;this.useNaturalPinchZoom?this.camera.radius=s*Math.sqrt(t)/Math.sqrt(e):this.pinchDeltaPercentage?this.camera.inertialRadiusOffset+=(e-t)*.001*s*this.pinchDeltaPercentage:this.camera.inertialRadiusOffset+=(e-t)/(this.pinchPrecision*(this.pinchInwards?1:-1)*(this.angularSensibilityX+this.angularSensibilityY)/2)}onTouch(t,e,s){this.panningSensibility!==0&&(this._ctrlKey&&this.camera._useCtrlForPanning||this._isPanClick)?(this.camera.inertialPanningX+=-e/this.panningSensibility,this.camera.inertialPanningY+=s/this.panningSensibility):(this.camera.inertialAlphaOffset-=e/this.angularSensibilityX,this.camera.inertialBetaOffset-=s/this.angularSensibilityY)}onDoubleTap(){this.camera.useInputToRestoreState&&this.camera.restoreState()}onMultiTouch(t,e,s,i,a,n){s===0&&a===null||i===0&&n===null||(this.multiTouchPanAndZoom?(this._computePinchZoom(s,i),this._computeMultiTouchPanning(a,n)):this.multiTouchPanning&&this.pinchZoom?(this._twoFingerActivityCount++,this._isPinching||this._twoFingerActivityCount<20&&Math.abs(Math.sqrt(i)-Math.sqrt(s))>this.camera.pinchToPanMaxDistance?(this._computePinchZoom(s,i),this._isPinching=!0):this._computeMultiTouchPanning(a,n)):this.multiTouchPanning?this._computeMultiTouchPanning(a,n):this.pinchZoom&&this._computePinchZoom(s,i))}onButtonDown(t){this._isPanClick=t.button===this.camera._panningMouseButton}onButtonUp(t){this._twoFingerActivityCount=0,this._isPinching=!1}onLostFocus(){this._isPanClick=!1,this._twoFingerActivityCount=0,this._isPinching=!1}}gt.MinimumRadiusForPinch=.001;K([j()],gt.prototype,"buttons",void 0);K([j()],gt.prototype,"angularSensibilityX",void 0);K([j()],gt.prototype,"angularSensibilityY",void 0);K([j()],gt.prototype,"pinchPrecision",void 0);K([j()],gt.prototype,"pinchDeltaPercentage",void 0);K([j()],gt.prototype,"useNaturalPinchZoom",void 0);K([j()],gt.prototype,"pinchZoom",void 0);K([j()],gt.prototype,"panningSensibility",void 0);K([j()],gt.prototype,"multiTouchPanning",void 0);K([j()],gt.prototype,"multiTouchPanAndZoom",void 0);re.ArcRotateCameraPointersInput=gt;class vt{constructor(){this.keysUp=[38],this.keysDown=[40],this.keysLeft=[37],this.keysRight=[39],this.keysReset=[220],this.panningSensibility=50,this.zoomingSensibility=25,this.useAltToZoom=!0,this.angularSpeed=.01,this._keys=new Array}attachControl(t){t=Pt.BackCompatCameraNoPreventDefault(arguments),!this._onCanvasBlurObserver&&(this._scene=this.camera.getScene(),this._engine=this._scene.getEngine(),this._onCanvasBlurObserver=this._engine.onCanvasBlurObservable.add(()=>{this._keys.length=0}),this._onKeyboardObserver=this._scene.onKeyboardObservable.add(e=>{const s=e.event;if(!s.metaKey){if(e.type===gs.KEYDOWN)this._ctrlPressed=s.ctrlKey,this._altPressed=s.altKey,(this.keysUp.indexOf(s.keyCode)!==-1||this.keysDown.indexOf(s.keyCode)!==-1||this.keysLeft.indexOf(s.keyCode)!==-1||this.keysRight.indexOf(s.keyCode)!==-1||this.keysReset.indexOf(s.keyCode)!==-1)&&(this._keys.indexOf(s.keyCode)===-1&&this._keys.push(s.keyCode),s.preventDefault&&(t||s.preventDefault()));else if(this.keysUp.indexOf(s.keyCode)!==-1||this.keysDown.indexOf(s.keyCode)!==-1||this.keysLeft.indexOf(s.keyCode)!==-1||this.keysRight.indexOf(s.keyCode)!==-1||this.keysReset.indexOf(s.keyCode)!==-1){const i=this._keys.indexOf(s.keyCode);i>=0&&this._keys.splice(i,1),s.preventDefault&&(t||s.preventDefault())}}}))}detachControl(){this._scene&&(this._onKeyboardObserver&&this._scene.onKeyboardObservable.remove(this._onKeyboardObserver),this._onCanvasBlurObserver&&this._engine.onCanvasBlurObservable.remove(this._onCanvasBlurObserver),this._onKeyboardObserver=null,this._onCanvasBlurObserver=null),this._keys.length=0}checkInputs(){if(this._onKeyboardObserver){const t=this.camera;for(let e=0;e<this._keys.length;e++){const s=this._keys[e];this.keysLeft.indexOf(s)!==-1?this._ctrlPressed&&this.camera._useCtrlForPanning?t.inertialPanningX-=1/this.panningSensibility:t.inertialAlphaOffset-=this.angularSpeed:this.keysUp.indexOf(s)!==-1?this._ctrlPressed&&this.camera._useCtrlForPanning?t.inertialPanningY+=1/this.panningSensibility:this._altPressed&&this.useAltToZoom?t.inertialRadiusOffset+=1/this.zoomingSensibility:t.inertialBetaOffset-=this.angularSpeed:this.keysRight.indexOf(s)!==-1?this._ctrlPressed&&this.camera._useCtrlForPanning?t.inertialPanningX+=1/this.panningSensibility:t.inertialAlphaOffset+=this.angularSpeed:this.keysDown.indexOf(s)!==-1?this._ctrlPressed&&this.camera._useCtrlForPanning?t.inertialPanningY-=1/this.panningSensibility:this._altPressed&&this.useAltToZoom?t.inertialRadiusOffset-=1/this.zoomingSensibility:t.inertialBetaOffset+=this.angularSpeed:this.keysReset.indexOf(s)!==-1&&t.useInputToRestoreState&&t.restoreState()}}}getClassName(){return"ArcRotateCameraKeyboardMoveInput"}getSimpleName(){return"keyboard"}}K([j()],vt.prototype,"keysUp",void 0);K([j()],vt.prototype,"keysDown",void 0);K([j()],vt.prototype,"keysLeft",void 0);K([j()],vt.prototype,"keysRight",void 0);K([j()],vt.prototype,"keysReset",void 0);K([j()],vt.prototype,"panningSensibility",void 0);K([j()],vt.prototype,"zoomingSensibility",void 0);K([j()],vt.prototype,"useAltToZoom",void 0);K([j()],vt.prototype,"angularSpeed",void 0);re.ArcRotateCameraKeyboardMoveInput=vt;const ks=40;class Wt{constructor(){this.wheelPrecision=3,this.zoomToMouseLocation=!1,this.wheelDeltaPercentage=0,this.customComputeDeltaFromMouseWheel=null,this._viewOffset=new P(0,0,0),this._globalOffset=new P(0,0,0),this._inertialPanning=P.Zero()}_computeDeltaFromMouseWheelLegacyEvent(t,e){let s=0;const i=t*.01*this.wheelDeltaPercentage*e;return t>0?s=i/(1+this.wheelDeltaPercentage):s=i*(1+this.wheelDeltaPercentage),s}attachControl(t){t=Pt.BackCompatCameraNoPreventDefault(arguments),this._wheel=e=>{if(e.type!==lt.POINTERWHEEL)return;const s=e.event;let i=0;const a=s.deltaMode===ms.DOM_DELTA_LINE?ks:1,n=-(s.deltaY*a);if(this.customComputeDeltaFromMouseWheel)i=this.customComputeDeltaFromMouseWheel(n,this,s);else if(this.wheelDeltaPercentage){if(i=this._computeDeltaFromMouseWheelLegacyEvent(n,this.camera.radius),i>0){let o=this.camera.radius,c=this.camera.inertialRadiusOffset+i;for(let f=0;f<20&&!(o<=c||Math.abs(c*this.camera.inertia)<.001);f++)o-=c,c*=this.camera.inertia;o=Vt(o,0,Number.MAX_VALUE),i=this._computeDeltaFromMouseWheelLegacyEvent(n,o)}}else i=n/(this.wheelPrecision*40);i&&(this.zoomToMouseLocation?(this._hitPlane||this._updateHitPlane(),this._zoomToMouse(i)):this.camera.inertialRadiusOffset+=i),s.preventDefault&&(t||s.preventDefault())},this._observer=this.camera.getScene()._inputManager._addCameraPointerObserver(this._wheel,lt.POINTERWHEEL),this.zoomToMouseLocation&&this._inertialPanning.setAll(0)}detachControl(){this._observer&&(this.camera.getScene()._inputManager._removeCameraPointerObserver(this._observer),this._observer=null,this._wheel=null)}checkInputs(){if(!this.zoomToMouseLocation)return;const t=this.camera;0+t.inertialAlphaOffset+t.inertialBetaOffset+t.inertialRadiusOffset&&(this._updateHitPlane(),t.target.addInPlace(this._inertialPanning),this._inertialPanning.scaleInPlace(t.inertia),this._zeroIfClose(this._inertialPanning))}getClassName(){return"ArcRotateCameraMouseWheelInput"}getSimpleName(){return"mousewheel"}_updateHitPlane(){const t=this.camera,e=t.target.subtract(t.position);this._hitPlane=_s.FromPositionAndNormal(t.target,e)}_getPosition(){const t=this.camera,e=t.getScene(),s=e.createPickingRay(e.pointerX,e.pointerY,at.Identity(),t,!1);(t.targetScreenOffset.x!==0||t.targetScreenOffset.y!==0)&&(this._viewOffset.set(t.targetScreenOffset.x,t.targetScreenOffset.y,0),t.getViewMatrix().invertToRef(t._cameraTransformMatrix),this._globalOffset=P.TransformNormal(this._viewOffset,t._cameraTransformMatrix),s.origin.addInPlace(this._globalOffset));let i=0;return this._hitPlane&&(i=s.intersectsPlane(this._hitPlane)??0),s.origin.addInPlace(s.direction.scaleInPlace(i))}_zoomToMouse(t){const e=this.camera,s=1-e.inertia;if(e.lowerRadiusLimit){const c=e.lowerRadiusLimit??0;e.radius-(e.inertialRadiusOffset+t)/s<c&&(t=(e.radius-c)*s-e.inertialRadiusOffset)}if(e.upperRadiusLimit){const c=e.upperRadiusLimit??0;e.radius-(e.inertialRadiusOffset+t)/s>c&&(t=(e.radius-c)*s-e.inertialRadiusOffset)}const a=t/s/e.radius,n=this._getPosition(),o=st.Vector3[6];n.subtractToRef(e.target,o),o.scaleInPlace(a),o.scaleInPlace(s),this._inertialPanning.addInPlace(o),e.inertialRadiusOffset+=t}_zeroIfClose(t){Math.abs(t.x)<ut&&(t.x=0),Math.abs(t.y)<ut&&(t.y=0),Math.abs(t.z)<ut&&(t.z=0)}}K([j()],Wt.prototype,"wheelPrecision",void 0);K([j()],Wt.prototype,"zoomToMouseLocation",void 0);K([j()],Wt.prototype,"wheelDeltaPercentage",void 0);re.ArcRotateCameraMouseWheelInput=Wt;class Us extends xs{constructor(t){super(t)}addMouseWheel(){return this.add(new Wt),this}addPointers(){return this.add(new gt),this}addKeyboard(){return this.add(new vt),this}}ve.AddNodeConstructor("ArcRotateCamera",(r,t)=>()=>new tt(r,0,0,1,P.Zero(),t));function Ws(r){let t=Math.PI/2;return r.x===0&&r.z===0||(t=Math.acos(r.x/Math.sqrt(Math.pow(r.x,2)+Math.pow(r.z,2)))),r.z<0&&(t=2*Math.PI-t),t}function Xs(r,t){return Math.acos(r/t)}function ft(r,t){return isNaN(r)?t:r}class tt extends ys{get target(){return this._target}set target(t){this.setTarget(t)}get targetHost(){return this._targetHost}set targetHost(t){t&&this.setTarget(t)}getTarget(){return this.target}get position(){return this._position}set position(t){this.setPosition(t)}set upVector(t){this._upToYMatrix||(this._yToUpMatrix=new at,this._upToYMatrix=new at,this._upVector=P.Zero()),t.normalize(),this._upVector.copyFrom(t),this.setMatUp()}get upVector(){return this._upVector}setMatUp(){at.RotationAlignToRef(P.UpReadOnly,this._upVector,this._yToUpMatrix),at.RotationAlignToRef(this._upVector,P.UpReadOnly,this._upToYMatrix)}get angularSensibilityX(){const t=this.inputs.attached.pointers;return t?t.angularSensibilityX:0}set angularSensibilityX(t){const e=this.inputs.attached.pointers;e&&(e.angularSensibilityX=t)}get angularSensibilityY(){const t=this.inputs.attached.pointers;return t?t.angularSensibilityY:0}set angularSensibilityY(t){const e=this.inputs.attached.pointers;e&&(e.angularSensibilityY=t)}get pinchPrecision(){const t=this.inputs.attached.pointers;return t?t.pinchPrecision:0}set pinchPrecision(t){const e=this.inputs.attached.pointers;e&&(e.pinchPrecision=t)}get pinchDeltaPercentage(){const t=this.inputs.attached.pointers;return t?t.pinchDeltaPercentage:0}set pinchDeltaPercentage(t){const e=this.inputs.attached.pointers;e&&(e.pinchDeltaPercentage=t)}get useNaturalPinchZoom(){const t=this.inputs.attached.pointers;return t?t.useNaturalPinchZoom:!1}set useNaturalPinchZoom(t){const e=this.inputs.attached.pointers;e&&(e.useNaturalPinchZoom=t)}get panningSensibility(){const t=this.inputs.attached.pointers;return t?t.panningSensibility:0}set panningSensibility(t){const e=this.inputs.attached.pointers;e&&(e.panningSensibility=t)}get keysUp(){const t=this.inputs.attached.keyboard;return t?t.keysUp:[]}set keysUp(t){const e=this.inputs.attached.keyboard;e&&(e.keysUp=t)}get keysDown(){const t=this.inputs.attached.keyboard;return t?t.keysDown:[]}set keysDown(t){const e=this.inputs.attached.keyboard;e&&(e.keysDown=t)}get keysLeft(){const t=this.inputs.attached.keyboard;return t?t.keysLeft:[]}set keysLeft(t){const e=this.inputs.attached.keyboard;e&&(e.keysLeft=t)}get keysRight(){const t=this.inputs.attached.keyboard;return t?t.keysRight:[]}set keysRight(t){const e=this.inputs.attached.keyboard;e&&(e.keysRight=t)}get wheelPrecision(){const t=this.inputs.attached.mousewheel;return t?t.wheelPrecision:0}set wheelPrecision(t){const e=this.inputs.attached.mousewheel;e&&(e.wheelPrecision=t)}get zoomToMouseLocation(){const t=this.inputs.attached.mousewheel;return t?t.zoomToMouseLocation:!1}set zoomToMouseLocation(t){const e=this.inputs.attached.mousewheel;e&&(e.zoomToMouseLocation=t)}get wheelDeltaPercentage(){const t=this.inputs.attached.mousewheel;return t?t.wheelDeltaPercentage:0}set wheelDeltaPercentage(t){const e=this.inputs.attached.mousewheel;e&&(e.wheelDeltaPercentage=t)}get isInterpolating(){return this._isInterpolating}get bouncingBehavior(){return this._bouncingBehavior}get useBouncingBehavior(){return this._bouncingBehavior!=null}set useBouncingBehavior(t){t!==this.useBouncingBehavior&&(t?(this._bouncingBehavior=new Rt,this.addBehavior(this._bouncingBehavior)):this._bouncingBehavior&&(this.removeBehavior(this._bouncingBehavior),this._bouncingBehavior=null))}get framingBehavior(){return this._framingBehavior}get useFramingBehavior(){return this._framingBehavior!=null}set useFramingBehavior(t){t!==this.useFramingBehavior&&(t?(this._framingBehavior=new pt,this.addBehavior(this._framingBehavior)):this._framingBehavior&&(this.removeBehavior(this._framingBehavior),this._framingBehavior=null))}get autoRotationBehavior(){return this._autoRotationBehavior}get useAutoRotationBehavior(){return this._autoRotationBehavior!=null}set useAutoRotationBehavior(t){t!==this.useAutoRotationBehavior&&(t?(this._autoRotationBehavior=new zs,this.addBehavior(this._autoRotationBehavior)):this._autoRotationBehavior&&(this.removeBehavior(this._autoRotationBehavior),this._autoRotationBehavior=null))}constructor(t,e,s,i,a,n,o=!0){super(t,P.Zero(),n,o),this.inertialAlphaOffset=0,this.inertialBetaOffset=0,this.inertialRadiusOffset=0,this.lowerAlphaLimit=null,this.upperAlphaLimit=null,this.lowerBetaLimit=.01,this.upperBetaLimit=Math.PI-.01,this.lowerRadiusLimit=null,this.upperRadiusLimit=null,this.lowerTargetYLimit=-1/0,this.inertialPanningX=0,this.inertialPanningY=0,this.pinchToPanMaxDistance=20,this.panningDistanceLimit=null,this.panningOriginTarget=P.Zero(),this.panningInertia=.9,this.zoomOnFactor=1,this.targetScreenOffset=rt.Zero(),this.allowUpsideDown=!0,this.useInputToRestoreState=!0,this.restoreStateInterpolationFactor=0,this._currentInterpolationFactor=0,this._viewMatrix=new at,this.panningAxis=new P(1,1,0),this._transformedDirection=new P,this.mapPanning=!1,this._isInterpolating=!1,this.onMeshTargetChangedObservable=new be,this.checkCollisions=!1,this.collisionRadius=new P(.5,.5,.5),this._previousPosition=P.Zero(),this._collisionVelocity=P.Zero(),this._newPosition=P.Zero(),this._computationVector=P.Zero(),this._goalAlpha=NaN,this._goalBeta=NaN,this._goalRadius=NaN,this._goalTarget=new P(NaN,NaN,NaN),this._goalTargetScreenOffset=new rt(NaN,NaN),this._onCollisionPositionChange=(c,f,g=null)=>{g?(this.setPosition(f),this.onCollide&&this.onCollide(g)):this._previousPosition.copyFrom(this._position);const h=Math.cos(this.alpha),u=Math.sin(this.alpha),_=Math.cos(this.beta);let d=Math.sin(this.beta);d===0&&(d=1e-4);const A=this._getTargetPosition();this._computationVector.copyFromFloats(this.radius*h*d,this.radius*_,this.radius*u*d),A.addToRef(this._computationVector,this._newPosition),this._position.copyFrom(this._newPosition);let y=this.upVector;this.allowUpsideDown&&this.beta<0&&(y=y.clone(),y=y.negate()),this._computeViewMatrix(this._position,A,y),this._viewMatrix.addAtIndex(12,this.targetScreenOffset.x),this._viewMatrix.addAtIndex(13,this.targetScreenOffset.y),this._collisionTriggered=!1},this._target=P.Zero(),a&&this.setTarget(a),this.alpha=e,this.beta=s,this.radius=i,this.getViewMatrix(),this.inputs=new Us(this),this.inputs.addKeyboard().addMouseWheel().addPointers()}_initCache(){super._initCache(),this._cache._target=new P(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE),this._cache.alpha=void 0,this._cache.beta=void 0,this._cache.radius=void 0,this._cache.targetScreenOffset=rt.Zero()}_updateCache(t){t||super._updateCache(),this._cache._target.copyFrom(this._getTargetPosition()),this._cache.alpha=this.alpha,this._cache.beta=this.beta,this._cache.radius=this.radius,this._cache.targetScreenOffset.copyFrom(this.targetScreenOffset)}_getTargetPosition(){if(this._targetHost&&this._targetHost.getAbsolutePosition){const e=this._targetHost.getAbsolutePosition();this._targetBoundingCenter?e.addToRef(this._targetBoundingCenter,this._target):this._target.copyFrom(e)}const t=this._getLockedTargetPosition();return t||this._target}storeState(){return this._storedAlpha=this.alpha,this._storedBeta=this.beta,this._storedRadius=this.radius,this._storedTarget=this._getTargetPosition().clone(),this._storedTargetScreenOffset=this.targetScreenOffset.clone(),super.storeState()}_restoreStateValues(){return this.hasStateStored()&&this.restoreStateInterpolationFactor>ut&&this.restoreStateInterpolationFactor<1?(this.interpolateTo(this._storedAlpha,this._storedBeta,this._storedRadius,this._storedTarget,this._storedTargetScreenOffset,this.restoreStateInterpolationFactor),!0):super._restoreStateValues()?(this.setTarget(this._storedTarget.clone()),this.alpha=this._storedAlpha,this.beta=this._storedBeta,this.radius=this._storedRadius,this.targetScreenOffset=this._storedTargetScreenOffset.clone(),this.inertialAlphaOffset=0,this.inertialBetaOffset=0,this.inertialRadiusOffset=0,this.inertialPanningX=0,this.inertialPanningY=0,!0):!1}stopInterpolation(){this._goalAlpha=NaN,this._goalBeta=NaN,this._goalRadius=NaN,this._goalTarget.set(NaN,NaN,NaN),this._goalTargetScreenOffset.set(NaN,NaN)}interpolateTo(t=this.alpha,e=this.beta,s=this.radius,i=this.target,a=this.targetScreenOffset,n){this.inertialAlphaOffset=0,this.inertialBetaOffset=0,this.inertialRadiusOffset=0,this.inertialPanningX=0,this.inertialPanningY=0,n!=null?this._currentInterpolationFactor=n:this.restoreStateInterpolationFactor!==0?this._currentInterpolationFactor=this.restoreStateInterpolationFactor:this._currentInterpolationFactor=.1,this._goalAlpha=ft(t,this._goalAlpha),this._goalBeta=ft(e,this._goalBeta),this._goalRadius=ft(s,this._goalRadius),this._goalTarget.set(ft(i.x,this._goalTarget.x),ft(i.y,this._goalTarget.y),ft(i.z,this._goalTarget.z)),this._goalTargetScreenOffset.set(ft(a.x,this._goalTargetScreenOffset.x),ft(a.y,this._goalTargetScreenOffset.y)),this._goalAlpha=Vt(this._goalAlpha,this.lowerAlphaLimit??-1/0,this.upperAlphaLimit??1/0),this._goalBeta=Vt(this._goalBeta,this.lowerBetaLimit??-1/0,this.upperBetaLimit??1/0),this._goalRadius=Vt(this._goalRadius,this.lowerRadiusLimit??-1/0,this.upperRadiusLimit??1/0),this._goalTarget.y=Vt(this._goalTarget.y,this.lowerTargetYLimit??-1/0,1/0),this._isInterpolating=!0}_isSynchronizedViewMatrix(){return super._isSynchronizedViewMatrix()?this._cache._target.equals(this._getTargetPosition())&&this._cache.alpha===this.alpha&&this._cache.beta===this.beta&&this._cache.radius===this.radius&&this._cache.targetScreenOffset.equals(this.targetScreenOffset):!1}attachControl(t,e,s=!0,i=2){const a=arguments;e=Pt.BackCompatCameraNoPreventDefault(a),this._useCtrlForPanning=s,this._panningMouseButton=i,typeof a[0]=="boolean"&&(a.length>1&&(this._useCtrlForPanning=a[1]),a.length>2&&(this._panningMouseButton=a[2])),this.inputs.attachElement(e),this._reset=()=>{this.inertialAlphaOffset=0,this.inertialBetaOffset=0,this.inertialRadiusOffset=0,this.inertialPanningX=0,this.inertialPanningY=0}}detachControl(){this.inputs.detachElement(),this._reset&&this._reset()}_checkInputs(){if(this._collisionTriggered)return;this.inputs.checkInputs();let t=!1;if(this.inertialAlphaOffset!==0||this.inertialBetaOffset!==0||this.inertialRadiusOffset!==0){t=!0;const e=this.invertRotation?-1:1,s=this._calculateHandednessMultiplier();let i=this.inertialAlphaOffset*s;this.beta<0&&(i*=-1),this.alpha+=i*e,this.beta+=this.inertialBetaOffset*e,this.radius-=this.inertialRadiusOffset,this.inertialAlphaOffset*=this.inertia,this.inertialBetaOffset*=this.inertia,this.inertialRadiusOffset*=this.inertia,Math.abs(this.inertialAlphaOffset)<ut&&(this.inertialAlphaOffset=0),Math.abs(this.inertialBetaOffset)<ut&&(this.inertialBetaOffset=0),Math.abs(this.inertialRadiusOffset)<this.speed*ut&&(this.inertialRadiusOffset=0)}if(this.inertialPanningX!==0||this.inertialPanningY!==0){t=!0;const e=new P(this.inertialPanningX,this.inertialPanningY,this.inertialPanningY);if(this._viewMatrix.invertToRef(this._cameraTransformMatrix),e.multiplyInPlace(this.panningAxis),P.TransformNormalToRef(e,this._cameraTransformMatrix,this._transformedDirection),this.mapPanning){const s=this.upVector,i=P.CrossToRef(this._transformedDirection,s,this._transformedDirection);P.CrossToRef(s,i,this._transformedDirection)}else this.panningAxis.y||(this._transformedDirection.y=0);if(!this._targetHost)if(this.panningDistanceLimit)this._transformedDirection.addInPlace(this._target),P.DistanceSquared(this._transformedDirection,this.panningOriginTarget)<=this.panningDistanceLimit*this.panningDistanceLimit&&this._target.copyFrom(this._transformedDirection);else{if(this.parent){const s=st.Matrix[0];this.parent.getWorldMatrix().getRotationMatrixToRef(s),s.transposeToRef(s),P.TransformCoordinatesToRef(this._transformedDirection,s,this._transformedDirection)}this._target.addInPlace(this._transformedDirection)}this.inertialPanningX*=this.panningInertia,this.inertialPanningY*=this.panningInertia,Math.abs(this.inertialPanningX)<this.speed*ut&&(this.inertialPanningX=0),Math.abs(this.inertialPanningY)<this.speed*ut&&(this.inertialPanningY=0)}if(t)this.stopInterpolation();else if(this._isInterpolating){let e=!1;const s=this._scene.getEngine().getDeltaTime()/1e3,i=1-Math.pow(2,-s/this._currentInterpolationFactor),a=ft(this._goalRadius,this.radius);if(!isNaN(this._goalTarget.x)||!isNaN(this._goalTarget.y)||!isNaN(this._goalTarget.z)){const n=st.Vector3[0].set(ft(this._goalTarget.x,this._target.x),ft(this._goalTarget.y,this._target.y),ft(this._goalTarget.z,this._target.z));P.LerpToRef(this.target,n,i,this._target),P.Distance(this.target,n)*10/a<ut?(this._goalTarget.set(NaN,NaN,NaN),this.target.copyFrom(n),this.setTarget(this.target,!1,!0,!0)):e=!0}if(!isNaN(this._goalAlpha)||!isNaN(this._goalBeta)){const n=Ht.RotationAlphaBetaGammaToRef(ft(this._goalAlpha,this.alpha),ft(this._goalBeta,this.beta),0,st.Quaternion[0]),o=Ht.RotationAlphaBetaGammaToRef(this.alpha,this.beta,0,st.Quaternion[1]),c=Ht.SlerpToRef(o,n,i,st.Quaternion[2]);c.normalize();const f=c.toAlphaBetaGammaToRef(st.Vector3[0]);if(this.alpha=f.x,this.beta=f.y,c.isApprox(n,ut/5)){this._goalAlpha=NaN,this._goalBeta=NaN;const g=n.toAlphaBetaGammaToRef(st.Vector3[0]);this.alpha=g.x,this.beta=g.y}else e=!0}if(isNaN(this._goalRadius)||(this.radius+=(a-this.radius)*i,Math.abs(a/this.radius-1)<ut?(this._goalRadius=NaN,this.radius=a):e=!0),!isNaN(this._goalTargetScreenOffset.x)||!isNaN(this._goalTargetScreenOffset.y)){const n=st.Vector2[0].set(ft(this._goalTargetScreenOffset.x,this.targetScreenOffset.x),ft(this._goalTargetScreenOffset.y,this.targetScreenOffset.y));rt.LerpToRef(this.targetScreenOffset,n,i,this.targetScreenOffset),rt.Distance(this.targetScreenOffset,n)<ut?(this._goalTargetScreenOffset.set(NaN,NaN),this.targetScreenOffset.copyFrom(n)):e=!0}this._isInterpolating=e}this._checkLimits(),super._checkInputs()}_checkLimits(){this.lowerBetaLimit===null||this.lowerBetaLimit===void 0?this.allowUpsideDown&&this.beta>Math.PI&&(this.beta=this.beta-2*Math.PI):this.beta<this.lowerBetaLimit&&(this.beta=this.lowerBetaLimit),this.upperBetaLimit===null||this.upperBetaLimit===void 0?this.allowUpsideDown&&this.beta<-Math.PI&&(this.beta=this.beta+2*Math.PI):this.beta>this.upperBetaLimit&&(this.beta=this.upperBetaLimit),this.lowerAlphaLimit!==null&&this.alpha<this.lowerAlphaLimit&&(this.alpha=this.lowerAlphaLimit),this.upperAlphaLimit!==null&&this.alpha>this.upperAlphaLimit&&(this.alpha=this.upperAlphaLimit),this.lowerRadiusLimit!==null&&this.radius<this.lowerRadiusLimit&&(this.radius=this.lowerRadiusLimit,this.inertialRadiusOffset=0),this.upperRadiusLimit!==null&&this.radius>this.upperRadiusLimit&&(this.radius=this.upperRadiusLimit,this.inertialRadiusOffset=0),this.target.y=Math.max(this.target.y,this.lowerTargetYLimit)}rebuildAnglesAndRadius(){this._position.subtractToRef(this._getTargetPosition(),this._computationVector),(this._upVector.x!==0||this._upVector.y!==1||this._upVector.z!==0)&&P.TransformCoordinatesToRef(this._computationVector,this._upToYMatrix,this._computationVector),this.radius=this._computationVector.length(),this.radius===0&&(this.radius=1e-4);const t=this.alpha;this.alpha=Ws(this._computationVector),this.beta=Xs(this._computationVector.y,this.radius);const e=Math.round((t-this.alpha)/(2*Math.PI));this.alpha+=e*2*Math.PI,this._checkLimits()}setPosition(t){this._position.equals(t)||(this._position.copyFrom(t),this.rebuildAnglesAndRadius())}setTarget(t,e=!1,s=!1,i=!1){if(i=this.overrideCloneAlphaBetaRadius??i,t.computeWorldMatrix)e&&t.getBoundingInfo?this._targetBoundingCenter=t.getBoundingInfo().boundingBox.centerWorld.clone():this._targetBoundingCenter=null,t.computeWorldMatrix(),this._targetHost=t,this._target=this._getTargetPosition(),this.onMeshTargetChangedObservable.notifyObservers(this._targetHost);else{const a=t,n=this._getTargetPosition();if(n&&!s&&n.equals(a))return;this._targetHost=null,this._target=a,this._targetBoundingCenter=null,this.onMeshTargetChangedObservable.notifyObservers(null)}i||this.rebuildAnglesAndRadius()}_getViewMatrix(){const t=Math.cos(this.alpha),e=Math.sin(this.alpha),s=Math.cos(this.beta);let i=Math.sin(this.beta);i===0&&(i=1e-4),this.radius===0&&(this.radius=1e-4);const a=this._getTargetPosition();if(this._computationVector.copyFromFloats(this.radius*t*i,this.radius*s,this.radius*e*i),(this._upVector.x!==0||this._upVector.y!==1||this._upVector.z!==0)&&P.TransformCoordinatesToRef(this._computationVector,this._yToUpMatrix,this._computationVector),a.addToRef(this._computationVector,this._newPosition),this.getScene().collisionsEnabled&&this.checkCollisions){const n=this.getScene().collisionCoordinator;this._collider||(this._collider=n.createCollider()),this._collider._radius=this.collisionRadius,this._newPosition.subtractToRef(this._position,this._collisionVelocity),this._collisionTriggered=!0,n.getNewPosition(this._position,this._collisionVelocity,this._collider,3,null,this._onCollisionPositionChange,this.uniqueId)}else{this._position.copyFrom(this._newPosition);let n=this.upVector;this.allowUpsideDown&&i<0&&(n=n.negate()),this._computeViewMatrix(this._position,a,n),this._viewMatrix.addAtIndex(12,this.targetScreenOffset.x),this._viewMatrix.addAtIndex(13,this.targetScreenOffset.y)}return this._currentTarget.copyFrom(a),this._viewMatrix}zoomOn(t,e=!1){t=t||this.getScene().meshes;const s=O.MinMax(t);let i=this._calculateLowerRadiusFromModelBoundingSphere(s.min,s.max);if(i=Math.max(Math.min(i,this.upperRadiusLimit||Number.MAX_VALUE),this.lowerRadiusLimit||0),this.radius=i*this.zoomOnFactor,this.mode===_t.ORTHOGRAPHIC_CAMERA){const a=this.getScene().getEngine().getAspectRatio(this),n=i*this.zoomOnFactor/2;this.orthoLeft=-n*a,this.orthoRight=n*a,this.orthoBottom=-n,this.orthoTop=n}this.focusOn({min:s.min,max:s.max,distance:i},e)}focusOn(t,e=!1){let s,i;if(t.min===void 0){const a=t||this.getScene().meshes;s=O.MinMax(a),i=P.Distance(s.min,s.max)}else{const a=t;s=a,i=a.distance}this._target=O.Center(s),e||(this.maxZ=i*2)}createRigCamera(t,e){let s=0;switch(this.cameraRigMode){case _t.RIG_MODE_STEREOSCOPIC_ANAGLYPH:case _t.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL:case _t.RIG_MODE_STEREOSCOPIC_OVERUNDER:case _t.RIG_MODE_STEREOSCOPIC_INTERLACED:case _t.RIG_MODE_VR:s=this._cameraRigParams.stereoHalfAngle*(e===0?1:-1);break;case _t.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED:s=this._cameraRigParams.stereoHalfAngle*(e===0?-1:1);break}const i=new tt(t,this.alpha+s,this.beta,this.radius,this._target,this.getScene());return i._cameraRigParams={},i.isRigCamera=!0,i.rigParent=this,i.upVector=this.upVector,i.mode=this.mode,i.orthoLeft=this.orthoLeft,i.orthoRight=this.orthoRight,i.orthoBottom=this.orthoBottom,i.orthoTop=this.orthoTop,i}_updateRigCameras(){const t=this._rigCameras[0],e=this._rigCameras[1];switch(t.beta=e.beta=this.beta,this.cameraRigMode){case _t.RIG_MODE_STEREOSCOPIC_ANAGLYPH:case _t.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL:case _t.RIG_MODE_STEREOSCOPIC_OVERUNDER:case _t.RIG_MODE_STEREOSCOPIC_INTERLACED:case _t.RIG_MODE_VR:t.alpha=this.alpha-this._cameraRigParams.stereoHalfAngle,e.alpha=this.alpha+this._cameraRigParams.stereoHalfAngle;break;case _t.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED:t.alpha=this.alpha+this._cameraRigParams.stereoHalfAngle,e.alpha=this.alpha-this._cameraRigParams.stereoHalfAngle;break}super._updateRigCameras()}_calculateLowerRadiusFromModelBoundingSphere(t,e,s=1){const i=P.Distance(t,e),n=this.getScene().getEngine().getAspectRatio(this),o=Math.tan(this.fov/2),c=o*n,g=i*.5*s,h=g*Math.sqrt(1+1/(c*c)),u=g*Math.sqrt(1+1/(o*o));return Math.max(h,u)}dispose(){this.inputs.clear(),super.dispose()}getClassName(){return"ArcRotateCamera"}}K([j()],tt.prototype,"alpha",void 0);K([j()],tt.prototype,"beta",void 0);K([j()],tt.prototype,"radius",void 0);K([j()],tt.prototype,"overrideCloneAlphaBetaRadius",void 0);K([oe("target")],tt.prototype,"_target",void 0);K([As("targetHost")],tt.prototype,"_targetHost",void 0);K([j()],tt.prototype,"inertialAlphaOffset",void 0);K([j()],tt.prototype,"inertialBetaOffset",void 0);K([j()],tt.prototype,"inertialRadiusOffset",void 0);K([j()],tt.prototype,"lowerAlphaLimit",void 0);K([j()],tt.prototype,"upperAlphaLimit",void 0);K([j()],tt.prototype,"lowerBetaLimit",void 0);K([j()],tt.prototype,"upperBetaLimit",void 0);K([j()],tt.prototype,"lowerRadiusLimit",void 0);K([j()],tt.prototype,"upperRadiusLimit",void 0);K([j()],tt.prototype,"lowerTargetYLimit",void 0);K([j()],tt.prototype,"inertialPanningX",void 0);K([j()],tt.prototype,"inertialPanningY",void 0);K([j()],tt.prototype,"pinchToPanMaxDistance",void 0);K([j()],tt.prototype,"panningDistanceLimit",void 0);K([oe()],tt.prototype,"panningOriginTarget",void 0);K([j()],tt.prototype,"panningInertia",void 0);K([j()],tt.prototype,"zoomToMouseLocation",null);K([j()],tt.prototype,"zoomOnFactor",void 0);K([bs()],tt.prototype,"targetScreenOffset",void 0);K([j()],tt.prototype,"allowUpsideDown",void 0);K([j()],tt.prototype,"useInputToRestoreState",void 0);K([j()],tt.prototype,"restoreStateInterpolationFactor",void 0);he("BABYLON.ArcRotateCamera",tt);ve.AddNodeConstructor("Light_Type_3",(r,t)=>()=>new Kt(r,P.Zero(),t));class Kt extends ge{constructor(t,e,s){super(t,s),this.groundColor=new kt(0,0,0),this.direction=e||P.Up()}_buildUniformLayout(){this._uniformBuffer.addUniform("vLightData",4),this._uniformBuffer.addUniform("vLightDiffuse",4),this._uniformBuffer.addUniform("vLightSpecular",4),this._uniformBuffer.addUniform("vLightGround",3),this._uniformBuffer.addUniform("shadowsInfo",3),this._uniformBuffer.addUniform("depthValues",2),this._uniformBuffer.create()}getClassName(){return"HemisphericLight"}setDirectionToTarget(t){return this.direction=P.Normalize(t.subtract(P.Zero())),this.direction}getShadowGenerator(){return null}transferToEffect(t,e){const s=P.Normalize(this.direction);return this._uniformBuffer.updateFloat4("vLightData",s.x,s.y,s.z,0,e),this._uniformBuffer.updateColor3("vLightGround",this.groundColor.scale(this.intensity),e),this}transferToNodeMaterialEffect(t,e){const s=P.Normalize(this.direction);return t.setFloat3(e,s.x,s.y,s.z),this}computeWorldMatrix(){return this._worldMatrix||(this._worldMatrix=at.Identity()),this._worldMatrix}getTypeID(){return ge.LIGHTTYPEID_HEMISPHERICLIGHT}prepareLightSpecificDefines(t,e){t["HEMILIGHT"+e]=!0}}K([vs()],Kt.prototype,"groundColor",void 0);K([oe()],Kt.prototype,"direction",void 0);he("BABYLON.HemisphericLight",Kt);function we(r){let t=r.pathArray;const e=r.closeArray||!1,s=r.closePath||!1,i=r.invertUV||!1,a=Math.floor(t[0].length/2);let n=r.offset||a;n=n>a?a:Math.floor(n);const o=r.sideOrientation===0?0:r.sideOrientation||k.DEFAULTSIDE,c=r.uvs,f=r.colors,g=[],h=[],u=[],_=[],d=[],A=[],y=[],b=[];let I;const w=[],v=[];let p,x,m;if(t.length<2){const W=[],J=[];for(x=0;x<t[0].length-n;x++)W.push(t[0][x]),J.push(t[0][x+n]);t=[W,J]}let M=0;const R=s?1:0,D=e?1:0;let L,V;I=t[0].length;let N,q;for(p=0;p<t.length+D;p++){for(y[p]=0,d[p]=[0],L=p===t.length?t[0]:t[p],V=L.length,I=I<V?I:V,m=0;m<V;)g.push(L[m].x,L[m].y,L[m].z),m>0&&(N=L[m].subtract(L[m-1]).length(),q=N+y[p],d[p].push(q),y[p]=q),m++;s&&(m--,g.push(L[0].x,L[0].y,L[0].z),N=L[m].subtract(L[0]).length(),q=N+y[p],d[p].push(q),y[p]=q),w[p]=V+R,v[p]=M,M+=V+R}let U,G,z=null,X=null;for(x=0;x<I+R;x++)for(b[x]=0,A[x]=[0],p=0;p<t.length-1+D;p++)U=t[p],G=p===t.length-1?t[0]:t[p+1],x===I?(z=U[0],X=G[0]):(z=U[x],X=G[x]),N=X.subtract(z).length(),q=N+b[x],A[x].push(q),b[x]=q;let B,S;if(c)for(p=0;p<c.length;p++)_.push(c[p].x,c[p].y);else for(p=0;p<t.length+D;p++)for(x=0;x<I+R;x++)B=y[p]!=0?d[p][x]/y[p]:0,S=b[x]!=0?A[x][p]/b[x]:0,i?_.push(S,B):_.push(B,S);p=0;let l=0,T=w[p]-1,C=w[p+1]-1,E=T<C?T:C,Y=v[1]-v[0];const F=w.length-1;for(;l<=E&&p<F;)h.push(l,l+Y,l+1),h.push(l+Y+1,l+1,l+Y),l+=1,l===E&&(p++,Y=v[p+1]-v[p],T=w[p]-1,C=w[p+1]-1,l=v[p],E=T<C?T+l:C+l);if(k.ComputeNormals(g,h,u),s){let W=0,J=0;for(p=0;p<t.length;p++){W=v[p]*3,p+1<t.length?J=(v[p+1]-1)*3:J=u.length-3,u[W]=(u[W]+u[J])*.5,u[W+1]=(u[W+1]+u[J+1])*.5,u[W+2]=(u[W+2]+u[J+2])*.5;const Z=Math.sqrt(u[W]*u[W]+u[W+1]*u[W+1]+u[W+2]*u[W+2]);u[W]/=Z,u[W+1]/=Z,u[W+2]/=Z,u[J]=u[W],u[J+1]=u[W+1],u[J+2]=u[W+2]}}if(e){let W=v[0]*3,J=v[t.length]*3;for(x=0;x<I+R;x++){u[W]=(u[W]+u[J])*.5,u[W+1]=(u[W+1]+u[J+1])*.5,u[W+2]=(u[W+2]+u[J+2])*.5;const Z=Math.sqrt(u[W]*u[W]+u[W+1]*u[W+1]+u[W+2]*u[W+2]);u[W]/=Z,u[W+1]/=Z,u[W+2]/=Z,u[J]=u[W],u[J+1]=u[W+1],u[J+2]=u[W+2],W+=3,J+=3}}k._ComputeSides(o,g,h,u,_,r.frontUVs,r.backUVs);let H=null;if(f){H=new Float32Array(f.length*4);for(let W=0;W<f.length;W++)H[W*4]=f[W].r,H[W*4+1]=f[W].g,H[W*4+2]=f[W].b,H[W*4+3]=f[W].a}const $=new k,ot=new Float32Array(g),it=new Float32Array(u),ht=new Float32Array(_);return $.indices=h,$.positions=ot,$.normals=it,$.uvs=ht,H&&$.set(H,Q.ColorKind),s&&($._idx=v),$}function Dt(r,t,e=null){const s=t.pathArray,i=t.closeArray,a=t.closePath,n=O._GetDefaultSideOrientation(t.sideOrientation),o=t.instance,c=t.updatable;if(o){const f=st.Vector3[0].setAll(Number.MAX_VALUE),g=st.Vector3[1].setAll(-Number.MAX_VALUE),h=_=>{let d=s[0].length;const A=o;let y=0;const b=A._originalBuilderSideOrientation===O.DOUBLESIDE?2:1;for(let I=1;I<=b;++I)for(let w=0;w<s.length;++w){const v=s[w],p=v.length;d=d<p?d:p;for(let x=0;x<d;++x){const m=v[x];_[y]=m.x,_[y+1]=m.y,_[y+2]=m.z,f.minimizeInPlaceFromFloats(m.x,m.y,m.z),g.maximizeInPlaceFromFloats(m.x,m.y,m.z),y+=3}if(A._creationDataStorage&&A._creationDataStorage.closePath){const x=v[0];_[y]=x.x,_[y+1]=x.y,_[y+2]=x.z,y+=3}}},u=o.getVerticesData(Q.PositionKind);if(h(u),o.hasBoundingInfo?o.getBoundingInfo().reConstruct(f,g,o._worldMatrix):o.buildBoundingInfo(f,g,o._worldMatrix),o.updateVerticesData(Q.PositionKind,u,!1,!1),t.colors){const _=o.getVerticesData(Q.ColorKind);for(let d=0,A=0;d<t.colors.length;d++,A+=4){const y=t.colors[d];_[A]=y.r,_[A+1]=y.g,_[A+2]=y.b,_[A+3]=y.a}o.updateVerticesData(Q.ColorKind,_,!1,!1)}if(t.uvs){const _=o.getVerticesData(Q.UVKind);for(let d=0;d<t.uvs.length;d++)_[d*2]=t.uvs[d].x,_[d*2+1]=t.uvs[d].y;o.updateVerticesData(Q.UVKind,_,!1,!1)}if(!o.areNormalsFrozen||o.isFacetDataEnabled){const _=o.getIndices(),d=o.getVerticesData(Q.NormalKind),A=o.isFacetDataEnabled?o.getFacetDataParameters():null;if(k.ComputeNormals(u,_,d,A),o._creationDataStorage&&o._creationDataStorage.closePath){let y=0,b=0;for(let I=0;I<s.length;I++)y=o._creationDataStorage.idx[I]*3,I+1<s.length?b=(o._creationDataStorage.idx[I+1]-1)*3:b=d.length-3,d[y]=(d[y]+d[b])*.5,d[y+1]=(d[y+1]+d[b+1])*.5,d[y+2]=(d[y+2]+d[b+2])*.5,d[b]=d[y],d[b+1]=d[y+1],d[b+2]=d[y+2]}o.areNormalsFrozen||o.updateVerticesData(Q.NormalKind,d,!1,!1)}return o}else{const f=new O(r,e);f._originalBuilderSideOrientation=n,f._creationDataStorage=new Oe;const g=we(t);return a&&(f._creationDataStorage.idx=g._idx),f._creationDataStorage.closePath=a,f._creationDataStorage.closeArray=i,g.applyToMesh(f,c),f}}k.CreateRibbon=we;O.CreateRibbon=(r,t,e=!1,s,i,a,n=!1,o,c)=>Dt(r,{pathArray:t,closeArray:e,closePath:s,offset:i,updatable:n,sideOrientation:o,instance:c},a);function Pe(r){const t=[],e=[],s=[],i=[],a=r.radius||.5,n=r.tessellation||64,o=r.arc&&(r.arc<=0||r.arc>1)?1:r.arc||1,c=r.sideOrientation===0?0:r.sideOrientation||k.DEFAULTSIDE;t.push(0,0,0),i.push(.5,.5);const f=Math.PI*2*o,g=o===1?f/n:f/(n-1);let h=0;for(let d=0;d<n;d++){const A=Math.cos(h),y=Math.sin(h),b=(A+1)/2,I=(1-y)/2;t.push(a*A,a*y,0),i.push(b,I),h+=g}o===1&&(t.push(t[3],t[4],t[5]),i.push(i[2],i[3]));const u=t.length/3;for(let d=1;d<u-1;d++)e.push(d+1,0,d);k.ComputeNormals(t,e,s),k._ComputeSides(c,t,e,s,i,r.frontUVs,r.backUVs);const _=new k;return _.indices=e,_.positions=t,_.normals=s,_.uvs=i,_}function Re(r,t={},e=null){const s=new O(r,e);return t.sideOrientation=O._GetDefaultSideOrientation(t.sideOrientation),s._originalBuilderSideOrientation=t.sideOrientation,Pe(t).applyToMesh(s,t.updatable),s}k.CreateDisc=Pe;O.CreateDisc=(r,t,e,s=null,i,a)=>Re(r,{radius:t,tessellation:e,sideOrientation:a,updatable:i},s);O._GroundMeshParser=(r,t)=>Xt.Parse(r,t);class Xt extends O{constructor(t,e){super(t,e),this.generateOctree=!1}getClassName(){return"GroundMesh"}get subdivisions(){return Math.min(this._subdivisionsX,this._subdivisionsY)}get subdivisionsX(){return this._subdivisionsX}get subdivisionsY(){return this._subdivisionsY}optimize(t,e=32){this._subdivisionsX=t,this._subdivisionsY=t,this.subdivide(t);const s=this;s.createOrUpdateSubmeshesOctree&&s.createOrUpdateSubmeshesOctree(e)}getHeightAtCoordinates(t,e){const s=this.getWorldMatrix(),i=st.Matrix[5];s.invertToRef(i);const a=st.Vector3[8];if(P.TransformCoordinatesFromFloatsToRef(t,0,e,i,a),t=a.x,e=a.z,t<this._minX||t>=this._maxX||e<=this._minZ||e>this._maxZ)return this.position.y;(!this._heightQuads||this._heightQuads.length==0)&&(this._initHeightQuads(),this._computeHeightQuads());const n=this._getFacetAt(t,e),o=-(n.x*t+n.z*e+n.w)/n.y;return P.TransformCoordinatesFromFloatsToRef(0,o,0,s,a),a.y}getNormalAtCoordinates(t,e){const s=new P(0,1,0);return this.getNormalAtCoordinatesToRef(t,e,s),s}getNormalAtCoordinatesToRef(t,e,s){const i=this.getWorldMatrix(),a=st.Matrix[5];i.invertToRef(a);const n=st.Vector3[8];if(P.TransformCoordinatesFromFloatsToRef(t,0,e,a,n),t=n.x,e=n.z,t<this._minX||t>this._maxX||e<this._minZ||e>this._maxZ)return this;(!this._heightQuads||this._heightQuads.length==0)&&(this._initHeightQuads(),this._computeHeightQuads());const o=this._getFacetAt(t,e);return P.TransformNormalFromFloatsToRef(o.x,o.y,o.z,i,s),this}updateCoordinateHeights(){return(!this._heightQuads||this._heightQuads.length==0)&&this._initHeightQuads(),this._computeHeightQuads(),this}_getFacetAt(t,e){const s=Math.floor((t+this._maxX)*this._subdivisionsX/this._width),i=Math.floor(-(e+this._maxZ)*this._subdivisionsY/this._height+this._subdivisionsY),a=this._heightQuads[i*this._subdivisionsX+s];let n;return e<a.slope.x*t+a.slope.y?n=a.facet1:n=a.facet2,n}_initHeightQuads(){const t=this._subdivisionsX,e=this._subdivisionsY;this._heightQuads=[];for(let s=0;s<e;s++)for(let i=0;i<t;i++){const a={slope:rt.Zero(),facet1:new Mt(0,0,0,0),facet2:new Mt(0,0,0,0)};this._heightQuads[s*t+i]=a}return this}_computeHeightQuads(){const t=this.getVerticesData(Q.PositionKind);if(!t)return this;const e=st.Vector3[3],s=st.Vector3[2],i=st.Vector3[1],a=st.Vector3[0],n=st.Vector3[4],o=st.Vector3[5],c=st.Vector3[6],f=st.Vector3[7],g=st.Vector3[8];let h=0,u=0,_=0,d=0,A=0,y=0,b=0;const I=this._subdivisionsX,w=this._subdivisionsY;for(let v=0;v<w;v++)for(let p=0;p<I;p++){h=p*3,u=v*(I+1)*3,_=(v+1)*(I+1)*3,e.x=t[u+h],e.y=t[u+h+1],e.z=t[u+h+2],s.x=t[u+h+3],s.y=t[u+h+4],s.z=t[u+h+5],i.x=t[_+h],i.y=t[_+h+1],i.z=t[_+h+2],a.x=t[_+h+3],a.y=t[_+h+4],a.z=t[_+h+5],d=(a.z-e.z)/(a.x-e.x),A=e.z-d*e.x,s.subtractToRef(e,n),i.subtractToRef(e,o),a.subtractToRef(e,c),P.CrossToRef(c,o,f),P.CrossToRef(n,c,g),f.normalize(),g.normalize(),y=-(f.x*e.x+f.y*e.y+f.z*e.z),b=-(g.x*s.x+g.y*s.y+g.z*s.z);const x=this._heightQuads[v*I+p];x.slope.copyFromFloats(d,A),x.facet1.copyFromFloats(f.x,f.y,f.z,y),x.facet2.copyFromFloats(g.x,g.y,g.z,b)}return this}serialize(t){super.serialize(t),t.subdivisionsX=this._subdivisionsX,t.subdivisionsY=this._subdivisionsY,t.minX=this._minX,t.maxX=this._maxX,t.minZ=this._minZ,t.maxZ=this._maxZ,t.width=this._width,t.height=this._height}static Parse(t,e){const s=new Xt(t.name,e);return s._subdivisionsX=t.subdivisionsX||1,s._subdivisionsY=t.subdivisionsY||1,s._minX=t.minX,s._maxX=t.maxX,s._minZ=t.minZ,s._maxZ=t.maxZ,s._width=t.width,s._height=t.height,s}}function Me(r){const t=[],e=[],s=[],i=[];let a,n;const o=r.width||r.size||1,c=r.height||r.size||1,f=(r.subdivisionsX||r.subdivisions||1)|0,g=(r.subdivisionsY||r.subdivisions||1)|0;for(a=0;a<=g;a++)for(n=0;n<=f;n++){const u=new P(n*o/f-o/2,0,(g-a)*c/g-c/2),_=new P(0,1,0);e.push(u.x,u.y,u.z),s.push(_.x,_.y,_.z),i.push(n/f,1-a/g)}for(a=0;a<g;a++)for(n=0;n<f;n++)t.push(n+1+(a+1)*(f+1)),t.push(n+1+a*(f+1)),t.push(n+a*(f+1)),t.push(n+(a+1)*(f+1)),t.push(n+1+(a+1)*(f+1)),t.push(n+a*(f+1));const h=new k;return h.indices=t,h.positions=e,h.normals=s,h.uvs=i,h}function De(r){const t=r.xmin!==void 0&&r.xmin!==null?r.xmin:-1,e=r.zmin!==void 0&&r.zmin!==null?r.zmin:-1,s=r.xmax!==void 0&&r.xmax!==null?r.xmax:1,i=r.zmax!==void 0&&r.zmax!==null?r.zmax:1,a=r.subdivisions||{w:1,h:1},n=r.precision||{w:1,h:1},o=[],c=[],f=[],g=[];let h,u,_,d;a.h=a.h<1?1:a.h,a.w=a.w<1?1:a.w,n.w=n.w<1?1:n.w,n.h=n.h<1?1:n.h;const A={w:(s-t)/a.w,h:(i-e)/a.h};function y(I,w,v,p){const x=c.length/3,m=n.w+1;for(h=0;h<n.h;h++)for(u=0;u<n.w;u++){const D=[x+u+h*m,x+(u+1)+h*m,x+(u+1)+(h+1)*m,x+u+(h+1)*m];o.push(D[1]),o.push(D[2]),o.push(D[3]),o.push(D[0]),o.push(D[1]),o.push(D[3])}const M=P.Zero(),R=new P(0,1,0);for(h=0;h<=n.h;h++)for(M.z=h*(p-w)/n.h+w,u=0;u<=n.w;u++)M.x=u*(v-I)/n.w+I,M.y=0,c.push(M.x,M.y,M.z),f.push(R.x,R.y,R.z),g.push(u/n.w,h/n.h)}for(_=0;_<a.h;_++)for(d=0;d<a.w;d++)y(t+d*A.w,e+_*A.h,t+(d+1)*A.w,e+(_+1)*A.h);const b=new k;return b.indices=o,b.positions=c,b.normals=f,b.uvs=g,b}function Se(r){const t=[],e=[],s=[],i=[];let a,n;const o=r.colorFilter||new kt(.3,.59,.11),c=r.alphaFilter||0;let f=!1;if(r.minHeight>r.maxHeight){f=!0;const h=r.maxHeight;r.maxHeight=r.minHeight,r.minHeight=h}for(a=0;a<=r.subdivisions;a++)for(n=0;n<=r.subdivisions;n++){const h=new P(n*r.width/r.subdivisions-r.width/2,0,(r.subdivisions-a)*r.height/r.subdivisions-r.height/2),u=(h.x+r.width/2)/r.width*(r.bufferWidth-1)|0,_=(1-(h.z+r.height/2)/r.height)*(r.bufferHeight-1)|0,d=(u+_*r.bufferWidth)*4;let A=r.buffer[d]/255,y=r.buffer[d+1]/255,b=r.buffer[d+2]/255;const I=r.buffer[d+3]/255;f&&(A=1-A,y=1-y,b=1-b);const w=A*o.r+y*o.g+b*o.b;I>=c?h.y=r.minHeight+(r.maxHeight-r.minHeight)*w:h.y=r.minHeight-ut,r.heightBuffer&&(r.heightBuffer[a*(r.subdivisions+1)+n]=h.y),e.push(h.x,h.y,h.z),s.push(0,0,0),i.push(n/r.subdivisions,1-a/r.subdivisions)}for(a=0;a<r.subdivisions;a++)for(n=0;n<r.subdivisions;n++){const h=n+1+(a+1)*(r.subdivisions+1),u=n+1+a*(r.subdivisions+1),_=n+a*(r.subdivisions+1),d=n+(a+1)*(r.subdivisions+1),A=e[h*3+1]>=r.minHeight,y=e[u*3+1]>=r.minHeight,b=e[_*3+1]>=r.minHeight;A&&y&&b&&(t.push(h),t.push(u),t.push(_)),e[d*3+1]>=r.minHeight&&A&&b&&(t.push(d),t.push(h),t.push(_))}k.ComputeNormals(e,t,s);const g=new k;return g.indices=t,g.positions=e,g.normals=s,g.uvs=i,g}function Be(r,t={},e){const s=new Xt(r,e);return s._setReady(!1),s._subdivisionsX=t.subdivisionsX||t.subdivisions||1,s._subdivisionsY=t.subdivisionsY||t.subdivisions||1,s._width=t.width||1,s._height=t.height||1,s._maxX=s._width/2,s._maxZ=s._height/2,s._minX=-s._maxX,s._minZ=-s._maxZ,Me(t).applyToMesh(s,t.updatable),s._setReady(!0),s}function Ee(r,t,e=null){const s=new O(r,e);return De(t).applyToMesh(s,t.updatable),s}function Le(r,t,e={},s=null){const i=e.width||10,a=e.height||10,n=e.subdivisions||1,o=e.minHeight||0,c=e.maxHeight||1,f=e.colorFilter||new kt(.3,.59,.11),g=e.alphaFilter||0,h=e.updatable,u=e.onReady;s=s||Ut.LastCreatedScene;const _=new Xt(r,s);_._subdivisionsX=n,_._subdivisionsY=n,_._width=i,_._height=a,_._maxX=_._width/2,_._maxZ=_._height/2,_._minX=-_._maxX,_._minZ=-_._maxZ,_._setReady(!1);let d;e.passHeightBufferInCallback&&(d=new Float32Array((n+1)*(n+1)));const A=(y,b,I)=>{Se({width:i,height:a,subdivisions:n,minHeight:o,maxHeight:c,colorFilter:f,buffer:y,bufferWidth:b,bufferHeight:I,alphaFilter:g,heightBuffer:d}).applyToMesh(_,h),u&&u(_,d),_._setReady(!0)};if(typeof t=="string"){const y=b=>{const I=b.width,w=b.height;if(s.isDisposed)return;const v=s?.getEngine().resizeImageBitmap(b,I,w);A(v,I,w)};Pt.LoadImage(t,y,e.onError?e.onError:()=>{},s.offlineProvider)}else A(t.data,t.width,t.height);return _}k.CreateGround=Me;k.CreateTiledGround=De;k.CreateGroundFromHeightMap=Se;O.CreateGround=(r,t,e,s,i,a)=>Be(r,{width:t,height:e,subdivisions:s,updatable:a},i);O.CreateTiledGround=(r,t,e,s,i,a,n,o,c)=>Ee(r,{xmin:t,zmin:e,xmax:s,zmax:i,subdivisions:a,precision:n,updatable:c},o);O.CreateGroundFromHeightMap=(r,t,e,s,i,a,n,o,c,f,g)=>Le(r,t,{width:e,height:s,subdivisions:i,minHeight:a,maxHeight:n,updatable:c,onReady:f,alphaFilter:g},o);function Fe(r){let e=[0,1,2,0,2,3,4,5,6,4,6,7,8,9,10,8,10,11,12,13,14,12,14,15,16,17,18,16,18,19,20,21,22,20,22,23];const s=[0,0,1,0,0,1,0,0,1,0,0,1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,1,0,0,1,0,0,1,0,0,1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,0,1,0,0,1,0,0,1,0,0,1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0],i=[];let a=[];const n=r.width||r.size||1,o=r.height||r.size||1,c=r.depth||r.size||1,f=r.wrap||!1;let g=r.topBaseAt===void 0?1:r.topBaseAt,h=r.bottomBaseAt===void 0?0:r.bottomBaseAt;g=(g+4)%4,h=(h+4)%4;const u=[2,0,3,1],_=[2,0,1,3];let d=u[g],A=_[h],y=[1,-1,1,-1,-1,1,-1,1,1,1,1,1,1,1,-1,-1,1,-1,-1,-1,-1,1,-1,-1,1,1,-1,1,-1,-1,1,-1,1,1,1,1,-1,1,1,-1,-1,1,-1,-1,-1,-1,1,-1,-1,1,1,-1,1,-1,1,1,-1,1,1,1,1,-1,1,1,-1,-1,-1,-1,-1,-1,-1,1];if(f){e=[2,3,0,2,0,1,4,5,6,4,6,7,9,10,11,9,11,8,12,14,15,12,13,14],y=[-1,1,1,1,1,1,1,-1,1,-1,-1,1,1,1,-1,-1,1,-1,-1,-1,-1,1,-1,-1,1,1,1,1,1,-1,1,-1,-1,1,-1,1,-1,1,-1,-1,1,1,-1,-1,1,-1,-1,-1];let m=[[1,1,1],[-1,1,1],[-1,1,-1],[1,1,-1]],M=[[-1,-1,1],[1,-1,1],[1,-1,-1],[-1,-1,-1]];const R=[17,18,19,16],D=[22,23,20,21];for(;d>0;)m.unshift(m.pop()),R.unshift(R.pop()),d--;for(;A>0;)M.unshift(M.pop()),D.unshift(D.pop()),A--;m=m.flat(),M=M.flat(),y=y.concat(m).concat(M),e.push(R[0],R[2],R[3],R[0],R[1],R[2]),e.push(D[0],D[2],D[3],D[0],D[1],D[2])}const b=[n/2,o/2,c/2];a=y.reduce((m,M,R)=>m.concat(M*b[R%3]),[]);const I=r.sideOrientation===0?0:r.sideOrientation||k.DEFAULTSIDE,w=r.faceUV||new Array(6),v=r.faceColors,p=[];for(let m=0;m<6;m++)w[m]===void 0&&(w[m]=new Mt(0,0,1,1)),v&&v[m]===void 0&&(v[m]=new It(1,1,1,1));for(let m=0;m<6;m++)if(i.push(w[m].z,w[m].w),i.push(w[m].x,w[m].w),i.push(w[m].x,w[m].y),i.push(w[m].z,w[m].y),v)for(let M=0;M<4;M++)p.push(v[m].r,v[m].g,v[m].b,v[m].a);k._ComputeSides(I,a,e,s,i,r.frontUVs,r.backUVs);const x=new k;if(x.indices=e,x.positions=a,x.normals=s,x.uvs=i,v){const m=I===k.DOUBLESIDE?p.concat(p):p;x.colors=m}return x}function Ve(r,t={},e=null){const s=new O(r,e);return t.sideOrientation=O._GetDefaultSideOrientation(t.sideOrientation),s._originalBuilderSideOrientation=t.sideOrientation,Fe(t).applyToMesh(s,t.updatable),s}k.CreateBox=Fe;O.CreateBox=(r,t,e=null,s,i)=>Ve(r,{size:t,sideOrientation:i,updatable:s},e);function zt(r){const t=r.pattern||O.NO_FLIP,e=r.tileWidth||r.tileSize||1,s=r.tileHeight||r.tileSize||1,i=r.alignHorizontal||0,a=r.alignVertical||0,n=r.width||r.size||1,o=Math.floor(n/e);let c=n-o*e;const f=r.height||r.size||1,g=Math.floor(f/s);let h=f-g*s;const u=e*o/2,_=s*g/2;let d=0,A=0,y=0,b=0,I=0,w=0;if(c>0||h>0){switch(y=-u,b=-_,I=u,w=_,i){case O.CENTER:c/=2,y-=c,I+=c;break;case O.LEFT:I+=c,d=-c/2;break;case O.RIGHT:y-=c,d=c/2;break}switch(a){case O.CENTER:h/=2,b-=h,w+=h;break;case O.BOTTOM:w+=h,A=-h/2;break;case O.TOP:b-=h,A=h/2;break}}const v=[],p=[],x=[];x[0]=[0,0,1,0,1,1,0,1],x[1]=[0,0,1,0,1,1,0,1],(t===O.ROTATE_TILE||t===O.ROTATE_ROW)&&(x[1]=[1,1,0,1,0,0,1,0]),(t===O.FLIP_TILE||t===O.FLIP_ROW)&&(x[1]=[1,0,0,0,0,1,1,1]),(t===O.FLIP_N_ROTATE_TILE||t===O.FLIP_N_ROTATE_ROW)&&(x[1]=[0,1,1,1,1,0,0,0]);let m=[];const M=[],R=[];let D=0;for(let q=0;q<g;q++)for(let U=0;U<o;U++)v.push(-u+U*e+d,-_+q*s+A,0),v.push(-u+(U+1)*e+d,-_+q*s+A,0),v.push(-u+(U+1)*e+d,-_+(q+1)*s+A,0),v.push(-u+U*e+d,-_+(q+1)*s+A,0),R.push(D,D+1,D+3,D+1,D+2,D+3),t===O.FLIP_TILE||t===O.ROTATE_TILE||t===O.FLIP_N_ROTATE_TILE?m=m.concat(x[(U%2+q%2)%2]):t===O.FLIP_ROW||t===O.ROTATE_ROW||t===O.FLIP_N_ROTATE_ROW?m=m.concat(x[q%2]):m=m.concat(x[0]),M.push(1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1),p.push(0,0,-1,0,0,-1,0,0,-1,0,0,-1),D+=4;if(c>0||h>0){const q=h>0&&(a===O.CENTER||a===O.TOP),U=h>0&&(a===O.CENTER||a===O.BOTTOM),G=c>0&&(i===O.CENTER||i===O.RIGHT),z=c>0&&(i===O.CENTER||i===O.LEFT);let X=[],B,S,l,T;if(q&&G&&(v.push(y+d,b+A,0),v.push(-u+d,b+A,0),v.push(-u+d,b+h+A,0),v.push(y+d,b+h+A,0),R.push(D,D+1,D+3,D+1,D+2,D+3),D+=4,B=1-c/e,S=1-h/s,l=1,T=1,X=[B,S,l,S,l,T,B,T],t===O.ROTATE_ROW&&(X=[1-B,1-S,1-l,1-S,1-l,1-T,1-B,1-T]),t===O.FLIP_ROW&&(X=[1-B,S,1-l,S,1-l,T,1-B,T]),t===O.FLIP_N_ROTATE_ROW&&(X=[B,1-S,l,1-S,l,1-T,B,1-T]),m=m.concat(X),M.push(1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1),p.push(0,0,-1,0,0,-1,0,0,-1,0,0,-1)),q&&z&&(v.push(u+d,b+A,0),v.push(I+d,b+A,0),v.push(I+d,b+h+A,0),v.push(u+d,b+h+A,0),R.push(D,D+1,D+3,D+1,D+2,D+3),D+=4,B=0,S=1-h/s,l=c/e,T=1,X=[B,S,l,S,l,T,B,T],(t===O.ROTATE_ROW||t===O.ROTATE_TILE&&o%2===0)&&(X=[1-B,1-S,1-l,1-S,1-l,1-T,1-B,1-T]),(t===O.FLIP_ROW||t===O.FLIP_TILE&&o%2===0)&&(X=[1-B,S,1-l,S,1-l,T,1-B,T]),(t===O.FLIP_N_ROTATE_ROW||t===O.FLIP_N_ROTATE_TILE&&o%2===0)&&(X=[B,1-S,l,1-S,l,1-T,B,1-T]),m=m.concat(X),M.push(1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1),p.push(0,0,-1,0,0,-1,0,0,-1,0,0,-1)),U&&G&&(v.push(y+d,_+A,0),v.push(-u+d,_+A,0),v.push(-u+d,w+A,0),v.push(y+d,w+A,0),R.push(D,D+1,D+3,D+1,D+2,D+3),D+=4,B=1-c/e,S=0,l=1,T=h/s,X=[B,S,l,S,l,T,B,T],(t===O.ROTATE_ROW&&g%2===1||t===O.ROTATE_TILE&&g%1===0)&&(X=[1-B,1-S,1-l,1-S,1-l,1-T,1-B,1-T]),(t===O.FLIP_ROW&&g%2===1||t===O.FLIP_TILE&&g%2===0)&&(X=[1-B,S,1-l,S,1-l,T,1-B,T]),(t===O.FLIP_N_ROTATE_ROW&&g%2===1||t===O.FLIP_N_ROTATE_TILE&&g%2===0)&&(X=[B,1-S,l,1-S,l,1-T,B,1-T]),m=m.concat(X),M.push(1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1),p.push(0,0,-1,0,0,-1,0,0,-1,0,0,-1)),U&&z&&(v.push(u+d,_+A,0),v.push(I+d,_+A,0),v.push(I+d,w+A,0),v.push(u+d,w+A,0),R.push(D,D+1,D+3,D+1,D+2,D+3),D+=4,B=0,S=0,l=c/e,T=h/s,X=[B,S,l,S,l,T,B,T],(t===O.ROTATE_ROW&&g%2===1||t===O.ROTATE_TILE&&(g+o)%2===1)&&(X=[1-B,1-S,1-l,1-S,1-l,1-T,1-B,1-T]),(t===O.FLIP_ROW&&g%2===1||t===O.FLIP_TILE&&(g+o)%2===1)&&(X=[1-B,S,1-l,S,1-l,T,1-B,T]),(t===O.FLIP_N_ROTATE_ROW&&g%2===1||t===O.FLIP_N_ROTATE_TILE&&(g+o)%2===1)&&(X=[B,1-S,l,1-S,l,1-T,B,1-T]),m=m.concat(X),M.push(1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1),p.push(0,0,-1,0,0,-1,0,0,-1,0,0,-1)),q){const C=[];B=0,S=1-h/s,l=1,T=1,C[0]=[B,S,l,S,l,T,B,T],C[1]=[B,S,l,S,l,T,B,T],(t===O.ROTATE_TILE||t===O.ROTATE_ROW)&&(C[1]=[1-B,1-S,1-l,1-S,1-l,1-T,1-B,1-T]),(t===O.FLIP_TILE||t===O.FLIP_ROW)&&(C[1]=[1-B,S,1-l,S,1-l,T,1-B,T]),(t===O.FLIP_N_ROTATE_TILE||t===O.FLIP_N_ROTATE_ROW)&&(C[1]=[B,1-S,l,1-S,l,1-T,B,1-T]);for(let E=0;E<o;E++)v.push(-u+E*e+d,b+A,0),v.push(-u+(E+1)*e+d,b+A,0),v.push(-u+(E+1)*e+d,b+h+A,0),v.push(-u+E*e+d,b+h+A,0),R.push(D,D+1,D+3,D+1,D+2,D+3),D+=4,t===O.FLIP_TILE||t===O.ROTATE_TILE||t===O.FLIP_N_ROTATE_TILE?m=m.concat(C[(E+1)%2]):t===O.FLIP_ROW||t===O.ROTATE_ROW||t===O.FLIP_N_ROTATE_ROW?m=m.concat(C[1]):m=m.concat(C[0]),M.push(1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1),p.push(0,0,-1,0,0,-1,0,0,-1,0,0,-1)}if(U){const C=[];B=0,S=0,l=1,T=h/s,C[0]=[B,S,l,S,l,T,B,T],C[1]=[B,S,l,S,l,T,B,T],(t===O.ROTATE_TILE||t===O.ROTATE_ROW)&&(C[1]=[1-B,1-S,1-l,1-S,1-l,1-T,1-B,1-T]),(t===O.FLIP_TILE||t===O.FLIP_ROW)&&(C[1]=[1-B,S,1-l,S,1-l,T,1-B,T]),(t===O.FLIP_N_ROTATE_TILE||t===O.FLIP_N_ROTATE_ROW)&&(C[1]=[B,1-S,l,1-S,l,1-T,B,1-T]);for(let E=0;E<o;E++)v.push(-u+E*e+d,w-h+A,0),v.push(-u+(E+1)*e+d,w-h+A,0),v.push(-u+(E+1)*e+d,w+A,0),v.push(-u+E*e+d,w+A,0),R.push(D,D+1,D+3,D+1,D+2,D+3),D+=4,t===O.FLIP_TILE||t===O.ROTATE_TILE||t===O.FLIP_N_ROTATE_TILE?m=m.concat(C[(E+g)%2]):t===O.FLIP_ROW||t===O.ROTATE_ROW||t===O.FLIP_N_ROTATE_ROW?m=m.concat(C[g%2]):m=m.concat(C[0]),M.push(1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1),p.push(0,0,-1,0,0,-1,0,0,-1,0,0,-1)}if(G){const C=[];B=1-c/e,S=0,l=1,T=1,C[0]=[B,S,l,S,l,T,B,T],C[1]=[B,S,l,S,l,T,B,T],(t===O.ROTATE_TILE||t===O.ROTATE_ROW)&&(C[1]=[1-B,1-S,1-l,1-S,1-l,1-T,1-B,1-T]),(t===O.FLIP_TILE||t===O.FLIP_ROW)&&(C[1]=[1-B,S,1-l,S,1-l,T,1-B,T]),(t===O.FLIP_N_ROTATE_TILE||t===O.FLIP_N_ROTATE_ROW)&&(C[1]=[B,1-S,l,1-S,l,1-T,B,1-T]);for(let E=0;E<g;E++)v.push(y+d,-_+E*s+A,0),v.push(y+c+d,-_+E*s+A,0),v.push(y+c+d,-_+(E+1)*s+A,0),v.push(y+d,-_+(E+1)*s+A,0),R.push(D,D+1,D+3,D+1,D+2,D+3),D+=4,t===O.FLIP_TILE||t===O.ROTATE_TILE||t===O.FLIP_N_ROTATE_TILE?m=m.concat(C[(E+1)%2]):t===O.FLIP_ROW||t===O.ROTATE_ROW||t===O.FLIP_N_ROTATE_ROW?m=m.concat(C[E%2]):m=m.concat(C[0]),M.push(1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1),p.push(0,0,-1,0,0,-1,0,0,-1,0,0,-1)}if(z){const C=[];B=0,S=0,l=c/s,T=1,C[0]=[B,S,l,S,l,T,B,T],C[1]=[B,S,l,S,l,T,B,T],(t===O.ROTATE_TILE||t===O.ROTATE_ROW)&&(C[1]=[1-B,1-S,1-l,1-S,1-l,1-T,1-B,1-T]),(t===O.FLIP_TILE||t===O.FLIP_ROW)&&(C[1]=[1-B,S,1-l,S,1-l,T,1-B,T]),(t===O.FLIP_N_ROTATE_TILE||t===O.FLIP_N_ROTATE_ROW)&&(C[1]=[B,1-S,l,1-S,l,1-T,B,1-T]);for(let E=0;E<g;E++)v.push(I-c+d,-_+E*s+A,0),v.push(I+d,-_+E*s+A,0),v.push(I+d,-_+(E+1)*s+A,0),v.push(I-c+d,-_+(E+1)*s+A,0),R.push(D,D+1,D+3,D+1,D+2,D+3),D+=4,t===O.FLIP_TILE||t===O.ROTATE_TILE||t===O.FLIP_N_ROTATE_TILE?m=m.concat(C[(E+o)%2]):t===O.FLIP_ROW||t===O.ROTATE_ROW||t===O.FLIP_N_ROTATE_ROW?m=m.concat(C[E%2]):m=m.concat(C[0]),M.push(1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1),p.push(0,0,-1,0,0,-1,0,0,-1,0,0,-1)}}const L=r.sideOrientation===0?0:r.sideOrientation||k.DEFAULTSIDE;k._ComputeSides(L,v,R,p,m,r.frontUVs,r.backUVs);const V=new k;V.indices=R,V.positions=v,V.normals=p,V.uvs=m;const N=L===k.DOUBLESIDE?M.concat(M):M;return V.colors=N,V}function Ys(r,t,e=null){const s=new O(r,e);return t.sideOrientation=O._GetDefaultSideOrientation(t.sideOrientation),s._originalBuilderSideOrientation=t.sideOrientation,zt(t).applyToMesh(s,t.updatable),s}k.CreateTiledPlane=zt;function Ne(r){const e=r.faceUV||new Array(6),s=r.faceColors,i=r.pattern||O.NO_FLIP,a=r.width||r.size||1,n=r.height||r.size||1,o=r.depth||r.size||1,c=r.tileWidth||r.tileSize||1,f=r.tileHeight||r.tileSize||1,g=r.alignHorizontal||0,h=r.alignVertical||0,u=r.sideOrientation===0?0:r.sideOrientation||k.DEFAULTSIDE;for(let l=0;l<6;l++)e[l]===void 0&&(e[l]=new Mt(0,0,1,1)),s&&s[l]===void 0&&(s[l]=new It(1,1,1,1));const _=a/2,d=n/2,A=o/2,y=[];for(let l=0;l<2;l++)y[l]=zt({pattern:i,tileWidth:c,tileHeight:f,width:a,height:n,alignVertical:h,alignHorizontal:g,sideOrientation:u});for(let l=2;l<4;l++)y[l]=zt({pattern:i,tileWidth:c,tileHeight:f,width:o,height:n,alignVertical:h,alignHorizontal:g,sideOrientation:u});let b=h;h===O.BOTTOM?b=O.TOP:h===O.TOP&&(b=O.BOTTOM);for(let l=4;l<6;l++)y[l]=zt({pattern:i,tileWidth:c,tileHeight:f,width:a,height:o,alignVertical:b,alignHorizontal:g,sideOrientation:u});let I=[],w=[],v=[],p=[];const x=[],m=[],M=[],R=[];let D=0,L=0;for(let l=0;l<6;l++){const T=y[l].positions.length;m[l]=[],M[l]=[];for(let C=0;C<T/3;C++)m[l].push(new P(y[l].positions[3*C],y[l].positions[3*C+1],y[l].positions[3*C+2])),M[l].push(new P(y[l].normals[3*C],y[l].normals[3*C+1],y[l].normals[3*C+2]));D=y[l].uvs.length,R[l]=[];for(let C=0;C<D;C+=2)R[l][C]=e[l].x+(e[l].z-e[l].x)*y[l].uvs[C],R[l][C+1]=e[l].y+(e[l].w-e[l].y)*y[l].uvs[C+1];if(v=v.concat(R[l]),p=p.concat(y[l].indices.map(C=>C+L)),L+=m[l].length,s)for(let C=0;C<4;C++)x.push(s[l].r,s[l].g,s[l].b,s[l].a)}const V=new P(0,0,A),N=at.RotationY(Math.PI);I=m[0].map(l=>P.TransformNormal(l,N).add(V)).map(l=>[l.x,l.y,l.z]).reduce((l,T)=>l.concat(T),[]),w=M[0].map(l=>P.TransformNormal(l,N)).map(l=>[l.x,l.y,l.z]).reduce((l,T)=>l.concat(T),[]),I=I.concat(m[1].map(l=>l.subtract(V)).map(l=>[l.x,l.y,l.z]).reduce((l,T)=>l.concat(T),[])),w=w.concat(M[1].map(l=>[l.x,l.y,l.z]).reduce((l,T)=>l.concat(T),[]));const q=new P(_,0,0),U=at.RotationY(-Math.PI/2);I=I.concat(m[2].map(l=>P.TransformNormal(l,U).add(q)).map(l=>[l.x,l.y,l.z]).reduce((l,T)=>l.concat(T),[])),w=w.concat(M[2].map(l=>P.TransformNormal(l,U)).map(l=>[l.x,l.y,l.z]).reduce((l,T)=>l.concat(T),[]));const G=at.RotationY(Math.PI/2);I=I.concat(m[3].map(l=>P.TransformNormal(l,G).subtract(q)).map(l=>[l.x,l.y,l.z]).reduce((l,T)=>l.concat(T),[])),w=w.concat(M[3].map(l=>P.TransformNormal(l,G)).map(l=>[l.x,l.y,l.z]).reduce((l,T)=>l.concat(T),[]));const z=new P(0,d,0),X=at.RotationX(Math.PI/2);I=I.concat(m[4].map(l=>P.TransformNormal(l,X).add(z)).map(l=>[l.x,l.y,l.z]).reduce((l,T)=>l.concat(T),[])),w=w.concat(M[4].map(l=>P.TransformNormal(l,X)).map(l=>[l.x,l.y,l.z]).reduce((l,T)=>l.concat(T),[]));const B=at.RotationX(-Math.PI/2);I=I.concat(m[5].map(l=>P.TransformNormal(l,B).subtract(z)).map(l=>[l.x,l.y,l.z]).reduce((l,T)=>l.concat(T),[])),w=w.concat(M[5].map(l=>P.TransformNormal(l,B)).map(l=>[l.x,l.y,l.z]).reduce((l,T)=>l.concat(T),[])),k._ComputeSides(u,I,p,w,v);const S=new k;if(S.indices=p,S.positions=I,S.normals=w,S.uvs=v,s){const l=u===k.DOUBLESIDE?x.concat(x):x;S.colors=l}return S}function Zs(r,t,e=null){const s=new O(r,e);return t.sideOrientation=O._GetDefaultSideOrientation(t.sideOrientation),s._originalBuilderSideOrientation=t.sideOrientation,Ne(t).applyToMesh(s,t.updatable),s}k.CreateTiledBox=Ne;function ze(r){const t=(r.segments||32)|0,e=r.diameterX||r.diameter||1,s=r.diameterY||r.diameter||1,i=r.diameterZ||r.diameter||1,a=r.arc&&(r.arc<=0||r.arc>1)?1:r.arc||1,n=r.slice&&r.slice<=0?1:r.slice||1,o=r.sideOrientation===0?0:r.sideOrientation||k.DEFAULTSIDE,c=!!r.dedupTopBottomIndices,f=new P(e/2,s/2,i/2),g=2+t,h=2*g,u=[],_=[],d=[],A=[];for(let b=0;b<=g;b++){const I=b/g,w=I*Math.PI*n;for(let v=0;v<=h;v++){const p=v/h,x=p*Math.PI*2*a,m=at.RotationZ(-w),M=at.RotationY(x),R=P.TransformCoordinates(P.Up(),m),D=P.TransformCoordinates(R,M),L=D.multiply(f),V=D.divide(f).normalize();_.push(L.x,L.y,L.z),d.push(V.x,V.y,V.z),A.push(p,I)}if(b>0){const v=_.length/3;for(let p=v-2*(h+1);p+h+2<v;p++)c?(b>1&&(u.push(p),u.push(p+1),u.push(p+h+1)),(b<g||n<1)&&(u.push(p+h+1),u.push(p+1),u.push(p+h+2))):(u.push(p),u.push(p+1),u.push(p+h+1),u.push(p+h+1),u.push(p+1),u.push(p+h+2))}}k._ComputeSides(o,_,u,d,A,r.frontUVs,r.backUVs);const y=new k;return y.indices=u,y.positions=_,y.normals=d,y.uvs=A,y}function ke(r,t={},e=null){const s=new O(r,e);return t.sideOrientation=O._GetDefaultSideOrientation(t.sideOrientation),s._originalBuilderSideOrientation=t.sideOrientation,ze(t).applyToMesh(s,t.updatable),s}k.CreateSphere=ze;O.CreateSphere=(r,t,e,s,i,a)=>ke(r,{segments:t,diameterX:e,diameterY:e,diameterZ:e,sideOrientation:a,updatable:i},s);function Ue(r){const t=r.height||2;let e=r.diameterTop===0?0:r.diameterTop||r.diameter||1,s=r.diameterBottom===0?0:r.diameterBottom||r.diameter||1;e=e||1e-5,s=s||1e-5;const i=(r.tessellation||24)|0,a=(r.subdivisions||1)|0,n=!!r.hasRings,o=!!r.enclose,c=r.cap===0?0:r.cap||O.CAP_ALL,f=r.arc&&(r.arc<=0||r.arc>1)?1:r.arc||1,g=r.sideOrientation===0?0:r.sideOrientation||k.DEFAULTSIDE,h=r.faceUV||new Array(3),u=r.faceColors,_=f!==1&&o?2:0,d=n?a:1,A=2+(1+_)*d;let y;for(y=0;y<A;y++)u&&u[y]===void 0&&(u[y]=new It(1,1,1,1));for(y=0;y<A;y++)h&&h[y]===void 0&&(h[y]=new Mt(0,0,1,1));const b=[],I=[],w=[],v=[],p=[],x=Math.PI*2*f/i;let m,M,R;const D=(s-e)/2/t,L=P.Zero(),V=P.Zero(),N=P.Zero(),q=P.Zero(),U=P.Zero(),G=Os.Y;let z,X,B,S=1,l=1,T=0,C=0;for(z=0;z<=a;z++)for(M=z/a,R=(M*(e-s)+s)/2,S=n&&z!==0&&z!==a?2:1,B=0;B<S;B++){for(n&&(l+=B),o&&(l+=2*B),X=0;X<=i;X++)m=X*x,L.x=Math.cos(-m)*R,L.y=-t/2+M*t,L.z=Math.sin(-m)*R,e===0&&z===a?(V.x=w[w.length-(i+1)*3],V.y=w[w.length-(i+1)*3+1],V.z=w[w.length-(i+1)*3+2]):(V.x=L.x,V.z=L.z,V.y=Math.sqrt(V.x*V.x+V.z*V.z)*D,V.normalize()),X===0&&(N.copyFrom(L),q.copyFrom(V)),I.push(L.x,L.y,L.z),w.push(V.x,V.y,V.z),n?C=T!==l?h[l].y:h[l].w:C=h[l].y+(h[l].w-h[l].y)*M,v.push(h[l].x+(h[l].z-h[l].x)*X/i,C),u&&p.push(u[l].r,u[l].g,u[l].b,u[l].a);f!==1&&o&&(I.push(L.x,L.y,L.z),I.push(0,L.y,0),I.push(0,L.y,0),I.push(N.x,N.y,N.z),P.CrossToRef(G,V,U),U.normalize(),w.push(U.x,U.y,U.z,U.x,U.y,U.z),P.CrossToRef(q,G,U),U.normalize(),w.push(U.x,U.y,U.z,U.x,U.y,U.z),n?C=T!==l?h[l+1].y:h[l+1].w:C=h[l+1].y+(h[l+1].w-h[l+1].y)*M,v.push(h[l+1].x,C),v.push(h[l+1].z,C),n?C=T!==l?h[l+2].y:h[l+2].w:C=h[l+2].y+(h[l+2].w-h[l+2].y)*M,v.push(h[l+2].x,C),v.push(h[l+2].z,C),u&&(p.push(u[l+1].r,u[l+1].g,u[l+1].b,u[l+1].a),p.push(u[l+1].r,u[l+1].g,u[l+1].b,u[l+1].a),p.push(u[l+2].r,u[l+2].g,u[l+2].b,u[l+2].a),p.push(u[l+2].r,u[l+2].g,u[l+2].b,u[l+2].a))),T!==l&&(T=l)}const E=f!==1&&o?i+4:i;for(z=0,l=0;l<a;l++){let H=0,$=0,ot=0,it=0;for(X=0;X<i;X++)H=z*(E+1)+X,$=(z+1)*(E+1)+X,ot=z*(E+1)+(X+1),it=(z+1)*(E+1)+(X+1),b.push(H,$,ot),b.push(it,ot,$);f!==1&&o&&(b.push(H+2,$+2,ot+2),b.push(it+2,ot+2,$+2),b.push(H+4,$+4,ot+4),b.push(it+4,ot+4,$+4)),z=n?z+2:z+1}const Y=H=>{const $=H?e/2:s/2;if($===0)return;let ot,it,ht;const W=H?h[A-1]:h[0];let J=null;u&&(J=H?u[A-1]:u[0]);const Z=I.length/3,ct=H?t/2:-t/2,xt=new P(0,ct,0);I.push(xt.x,xt.y,xt.z),w.push(0,H?1:-1,0);const mt=W.y+(W.w-W.y)*.5;v.push(W.x+(W.z-W.x)*.5,mt),J&&p.push(J.r,J.g,J.b,J.a);const At=new rt(.5,.5);for(ht=0;ht<=i;ht++){ot=Math.PI*2*ht*f/i;const St=Math.cos(-ot),Ot=Math.sin(-ot);it=new P(St*$,ct,Ot*$);const Bt=new rt(St*At.x+.5,Ot*At.y+.5);I.push(it.x,it.y,it.z),w.push(0,H?1:-1,0);const Et=W.y+(W.w-W.y)*Bt.y;v.push(W.x+(W.z-W.x)*Bt.x,Et),J&&p.push(J.r,J.g,J.b,J.a)}for(ht=0;ht<i;ht++)H?(b.push(Z),b.push(Z+(ht+2)),b.push(Z+(ht+1))):(b.push(Z),b.push(Z+(ht+1)),b.push(Z+(ht+2)))};(c===O.CAP_START||c===O.CAP_ALL)&&Y(!1),(c===O.CAP_END||c===O.CAP_ALL)&&Y(!0),k._ComputeSides(g,I,b,w,v,r.frontUVs,r.backUVs);const F=new k;return F.indices=b,F.positions=I,F.normals=w,F.uvs=v,u&&(F.colors=p),F}function We(r,t={},e){const s=new O(r,e);return t.sideOrientation=O._GetDefaultSideOrientation(t.sideOrientation),s._originalBuilderSideOrientation=t.sideOrientation,Ue(t).applyToMesh(s,t.updatable),s}k.CreateCylinder=Ue;O.CreateCylinder=(r,t,e,s,i,a,n,o,c)=>((n===void 0||!(n instanceof Te))&&(n!==void 0&&(c=o||O.DEFAULTSIDE,o=n),n=a,a=1),We(r,{height:t,diameterTop:e,diameterBottom:s,tessellation:i,subdivisions:a,sideOrientation:c,updatable:o},n));function Xe(r){const t=[],e=[],s=[],i=[],a=r.diameter||1,n=r.thickness||.5,o=(r.tessellation||16)|0,c=r.sideOrientation===0?0:r.sideOrientation||k.DEFAULTSIDE,f=o+1;for(let h=0;h<=o;h++){const u=h/o,_=h*Math.PI*2/o-Math.PI/2,d=at.Translation(a/2,0,0).multiply(at.RotationY(_));for(let A=0;A<=o;A++){const y=1-A/o,b=A*Math.PI*2/o+Math.PI,I=Math.cos(b),w=Math.sin(b);let v=new P(I,w,0),p=v.scale(n/2);const x=new rt(u,y);p=P.TransformCoordinates(p,d),v=P.TransformNormal(v,d),e.push(p.x,p.y,p.z),s.push(v.x,v.y,v.z),i.push(x.x,x.y);const m=(h+1)%f,M=(A+1)%f;t.push(h*f+A),t.push(h*f+M),t.push(m*f+A),t.push(h*f+M),t.push(m*f+M),t.push(m*f+A)}}k._ComputeSides(c,e,t,s,i,r.frontUVs,r.backUVs);const g=new k;return g.indices=t,g.positions=e,g.normals=s,g.uvs=i,g}function Ye(r,t={},e){const s=new O(r,e);return t.sideOrientation=O._GetDefaultSideOrientation(t.sideOrientation),s._originalBuilderSideOrientation=t.sideOrientation,Xe(t).applyToMesh(s,t.updatable),s}k.CreateTorus=Xe;O.CreateTorus=(r,t,e,s,i,a,n)=>Ye(r,{diameter:t,thickness:e,tessellation:s,sideOrientation:n,updatable:a},i);function Ze(r){const t=[],e=[],s=[],i=[],a=r.radius||2,n=r.tube||.5,o=r.radialSegments||32,c=r.tubularSegments||32,f=r.p||2,g=r.q||3,h=r.sideOrientation===0?0:r.sideOrientation||k.DEFAULTSIDE,u=y=>{const b=Math.cos(y),I=Math.sin(y),w=g/f*y,v=Math.cos(w),p=a*(2+v)*.5*b,x=a*(2+v)*I*.5,m=a*Math.sin(w)*.5;return new P(p,x,m)};let _,d;for(_=0;_<=o;_++){const b=_%o/o*2*f*Math.PI,I=u(b),w=u(b+.01),v=w.subtract(I);let p=w.add(I);const x=P.Cross(v,p);for(p=P.Cross(x,v),x.normalize(),p.normalize(),d=0;d<c;d++){const M=d%c/c*2*Math.PI,R=-n*Math.cos(M),D=n*Math.sin(M);e.push(I.x+R*p.x+D*x.x),e.push(I.y+R*p.y+D*x.y),e.push(I.z+R*p.z+D*x.z),i.push(_/o),i.push(d/c)}}for(_=0;_<o;_++)for(d=0;d<c;d++){const y=(d+1)%c,b=_*c+d,I=(_+1)*c+d,w=(_+1)*c+y,v=_*c+y;t.push(v),t.push(I),t.push(b),t.push(v),t.push(w),t.push(I)}k.ComputeNormals(e,t,s),k._ComputeSides(h,e,t,s,i,r.frontUVs,r.backUVs);const A=new k;return A.indices=t,A.positions=e,A.normals=s,A.uvs=i,A}function He(r,t={},e){const s=new O(r,e);return t.sideOrientation=O._GetDefaultSideOrientation(t.sideOrientation),s._originalBuilderSideOrientation=t.sideOrientation,Ze(t).applyToMesh(s,t.updatable),s}k.CreateTorusKnot=Ze;O.CreateTorusKnot=(r,t,e,s,i,a,n,o,c,f)=>He(r,{radius:t,tube:e,radialSegments:s,tubularSegments:i,p:a,q:n,sideOrientation:f,updatable:c},o);const se={effect:null,subMesh:null};class Ct extends Ts{constructor(t,e,s,i={},a=!0){super(t,e,a),this._textures={},this._textureArrays={},this._externalTextures={},this._floats={},this._ints={},this._uints={},this._floatsArrays={},this._colors3={},this._colors3Arrays={},this._colors4={},this._colors4Arrays={},this._vectors2={},this._vectors3={},this._vectors4={},this._quaternions={},this._quaternionsArrays={},this._matrices={},this._matrixArrays={},this._matrices3x3={},this._matrices2x2={},this._vectors2Arrays={},this._vectors3Arrays={},this._vectors4Arrays={},this._uniformBuffers={},this._textureSamplers={},this._storageBuffers={},this._cachedWorldViewMatrix=new at,this._cachedWorldViewProjectionMatrix=new at,this._multiview=!1,this._materialHelperNeedsPreviousMatrices=!1,this._shaderPath=s,this._options={needAlphaBlending:!1,needAlphaTesting:!1,attributes:["position","normal","uv"],uniforms:["worldViewProjection"],uniformBuffers:[],samplers:[],externalTextures:[],samplerObjects:[],storageBuffers:[],defines:[],useClipPlane:!1,...i}}get shaderPath(){return this._shaderPath}set shaderPath(t){this._shaderPath=t}get options(){return this._options}get isMultiview(){return this._multiview}getClassName(){return"ShaderMaterial"}needAlphaBlending(){return this.alpha<1||this._options.needAlphaBlending}needAlphaTesting(){return this._options.needAlphaTesting}_checkUniform(t){this._options.uniforms.indexOf(t)===-1&&this._options.uniforms.push(t)}setTexture(t,e){return this._options.samplers.indexOf(t)===-1&&this._options.samplers.push(t),this._textures[t]=e,this}removeTexture(t){delete this._textures[t]}setTextureArray(t,e){return this._options.samplers.indexOf(t)===-1&&this._options.samplers.push(t),this._checkUniform(t),this._textureArrays[t]=e,this}setExternalTexture(t,e){return this._options.externalTextures.indexOf(t)===-1&&this._options.externalTextures.push(t),this._externalTextures[t]=e,this}setFloat(t,e){return this._checkUniform(t),this._floats[t]=e,this}setInt(t,e){return this._checkUniform(t),this._ints[t]=e,this}setUInt(t,e){return this._checkUniform(t),this._uints[t]=e,this}setFloats(t,e){return this._checkUniform(t),this._floatsArrays[t]=e,this}setColor3(t,e){return this._checkUniform(t),this._colors3[t]=e,this}setColor3Array(t,e){return this._checkUniform(t),this._colors3Arrays[t]=e.reduce((s,i)=>(s.push(i.r,i.g,i.b),s),[]),this}setColor4(t,e){return this._checkUniform(t),this._colors4[t]=e,this}setColor4Array(t,e){return this._checkUniform(t),this._colors4Arrays[t]=e.reduce((s,i)=>(s.push(i.r,i.g,i.b,i.a),s),[]),this}setVector2(t,e){return this._checkUniform(t),this._vectors2[t]=e,this}setVector3(t,e){return this._checkUniform(t),this._vectors3[t]=e,this}setVector4(t,e){return this._checkUniform(t),this._vectors4[t]=e,this}setQuaternion(t,e){return this._checkUniform(t),this._quaternions[t]=e,this}setQuaternionArray(t,e){return this._checkUniform(t),this._quaternionsArrays[t]=e.reduce((s,i)=>(i.toArray(s,s.length),s),[]),this}setMatrix(t,e){return this._checkUniform(t),this._matrices[t]=e,this}setMatrices(t,e){this._checkUniform(t);const s=new Float32Array(e.length*16);for(let i=0;i<e.length;i++)e[i].copyToArray(s,i*16);return this._matrixArrays[t]=s,this}setMatrix3x3(t,e){return this._checkUniform(t),this._matrices3x3[t]=e,this}setMatrix2x2(t,e){return this._checkUniform(t),this._matrices2x2[t]=e,this}setArray2(t,e){return this._checkUniform(t),this._vectors2Arrays[t]=e,this}setArray3(t,e){return this._checkUniform(t),this._vectors3Arrays[t]=e,this}setArray4(t,e){return this._checkUniform(t),this._vectors4Arrays[t]=e,this}setUniformBuffer(t,e){return this._options.uniformBuffers.indexOf(t)===-1&&this._options.uniformBuffers.push(t),this._uniformBuffers[t]=e,this}setTextureSampler(t,e){return this._options.samplerObjects.indexOf(t)===-1&&this._options.samplerObjects.push(t),this._textureSamplers[t]=e,this}setStorageBuffer(t,e){return this._options.storageBuffers.indexOf(t)===-1&&this._options.storageBuffers.push(t),this._storageBuffers[t]=e,this}setDefine(t,e){const s=t.trimEnd()+" ",i=this.options.defines.findIndex(a=>a===t||a.startsWith(s));return i>=0&&this.options.defines.splice(i,1),(typeof e!="boolean"||e)&&this.options.defines.push(s+e),this}isReadyForSubMesh(t,e,s){return this.isReady(t,s,e)}isReady(t,e,s){const i=s&&this._storeEffectOnSubMeshes;if(this.isFrozen){const x=i?s._drawWrapper:this._drawWrapper;if(x.effect&&x._wasPreviouslyReady&&x._wasPreviouslyUsingInstances===e)return!0}const a=this.getScene(),n=a.getEngine(),o=[],c=[];let f=null,g=this._shaderPath,h=this._options.uniforms,u=this._options.uniformBuffers,_=this._options.samplers;n.getCaps().multiview&&a.activeCamera&&a.activeCamera.outputRenderTarget&&a.activeCamera.outputRenderTarget.getViewCount()>1&&(this._multiview=!0,o.push("#define MULTIVIEW"),h.indexOf("viewProjection")!==-1&&h.indexOf("viewProjectionR")===-1&&h.push("viewProjectionR"));for(let x=0;x<this._options.defines.length;x++){const m=this._options.defines[x].indexOf("#define")===0?this._options.defines[x]:`#define ${this._options.defines[x]}`;o.push(m)}for(let x=0;x<this._options.attributes.length;x++)c.push(this._options.attributes[x]);if(t&&t.isVerticesDataPresent(Q.ColorKind)&&(c.indexOf(Q.ColorKind)===-1&&c.push(Q.ColorKind),o.push("#define VERTEXCOLOR")),e&&(o.push("#define INSTANCES"),Cs(c,this._materialHelperNeedsPreviousMatrices),t?.hasThinInstances&&(o.push("#define THIN_INSTANCES"),t&&t.isVerticesDataPresent(Q.ColorInstanceKind)&&(c.push(Q.ColorInstanceKind),o.push("#define INSTANCESCOLOR")))),t&&t.useBones&&t.computeBonesUsingShaders&&t.skeleton){c.push(Q.MatricesIndicesKind),c.push(Q.MatricesWeightsKind),t.numBoneInfluencers>4&&(c.push(Q.MatricesIndicesExtraKind),c.push(Q.MatricesWeightsExtraKind));const x=t.skeleton;o.push("#define NUM_BONE_INFLUENCERS "+t.numBoneInfluencers),f=new Fs,f.addCPUSkinningFallback(0,t),x.isUsingTextureForMatrices?(o.push("#define BONETEXTURE"),h.indexOf("boneTextureWidth")===-1&&h.push("boneTextureWidth"),this._options.samplers.indexOf("boneSampler")===-1&&this._options.samplers.push("boneSampler")):(o.push("#define BonesPerMesh "+(x.bones.length+1)),h.indexOf("mBones")===-1&&h.push("mBones"))}else o.push("#define NUM_BONE_INFLUENCERS 0");let d=0;const A=t?t.morphTargetManager:null;if(A){const x=o.indexOf("#define UV1")!==-1,m=o.indexOf("#define UV2")!==-1,M=o.indexOf("#define TANGENT")!==-1,R=o.indexOf("#define NORMAL")!==-1,D=o.indexOf("#define VERTEXCOLOR")!==-1;d=Is(A,o,c,t,!0,R,M,x,m,D),A.isUsingTextureForTargets&&(h.indexOf("morphTargetTextureIndices")===-1&&h.push("morphTargetTextureIndices"),this._options.samplers.indexOf("morphTargets")===-1&&this._options.samplers.push("morphTargets")),d>0&&(h=h.slice(),h.push("morphTargetInfluences"),h.push("morphTargetCount"),h.push("morphTargetTextureInfo"),h.push("morphTargetTextureIndices"))}else o.push("#define NUM_MORPH_INFLUENCERS 0");if(t){const x=t.bakedVertexAnimationManager;x&&x.isEnabled&&(o.push("#define BAKED_VERTEX_ANIMATION_TEXTURE"),h.indexOf("bakedVertexAnimationSettings")===-1&&h.push("bakedVertexAnimationSettings"),h.indexOf("bakedVertexAnimationTextureSizeInverted")===-1&&h.push("bakedVertexAnimationTextureSizeInverted"),h.indexOf("bakedVertexAnimationTime")===-1&&h.push("bakedVertexAnimationTime"),this._options.samplers.indexOf("bakedVertexAnimationTexture")===-1&&this._options.samplers.push("bakedVertexAnimationTexture")),ws(c,t,o)}for(const x in this._textures)if(!this._textures[x].isReady())return!1;t&&this.needAlphaTestingForMesh(t)&&o.push("#define ALPHATEST"),this._options.useClipPlane!==!1&&(Ps(h),Rs(this,a,o)),a.fogEnabled&&t?.applyFog&&a.fogMode!==Te.FOGMODE_NONE&&(o.push("#define FOG"),h.indexOf("view")===-1&&h.push("view"),h.indexOf("vFogInfos")===-1&&h.push("vFogInfos"),h.indexOf("vFogColor")===-1&&h.push("vFogColor")),this._useLogarithmicDepth&&(o.push("#define LOGARITHMICDEPTH"),h.indexOf("logarithmicDepthConstant")===-1&&h.push("logarithmicDepthConstant")),this.customShaderNameResolve&&(h=h.slice(),u=u.slice(),_=_.slice(),g=this.customShaderNameResolve(this.name,h,u,_,o,c));const y=s?s.getRenderingMesh():t;if(y&&this.useVertexPulling){o.push("#define USE_VERTEX_PULLING");const x=y.geometry?.getIndexBuffer();x&&(o.push("#define VERTEX_PULLING_USE_INDEX_BUFFER"),x.is32Bits&&o.push("#define VERTEX_PULLING_INDEX_BUFFER_32BITS"))}const b=i?s._getDrawWrapper(void 0,!0):this._drawWrapper,I=b?.effect??null,w=b?.defines??null,v=o.join(`
`);let p=I;return w!==v&&(p=n.createEffect(g,{attributes:c,uniformsNames:h,uniformBuffersNames:u,samplers:_,defines:v,fallbacks:f,onCompiled:this.onCompiled,onError:this.onError,indexParameters:{maxSimultaneousMorphTargets:d},shaderLanguage:this._options.shaderLanguage,extraInitializationsAsync:this._options.extraInitializationsAsync},n),i?s.setEffect(p,v,this._materialContext):b&&b.setEffect(p,v),this._onEffectCreatedObservable&&(se.effect=p,se.subMesh=s??t?.subMeshes[0]??null,this._onEffectCreatedObservable.notifyObservers(se))),b._wasPreviouslyUsingInstances=!!e,p?.isReady()?(I!==p&&a.resetCachedMaterial(),b._wasPreviouslyReady=!0,!0):!1}bindOnlyWorldMatrix(t,e){const s=e??this.getEffect();if(!s)return;const i=this._options.uniforms;i.indexOf("world")!==-1&&s.setMatrix("world",t);const a=this.getScene();i.indexOf("worldView")!==-1&&(t.multiplyToRef(a.getViewMatrix(),this._cachedWorldViewMatrix),s.setMatrix("worldView",this._cachedWorldViewMatrix)),i.indexOf("worldViewProjection")!==-1&&(t.multiplyToRef(a.getTransformMatrix(),this._cachedWorldViewProjectionMatrix),s.setMatrix("worldViewProjection",this._cachedWorldViewProjectionMatrix)),i.indexOf("view")!==-1&&s.setMatrix("view",a.getViewMatrix())}bindForSubMesh(t,e,s){this.bind(t,e,s._drawWrapperOverride?.effect,s)}bind(t,e,s,i){const a=i&&this._storeEffectOnSubMeshes,n=s??(a?i.effect:this.getEffect());if(!n)return;const o=this.getScene();this._activeEffect=n,this.bindOnlyWorldMatrix(t,s);const c=this._options.uniformBuffers;let f=!1;if(n&&c&&c.length>0&&o.getEngine().supportsUniformBuffers)for(let h=0;h<c.length;++h)switch(c[h]){case"Mesh":e&&(e.getMeshUniformBuffer().bindToEffect(n,"Mesh"),e.transferToEffect(t));break;case"Scene":Ms(n,o.getSceneUniformBuffer()),o.finalizeSceneUbo(),f=!0;break}const g=e&&a?this._mustRebind(o,n,i,e.visibility):o.getCachedMaterial()!==this;if(n&&g){!f&&this._options.uniforms.indexOf("view")!==-1&&n.setMatrix("view",o.getViewMatrix()),!f&&this._options.uniforms.indexOf("projection")!==-1&&n.setMatrix("projection",o.getProjectionMatrix()),!f&&this._options.uniforms.indexOf("viewProjection")!==-1&&(n.setMatrix("viewProjection",o.getTransformMatrix()),this._multiview&&n.setMatrix("viewProjectionR",o._transformMatrixR)),o.activeCamera&&this._options.uniforms.indexOf("cameraPosition")!==-1&&n.setVector3("cameraPosition",o.activeCamera.globalPosition),Ds(e,n),Ss(n,this,o),this._useLogarithmicDepth&&Bs(a?i.materialDefines:n.defines,n,o),e&&Es(o,e,n);let h;for(h in this._textures)n.setTexture(h,this._textures[h]);for(h in this._textureArrays)n.setTextureArray(h,this._textureArrays[h]);for(h in this._ints)n.setInt(h,this._ints[h]);for(h in this._uints)n.setUInt(h,this._uints[h]);for(h in this._floats)n.setFloat(h,this._floats[h]);for(h in this._floatsArrays)n.setArray(h,this._floatsArrays[h]);for(h in this._colors3)n.setColor3(h,this._colors3[h]);for(h in this._colors3Arrays)n.setArray3(h,this._colors3Arrays[h]);for(h in this._colors4){const y=this._colors4[h];n.setFloat4(h,y.r,y.g,y.b,y.a)}for(h in this._colors4Arrays)n.setArray4(h,this._colors4Arrays[h]);for(h in this._vectors2)n.setVector2(h,this._vectors2[h]);for(h in this._vectors3)n.setVector3(h,this._vectors3[h]);for(h in this._vectors4)n.setVector4(h,this._vectors4[h]);for(h in this._quaternions)n.setQuaternion(h,this._quaternions[h]);for(h in this._matrices)n.setMatrix(h,this._matrices[h]);for(h in this._matrixArrays)n.setMatrices(h,this._matrixArrays[h]);for(h in this._matrices3x3)n.setMatrix3x3(h,this._matrices3x3[h]);for(h in this._matrices2x2)n.setMatrix2x2(h,this._matrices2x2[h]);for(h in this._vectors2Arrays)n.setArray2(h,this._vectors2Arrays[h]);for(h in this._vectors3Arrays)n.setArray3(h,this._vectors3Arrays[h]);for(h in this._vectors4Arrays)n.setArray4(h,this._vectors4Arrays[h]);for(h in this._quaternionsArrays)n.setArray4(h,this._quaternionsArrays[h]);for(h in this._uniformBuffers){const y=this._uniformBuffers[h].getBuffer();y&&n.bindUniformBuffer(y,h)}const u=o.getEngine(),_=u.setExternalTexture;if(_)for(h in this._externalTextures)_.call(u,h,this._externalTextures[h]);const d=u.setTextureSampler;if(d)for(h in this._textureSamplers)d.call(u,h,this._textureSamplers[h]);const A=u.setStorageBuffer;if(A)for(h in this._storageBuffers)A.call(u,h,this._storageBuffers[h])}if(n&&e&&(g||!this.isFrozen)){Ls(e,n),e.morphTargetManager&&e.morphTargetManager.isUsingTextureForTargets&&e.morphTargetManager._bind(n);const h=e.bakedVertexAnimationManager;if(h&&h.isEnabled){const u=a?i._drawWrapper:this._drawWrapper;e.bakedVertexAnimationManager?.bind(n,!!u._wasPreviouslyUsingInstances)}}this._afterBind(e,n,i)}getActiveTextures(){const t=super.getActiveTextures();for(const e in this._textures)t.push(this._textures[e]);for(const e in this._textureArrays){const s=this._textureArrays[e];for(let i=0;i<s.length;i++)t.push(s[i])}return t}hasTexture(t){if(super.hasTexture(t))return!0;for(const e in this._textures)if(this._textures[e]===t)return!0;for(const e in this._textureArrays){const s=this._textureArrays[e];for(let i=0;i<s.length;i++)if(s[i]===t)return!0}return!1}clone(t){const e=te.Clone(()=>new Ct(t,this.getScene(),this._shaderPath,this._options,this._storeEffectOnSubMeshes),this);e.name=t,e.id=t,typeof e._shaderPath=="object"&&(e._shaderPath={...e._shaderPath}),this._options={...this._options};const s=Object.keys(this._options);for(const i of s){const a=this._options[i];Array.isArray(a)&&(this._options[i]=a.slice(0))}this.stencil.copyTo(e.stencil);for(const i in this._textures)e.setTexture(i,this._textures[i]);for(const i in this._textureArrays)e.setTextureArray(i,this._textureArrays[i]);for(const i in this._externalTextures)e.setExternalTexture(i,this._externalTextures[i]);for(const i in this._ints)e.setInt(i,this._ints[i]);for(const i in this._uints)e.setUInt(i,this._uints[i]);for(const i in this._floats)e.setFloat(i,this._floats[i]);for(const i in this._floatsArrays)e.setFloats(i,this._floatsArrays[i]);for(const i in this._colors3)e.setColor3(i,this._colors3[i]);for(const i in this._colors3Arrays)e._colors3Arrays[i]=this._colors3Arrays[i];for(const i in this._colors4)e.setColor4(i,this._colors4[i]);for(const i in this._colors4Arrays)e._colors4Arrays[i]=this._colors4Arrays[i];for(const i in this._vectors2)e.setVector2(i,this._vectors2[i]);for(const i in this._vectors3)e.setVector3(i,this._vectors3[i]);for(const i in this._vectors4)e.setVector4(i,this._vectors4[i]);for(const i in this._quaternions)e.setQuaternion(i,this._quaternions[i]);for(const i in this._quaternionsArrays)e._quaternionsArrays[i]=this._quaternionsArrays[i];for(const i in this._matrices)e.setMatrix(i,this._matrices[i]);for(const i in this._matrixArrays)e._matrixArrays[i]=this._matrixArrays[i].slice();for(const i in this._matrices3x3)e.setMatrix3x3(i,this._matrices3x3[i]);for(const i in this._matrices2x2)e.setMatrix2x2(i,this._matrices2x2[i]);for(const i in this._vectors2Arrays)e.setArray2(i,this._vectors2Arrays[i]);for(const i in this._vectors3Arrays)e.setArray3(i,this._vectors3Arrays[i]);for(const i in this._vectors4Arrays)e.setArray4(i,this._vectors4Arrays[i]);for(const i in this._uniformBuffers)e.setUniformBuffer(i,this._uniformBuffers[i]);for(const i in this._textureSamplers)e.setTextureSampler(i,this._textureSamplers[i]);for(const i in this._storageBuffers)e.setStorageBuffer(i,this._storageBuffers[i]);return e}dispose(t,e,s){if(e){let i;for(i in this._textures)this._textures[i].dispose();for(i in this._textureArrays){const a=this._textureArrays[i];for(let n=0;n<a.length;n++)a[n].dispose()}}this._textures={},super.dispose(t,e,s)}serialize(){const t=te.Serialize(this);t.customType="BABYLON.ShaderMaterial",t.uniqueId=this.uniqueId,t.options=this._options,t.shaderPath=this._shaderPath,t.storeEffectOnSubMeshes=this._storeEffectOnSubMeshes;let e;t.stencil=this.stencil.serialize(),t.textures={};for(e in this._textures)t.textures[e]=this._textures[e].serialize();t.textureArrays={};for(e in this._textureArrays){t.textureArrays[e]=[];const s=this._textureArrays[e];for(let i=0;i<s.length;i++)t.textureArrays[e].push(s[i].serialize())}t.ints={};for(e in this._ints)t.ints[e]=this._ints[e];t.uints={};for(e in this._uints)t.uints[e]=this._uints[e];t.floats={};for(e in this._floats)t.floats[e]=this._floats[e];t.floatsArrays={};for(e in this._floatsArrays)t.floatsArrays[e]=this._floatsArrays[e];t.colors3={};for(e in this._colors3){const s=this._colors3[e];t.colors3[e]=[s.r,s.g,s.b]}t.colors3Arrays={};for(e in this._colors3Arrays)t.colors3Arrays[e]=this._colors3Arrays[e];t.colors4={};for(e in this._colors4){const s=this._colors4[e];t.colors4[e]=[s.r,s.g,s.b,s.a]}t.colors4Arrays={};for(e in this._colors4Arrays)t.colors4Arrays[e]=this._colors4Arrays[e];t.vectors2={};for(e in this._vectors2){const s=this._vectors2[e];t.vectors2[e]=[s.x,s.y]}t.vectors3={};for(e in this._vectors3){const s=this._vectors3[e];t.vectors3[e]=[s.x,s.y,s.z]}t.vectors4={};for(e in this._vectors4){const s=this._vectors4[e];t.vectors4[e]=[s.x,s.y,s.z,s.w]}t.quaternions={};for(e in this._quaternions)t.quaternions[e]=this._quaternions[e].asArray();t.matrices={};for(e in this._matrices)t.matrices[e]=this._matrices[e].asArray();t.matrixArray={};for(e in this._matrixArrays)t.matrixArray[e]=this._matrixArrays[e];t.matrices3x3={};for(e in this._matrices3x3)t.matrices3x3[e]=this._matrices3x3[e];t.matrices2x2={};for(e in this._matrices2x2)t.matrices2x2[e]=this._matrices2x2[e];t.vectors2Arrays={};for(e in this._vectors2Arrays)t.vectors2Arrays[e]=this._vectors2Arrays[e];t.vectors3Arrays={};for(e in this._vectors3Arrays)t.vectors3Arrays[e]=this._vectors3Arrays[e];t.vectors4Arrays={};for(e in this._vectors4Arrays)t.vectors4Arrays[e]=this._vectors4Arrays[e];t.quaternionsArrays={};for(e in this._quaternionsArrays)t.quaternionsArrays[e]=this._quaternionsArrays[e];return t}static Parse(t,e,s){const i=te.Parse(()=>new Ct(t.name,e,t.shaderPath,t.options,t.storeEffectOnSubMeshes),t,e,s);let a;t.stencil&&i.stencil.parse(t.stencil,e,s);for(a in t.textures)i.setTexture(a,me.Parse(t.textures[a],e,s));for(a in t.textureArrays){const n=t.textureArrays[a],o=[];for(let c=0;c<n.length;c++)o.push(me.Parse(n[c],e,s));i.setTextureArray(a,o)}for(a in t.ints)i.setInt(a,t.ints[a]);for(a in t.uints)i.setUInt(a,t.uints[a]);for(a in t.floats)i.setFloat(a,t.floats[a]);for(a in t.floatsArrays)i.setFloats(a,t.floatsArrays[a]);for(a in t.colors3){const n=t.colors3[a];i.setColor3(a,{r:n[0],g:n[1],b:n[2]})}for(a in t.colors3Arrays){const n=t.colors3Arrays[a].reduce((o,c,f)=>(f%3===0?o.push([c]):o[o.length-1].push(c),o),[]).map(o=>({r:o[0],g:o[1],b:o[2]}));i.setColor3Array(a,n)}for(a in t.colors4){const n=t.colors4[a];i.setColor4(a,{r:n[0],g:n[1],b:n[2],a:n[3]})}for(a in t.colors4Arrays){const n=t.colors4Arrays[a].reduce((o,c,f)=>(f%4===0?o.push([c]):o[o.length-1].push(c),o),[]).map(o=>({r:o[0],g:o[1],b:o[2],a:o[3]}));i.setColor4Array(a,n)}for(a in t.vectors2){const n=t.vectors2[a];i.setVector2(a,{x:n[0],y:n[1]})}for(a in t.vectors3){const n=t.vectors3[a];i.setVector3(a,{x:n[0],y:n[1],z:n[2]})}for(a in t.vectors4){const n=t.vectors4[a];i.setVector4(a,{x:n[0],y:n[1],z:n[2],w:n[3]})}for(a in t.quaternions)i.setQuaternion(a,Ht.FromArray(t.quaternions[a]));for(a in t.matrices)i.setMatrix(a,at.FromArray(t.matrices[a]));for(a in t.matrixArray)i._matrixArrays[a]=new Float32Array(t.matrixArray[a]);for(a in t.matrices3x3)i.setMatrix3x3(a,t.matrices3x3[a]);for(a in t.matrices2x2)i.setMatrix2x2(a,t.matrices2x2[a]);for(a in t.vectors2Arrays)i.setArray2(a,t.vectors2Arrays[a]);for(a in t.vectors3Arrays)i.setArray3(a,t.vectors3Arrays[a]);for(a in t.vectors4Arrays)i.setArray4(a,t.vectors4Arrays[a]);for(a in t.quaternionsArrays)i.setArray4(a,t.quaternionsArrays[a]);return i}static async ParseFromFileAsync(t,e,s,i=""){return await new Promise((a,n)=>{const o=new _e;o.addEventListener("readystatechange",()=>{if(o.readyState==4)if(o.status==200){const c=JSON.parse(o.responseText),f=this.Parse(c,s||Ut.LastCreatedScene,i);t&&(f.name=t),a(f)}else n("Unable to load the ShaderMaterial")}),o.open("GET",e),o.send()})}static async ParseFromSnippetAsync(t,e,s=""){return await new Promise((i,a)=>{const n=new _e;n.addEventListener("readystatechange",()=>{if(n.readyState==4)if(n.status==200){const o=JSON.parse(JSON.parse(n.responseText).jsonPayload),c=JSON.parse(o.shaderMaterial),f=this.Parse(c,e||Ut.LastCreatedScene,s);f.snippetId=t,i(f)}else a("Unable to load the snippet "+t)}),n.open("GET",this.SnippetUrl+"/"+t.replace(/#/g,"/")),n.send()})}}Ct.SnippetUrl="https://snippet.babylonjs.com";Ct.CreateFromSnippetAsync=Ct.ParseFromSnippetAsync;he("BABYLON.ShaderMaterial",Ct);O._LinesMeshParser=(r,t)=>Tt.Parse(r,t);class Tt extends O{_isShaderMaterial(t){return t?t.getClassName()==="ShaderMaterial":!1}constructor(t,e=null,s=null,i=null,a,n,o,c){super(t,e,s,i,a),this.useVertexColor=n,this.useVertexAlpha=o,this.color=new kt(1,1,1),this.alpha=1,this._shaderLanguage=0,i&&(this.color=i.color.clone(),this.alpha=i.alpha,this.useVertexColor=i.useVertexColor,this.useVertexAlpha=i.useVertexAlpha),this.intersectionThreshold=.1;const f=[],g={attributes:[Q.PositionKind],uniforms:["world","viewProjection"],needAlphaBlending:!0,defines:f,useClipPlane:null,shaderLanguage:0};this.useVertexAlpha?g.defines.push("#define VERTEXALPHA"):g.needAlphaBlending=!1,this.useVertexColor?(g.defines.push("#define VERTEXCOLOR"),g.attributes.push(Q.ColorKind)):(g.uniforms.push("color"),this._color4=new It),c?this.material=c:(this.getScene().getEngine().isWebGPU&&!Tt.ForceGLSL&&(this._shaderLanguage=1),g.shaderLanguage=this._shaderLanguage,g.extraInitializationsAsync=async()=>{this._shaderLanguage===1?await Promise.all([Zt(()=>import("./color.vertex-T-eS24_s.js"),__vite__mapDeps([0,1,2,3,4]),import.meta.url),Zt(()=>import("./color.fragment-CuwxTslN.js"),__vite__mapDeps([5,1,2,6]),import.meta.url)]):await Promise.all([Zt(()=>import("./color.vertex-C9BE824k.js"),__vite__mapDeps([7,1,2,8,9]),import.meta.url),Zt(()=>import("./color.fragment-2fwIaQJ6.js"),__vite__mapDeps([10,1,2,11]),import.meta.url)])},this.material=new Ct("colorShader",this.getScene(),"color",g,!1),this.material.doNotSerialize=!0)}getClassName(){return"LinesMesh"}get material(){return this._internalAbstractMeshDataInfo._material}set material(t){this._setMaterial(t),this.material&&(this.material.fillMode=ee.LineListDrawMode)}get checkCollisions(){return!1}set checkCollisions(t){}_bind(t,e){if(!this._geometry)return this;const s=this.isUnIndexed?null:this._geometry.getIndexBuffer();if(!this._userInstancedBuffersStorage||this.hasThinInstances?this._geometry._bind(e,s):this._geometry._bind(e,s,this._userInstancedBuffersStorage.vertexBuffers,this._userInstancedBuffersStorage.vertexArrayObjects),!this.useVertexColor&&this._isShaderMaterial(this.material)){const{r:i,g:a,b:n}=this.color;this._color4.set(i,a,n,this.alpha),this.material.setColor4("color",this._color4)}return this}_draw(t,e,s){if(!this._geometry||!this._geometry.getVertexBuffers()||!this._unIndexed&&!this._geometry.getIndexBuffer())return this;const i=this.getScene().getEngine();return this._unIndexed?i.drawArraysType(ee.LineListDrawMode,t.verticesStart,t.verticesCount,s):i.drawElementsType(ee.LineListDrawMode,t.indexStart,t.indexCount,s),this}dispose(t,e=!1,s){s||this.material?.dispose(!1,!1,!0),super.dispose(t)}clone(t,e=null,s){if(e&&e._addToSceneRootNodes===void 0){const i=e;return i.source=this,new Tt(t,this.getScene(),i.parent,i.source,i.doNotCloneChildren)}return new Tt(t,this.getScene(),e,this,s)}createInstance(t){const e=new Hs(t,this);if(this.instancedBuffers){e.instancedBuffers={};for(const s in this.instancedBuffers)e.instancedBuffers[s]=this.instancedBuffers[s]}return e}serialize(t){super.serialize(t),t.color=this.color.asArray(),t.alpha=this.alpha}static Parse(t,e){const s=new Tt(t.name,e);return s.color=kt.FromArray(t.color),s.alpha=t.alpha,s}}Tt.ForceGLSL=!1;class Hs extends Vs{constructor(t,e){super(t,e),this.intersectionThreshold=e.intersectionThreshold}getClassName(){return"InstancedLinesMesh"}}function Ge(r){const t=[],e=[],s=r.lines,i=r.colors,a=[];let n=0;for(let c=0;c<s.length;c++){const f=s[c];for(let g=0;g<f.length;g++){const{x:h,y:u,z:_}=f[g];if(e.push(h,u,_),i){const d=i[c],{r:A,g:y,b,a:I}=d[g];a.push(A,y,b,I)}g>0&&(t.push(n-1),t.push(n)),n++}}const o=new k;return o.indices=t,o.positions=e,i&&(o.colors=a),o}function Ke(r){const t=r.dashSize||3,e=r.gapSize||1,s=r.dashNb||200,i=r.points,a=[],n=[],o=P.Zero();let c=0,f=0,g=0,h=0,u=0,_=0,d=0;for(d=0;d<i.length-1;d++)i[d+1].subtractToRef(i[d],o),c+=o.length();for(g=c/s,h=t*g/(t+e),d=0;d<i.length-1;d++){i[d+1].subtractToRef(i[d],o),f=Math.floor(o.length()/g),o.normalize();for(let y=0;y<f;y++)u=g*y,a.push(i[d].x+u*o.x,i[d].y+u*o.y,i[d].z+u*o.z),a.push(i[d].x+(u+h)*o.x,i[d].y+(u+h)*o.y,i[d].z+(u+h)*o.z),n.push(_,_+1),_+=2}const A=new k;return A.positions=a,A.indices=n,A}function qe(r,t,e=null){const s=t.instance,i=t.lines,a=t.colors;if(s){const f=s.getVerticesData(Q.PositionKind);let g,h;a&&(g=s.getVerticesData(Q.ColorKind));let u=0,_=0;for(let d=0;d<i.length;d++){const A=i[d];for(let y=0;y<A.length;y++)f[u]=A[y].x,f[u+1]=A[y].y,f[u+2]=A[y].z,a&&g&&(h=a[d],g[_]=h[y].r,g[_+1]=h[y].g,g[_+2]=h[y].b,g[_+3]=h[y].a,_+=4),u+=3}return s.updateVerticesData(Q.PositionKind,f,!1,!1),a&&g&&s.updateVerticesData(Q.ColorKind,g,!1,!1),s.refreshBoundingInfo(),s}const n=!!a,o=new Tt(r,e,null,void 0,void 0,n,t.useVertexAlpha,t.material);return Ge(t).applyToMesh(o,t.updatable),o}function je(r,t,e=null){const s=t.colors?[t.colors]:null;return qe(r,{lines:[t.points],updatable:t.updatable,instance:t.instance,colors:s,useVertexAlpha:t.useVertexAlpha,material:t.material},e)}function Qe(r,t,e=null){const s=t.points,i=t.instance,a=t.gapSize||1,n=t.dashSize||3;if(i){const f=g=>{const h=P.Zero(),u=g.length/6;let _=0,d=0,A=0,y=0,b=0,I=0,w=0,v=0;for(w=0;w<s.length-1;w++)s[w+1].subtractToRef(s[w],h),_+=h.length();A=_/u;const p=i._creationDataStorage.dashSize,x=i._creationDataStorage.gapSize;for(y=p*A/(p+x),w=0;w<s.length-1;w++)for(s[w+1].subtractToRef(s[w],h),d=Math.floor(h.length()/A),h.normalize(),v=0;v<d&&I<g.length;)b=A*v,g[I]=s[w].x+b*h.x,g[I+1]=s[w].y+b*h.y,g[I+2]=s[w].z+b*h.z,g[I+3]=s[w].x+(b+y)*h.x,g[I+4]=s[w].y+(b+y)*h.y,g[I+5]=s[w].z+(b+y)*h.z,I+=6,v++;for(;I<g.length;)g[I]=s[w].x,g[I+1]=s[w].y,g[I+2]=s[w].z,I+=3};return(t.dashNb||t.dashSize||t.gapSize||t.useVertexAlpha||t.material)&&dt.Warn("You have used an option other than points with the instance option. Please be aware that these other options will be ignored."),i.updateMeshPositions(f,!1),i}const o=new Tt(r,e,null,void 0,void 0,void 0,t.useVertexAlpha,t.material);return Ke(t).applyToMesh(o,t.updatable),o._creationDataStorage=new Oe,o._creationDataStorage.dashSize=n,o._creationDataStorage.gapSize=a,o}k.CreateLineSystem=Ge;k.CreateDashedLines=Ke;O.CreateLines=(r,t,e=null,s=!1,i=null)=>je(r,{points:t,updatable:s,instance:i},e);O.CreateDashedLines=(r,t,e,s,i,a=null,n,o)=>Qe(r,{points:t,dashSize:e,gapSize:s,dashNb:i,updatable:n,instance:o},a);class Gs extends rt{constructor(t,e){super(t.x,t.y),this.index=e}}class ie{constructor(){this.elements=[]}add(t){const e=[];for(const s of t){const i=new Gs(s,this.elements.length);e.push(i),this.elements.push(i)}return e}computeBounds(){const t=new rt(this.elements[0].x,this.elements[0].y),e=new rt(this.elements[0].x,this.elements[0].y);for(const s of this.elements)s.x<t.x?t.x=s.x:s.x>e.x&&(e.x=s.x),s.y<t.y?t.y=s.y:s.y>e.y&&(e.y=s.y);return{min:t,max:e,width:e.x-t.x,height:e.y-t.y}}}class Ks{_addToepoint(t){for(const e of t)this._epoints.push(e.x,e.y)}constructor(t,e,s,i=earcut){this._points=new ie,this._outlinepoints=new ie,this._holes=new Array,this._epoints=new Array,this._eholes=new Array,this.bjsEarcut=i,this._name=t,this._scene=s||Ut.LastCreatedScene;let a;e instanceof Ce?a=e.getPoints():a=e,this._addToepoint(a),this._points.add(a),this._outlinepoints.add(a),typeof this.bjsEarcut>"u"&&dt.Warn("Earcut was not found, the polygon will not be built.")}addHole(t){this._points.add(t);const e=new ie;return e.add(t),this._holes.push(e),this._eholes.push(this._epoints.length/2),this._addToepoint(t),this}build(t=!1,e=0,s=2){const i=new O(this._name,this._scene),a=this.buildVertexData(e,s);return i.setVerticesData(Q.PositionKind,a.positions,t),i.setVerticesData(Q.NormalKind,a.normals,t),i.setVerticesData(Q.UVKind,a.uvs,t),i.setIndices(a.indices),i}buildVertexData(t=0,e=2){const s=new k,i=[],a=[],n=[],o=this._points.computeBounds();for(const g of this._points.elements)i.push(0,1,0),a.push(g.x,0,g.y),n.push((g.x-o.min.x)/o.width,(g.y-o.min.y)/o.height);const c=[],f=this.bjsEarcut(this._epoints,this._eholes,2);for(let g=0;g<f.length;g++)c.push(f[g]);if(t>0){const g=a.length/3;for(const u of this._points.elements)i.push(0,-1,0),a.push(u.x,-t,u.y),n.push(1-(u.x-o.min.x)/o.width,1-(u.y-o.min.y)/o.height);const h=c.length;for(let u=0;u<h;u+=3){const _=c[u+0],d=c[u+1],A=c[u+2];c.push(A+g),c.push(d+g),c.push(_+g)}this._addSide(a,i,n,c,o,this._outlinepoints,t,!1,e);for(const u of this._holes)this._addSide(a,i,n,c,o,u,t,!0,e)}return s.indices=c,s.positions=a,s.normals=i,s.uvs=n,s}_addSide(t,e,s,i,a,n,o,c,f){let g=t.length/3,h=0;for(let u=0;u<n.elements.length;u++){const _=n.elements[u],d=n.elements[(u+1)%n.elements.length];t.push(_.x,0,_.y),t.push(_.x,-o,_.y),t.push(d.x,0,d.y),t.push(d.x,-o,d.y);const A=n.elements[(u+n.elements.length-1)%n.elements.length],y=n.elements[(u+2)%n.elements.length];let b=new P(-(d.y-_.y),0,d.x-_.x),I=new P(-(_.y-A.y),0,_.x-A.x),w=new P(-(y.y-d.y),0,y.x-d.x);c||(b=b.scale(-1),I=I.scale(-1),w=w.scale(-1));const v=b.normalizeToNew();let p=I.normalizeToNew(),x=w.normalizeToNew();const m=P.Dot(p,v);m>f?m<ut-1?p=new P(_.x,0,_.y).subtract(new P(d.x,0,d.y)).normalize():p=I.add(b).normalize():p=v;const M=P.Dot(w,b);M>f?M<ut-1?x=new P(d.x,0,d.y).subtract(new P(_.x,0,_.y)).normalize():x=w.add(b).normalize():x=v,s.push(h/a.width,0),s.push(h/a.width,1),h+=b.length(),s.push(h/a.width,0),s.push(h/a.width,1),e.push(p.x,p.y,p.z),e.push(p.x,p.y,p.z),e.push(x.x,x.y,x.z),e.push(x.x,x.y,x.z),c?(i.push(g),i.push(g+2),i.push(g+1),i.push(g+1),i.push(g+2),i.push(g+3)):(i.push(g),i.push(g+1),i.push(g+2),i.push(g+1),i.push(g+3),i.push(g+2)),g+=4}}}function Je(r,t,e,s,i,a,n){const o=e||new Array(3),c=s,f=[],g=n||!1;for(let R=0;R<3;R++)o[R]===void 0&&(o[R]=new Mt(0,0,1,1)),c&&c[R]===void 0&&(c[R]=new It(1,1,1,1));const h=r.getVerticesData(Q.PositionKind),u=r.getVerticesData(Q.NormalKind),_=r.getVerticesData(Q.UVKind),d=r.getIndices(),A=h.length/9;let y=0,b=0,I=0,w=0,v=0;const p=[0];if(g)for(let R=A;R<h.length/3;R+=4)b=h[3*(R+2)]-h[3*R],I=h[3*(R+2)+2]-h[3*R+2],w=Math.sqrt(b*b+I*I),v+=w,p.push(v);let x=0,m=0;for(let R=0;R<u.length;R+=3)Math.abs(u[R+1])<.001&&(m=1),Math.abs(u[R+1]-1)<.001&&(m=0),Math.abs(u[R+1]+1)<.001&&(m=2),x=R/3,m===1?(y=x-A,y%4<1.5?g?_[2*x]=o[m].x+(o[m].z-o[m].x)*p[Math.floor(y/4)]/v:_[2*x]=o[m].x:g?_[2*x]=o[m].x+(o[m].z-o[m].x)*p[Math.floor(y/4)+1]/v:_[2*x]=o[m].z,y%2===0?_[2*x+1]=o[m].w:_[2*x+1]=o[m].y):(_[2*x]=(1-_[2*x])*o[m].x+_[2*x]*o[m].z,_[2*x+1]=(1-_[2*x+1])*o[m].y+_[2*x+1]*o[m].w),c&&f.push(c[m].r,c[m].g,c[m].b,c[m].a);k._ComputeSides(t,h,d,u,_,i,a);const M=new k;if(M.indices=d,M.positions=h,M.normals=u,M.uvs=_,c){const R=t===k.DOUBLESIDE?f.concat(f):f;M.colors=R}return M}function ce(r,t,e=null,s=earcut){t.sideOrientation=O._GetDefaultSideOrientation(t.sideOrientation);const i=t.shape,a=t.holes||[],n=t.depth||0,o=t.smoothingThreshold||2,c=[];let f=[];for(let d=0;d<i.length;d++)c[d]=new rt(i[d].x,i[d].z);c[0].equalsWithEpsilon(c[c.length-1],1e-8)&&c.pop();const h=new Ks(r,c,e||Ut.LastCreatedScene,s);for(let d=0;d<a.length;d++){f=[];for(let A=0;A<a[d].length;A++)f.push(new rt(a[d][A].x,a[d][A].z));h.addHole(f)}const u=h.build(!1,n,o);return u._originalBuilderSideOrientation=t.sideOrientation,Je(u,t.sideOrientation,t.faceUV,t.faceColors,t.frontUVs,t.backUVs,t.wrap).applyToMesh(u,t.updatable),u}function le(r,t,e=null,s=earcut){return ce(r,t,e,s)}k.CreatePolygon=Je;O.CreatePolygon=(r,t,e,s,i,a,n=earcut)=>ce(r,{shape:t,holes:s,updatable:i,sideOrientation:a},e,n);O.ExtrudePolygon=(r,t,e,s,i,a,n,o=earcut)=>le(r,{shape:t,holes:i,depth:e,updatable:a,sideOrientation:n},s,o);function $e(r,t,e=null){const s=t.path,i=t.shape,a=t.scale||1,n=t.rotation||0,o=t.cap===0?0:t.cap||O.NO_CAP,c=t.updatable,f=O._GetDefaultSideOrientation(t.sideOrientation),g=t.instance||null,h=t.invertUV||!1,u=t.closeShape||!1,_=t.closePath||!1,d=t.capFunction||null;return es(r,i,s,a,n,null,null,_,u,o,!1,e,!!c,f,g,h,t.frontUVs||null,t.backUVs||null,t.firstNormal||null,!!t.adjustFrame,d)}function ts(r,t,e=null){const s=t.path,i=t.shape,a=t.scaleFunction||(()=>1),n=t.rotationFunction||(()=>0),o=t.closePath||t.ribbonCloseArray||!1,c=t.closeShape||t.ribbonClosePath||!1,f=t.cap===0?0:t.cap||O.NO_CAP,g=t.updatable,h=t.firstNormal||null,u=t.adjustFrame||!1,_=O._GetDefaultSideOrientation(t.sideOrientation),d=t.instance,A=t.invertUV||!1,y=t.capFunction||null;return es(r,i,s,null,null,a,n,o,c,f,!0,e,!!g,_,d||null,A,t.frontUVs||null,t.backUVs||null,h,u,y||null)}function es(r,t,e,s,i,a,n,o,c,f,g,h,u,_,d,A,y,b,I,w,v){const p=(D,L,V,N,q,U,G,z,X,B,S)=>{const l=V.getTangents(),T=V.getNormals(),C=V.getBinormals(),E=V.getDistances();if(S){for(let Z=0;Z<l.length;Z++)if(l[Z].x==0&&l[Z].y==0&&l[Z].z==0&&l[Z].copyFrom(l[Z-1]),T[Z].x==0&&T[Z].y==0&&T[Z].z==0&&T[Z].copyFrom(T[Z-1]),C[Z].x==0&&C[Z].y==0&&C[Z].z==0&&C[Z].copyFrom(C[Z-1]),Z>0){let ct=l[Z-1];P.Dot(ct,l[Z])<0&&l[Z].scaleInPlace(-1),ct=T[Z-1],P.Dot(ct,T[Z])<0&&T[Z].scaleInPlace(-1),ct=C[Z-1],P.Dot(ct,C[Z])<0&&C[Z].scaleInPlace(-1)}}let Y=0;const F=()=>q!==null?q:1,$=B&&z?z:()=>U!==null?U:0,ot=B&&G?G:F;let it=X===O.NO_CAP||X===O.CAP_END?0:2;const ht=st.Matrix[0];for(let Z=0;Z<L.length;Z++){const ct=[],xt=$(Z,E[Z]),mt=ot(Z,E[Z]);at.RotationAxisToRef(l[Z],Y,ht);for(let At=0;At<D.length;At++){const St=l[Z].scale(D[At].z).add(T[Z].scale(D[At].x)).add(C[Z].scale(D[At].y)),Ot=P.Zero();P.TransformCoordinatesToRef(St,ht,Ot),Ot.scaleInPlace(mt).addInPlace(L[Z]),ct[At]=Ot}N[it]=ct,Y+=xt,it++}const J=v||(Z=>{const ct=Array(),xt=P.Zero();let mt;for(mt=0;mt<Z.length;mt++)xt.addInPlace(Z[mt]);for(xt.scaleInPlace(1/Z.length),mt=0;mt<Z.length;mt++)ct.push(xt);return ct});switch(X){case O.NO_CAP:break;case O.CAP_START:N[0]=J(N[2]),N[1]=N[2];break;case O.CAP_END:N[it]=N[it-1],N[it+1]=J(N[it-1]);break;case O.CAP_ALL:N[0]=J(N[2]),N[1]=N[2],N[it]=N[it-1],N[it+1]=J(N[it-1]);break}return N};let x,m;if(d){const D=d._creationDataStorage;return x=I?D.path3D.update(e,I):D.path3D.update(e),m=p(t,e,D.path3D,D.pathArray,s,i,a,n,D.cap,g,w),d=Dt("",{pathArray:m,closeArray:!1,closePath:!1,offset:0,updatable:!1,sideOrientation:0,instance:d},h||void 0),d}x=I?new ae(e,I):new ae(e);const M=new Array;f=f<0||f>3?0:f,m=p(t,e,x,M,s,i,a,n,f,g,w);const R=Dt(r,{pathArray:m,closeArray:o,closePath:c,updatable:u,sideOrientation:_,invertUV:A,frontUVs:y||void 0,backUVs:b||void 0},h);return R._creationDataStorage.pathArray=m,R._creationDataStorage.path3D=x,R._creationDataStorage.cap=f,R}O.ExtrudeShape=(r,t,e,s,i,a,n=null,o,c,f)=>{const g={shape:t,path:e,scale:s,rotation:i,cap:a===0?0:a||O.NO_CAP,sideOrientation:c,instance:f,updatable:o};return $e(r,g,n)};O.ExtrudeShapeCustom=(r,t,e,s,i,a,n,o,c,f,g,h)=>{const u={shape:t,path:e,scaleFunction:s,rotationFunction:i,ribbonCloseArray:a,ribbonClosePath:n,cap:o===0?0:o||O.NO_CAP,sideOrientation:g,instance:h,updatable:f};return ts(r,u,c)};function ss(r,t,e=null){const s=t.arc?t.arc<=0||t.arc>1?1:t.arc:1,i=t.closed===void 0?!0:t.closed,a=t.shape,n=t.radius||1,o=t.tessellation||64,c=t.clip||0,f=t.updatable,g=O._GetDefaultSideOrientation(t.sideOrientation),h=t.cap||O.NO_CAP,u=Math.PI*2,_=[],d=t.invertUV||!1;let A=0,y=0;const b=u/o*s;let I,w;for(A=0;A<=o-c;A++){for(w=[],(h==O.CAP_START||h==O.CAP_ALL)&&(w.push(new P(0,a[0].y,0)),w.push(new P(Math.cos(A*b)*a[0].x*n,a[0].y,Math.sin(A*b)*a[0].x*n))),y=0;y<a.length;y++)I=new P(Math.cos(A*b)*a[y].x*n,a[y].y,Math.sin(A*b)*a[y].x*n),w.push(I);(h==O.CAP_END||h==O.CAP_ALL)&&(w.push(new P(Math.cos(A*b)*a[a.length-1].x*n,a[a.length-1].y,Math.sin(A*b)*a[a.length-1].x*n)),w.push(new P(0,a[a.length-1].y,0))),_.push(w)}return Dt(r,{pathArray:_,closeArray:i,sideOrientation:g,updatable:f,invertUV:d,frontUVs:t.frontUVs,backUVs:t.backUVs},e)}O.CreateLathe=(r,t,e,s,i,a,n)=>ss(r,{shape:t,radius:e,tessellation:s,sideOrientation:n,updatable:a},i);function is(r){const t=[],e=[],s=[],i=[],a=r.width!==void 0?r.width:r.size!==void 0?r.size:1,n=r.height!==void 0?r.height:r.size!==void 0?r.size:1,o=r.sideOrientation===0?0:r.sideOrientation||k.DEFAULTSIDE,c=a/2,f=n/2;e.push(-c,-f,0),s.push(0,0,-1),i.push(0,0),e.push(c,-f,0),s.push(0,0,-1),i.push(1,0),e.push(c,f,0),s.push(0,0,-1),i.push(1,1),e.push(-c,f,0),s.push(0,0,-1),i.push(0,1),t.push(0),t.push(1),t.push(2),t.push(0),t.push(2),t.push(3),k._ComputeSides(o,e,t,s,i,r.frontUVs,r.backUVs);const g=new k;return g.indices=t,g.positions=e,g.normals=s,g.uvs=i,g}function as(r,t={},e=null){const s=new O(r,e);return t.sideOrientation=O._GetDefaultSideOrientation(t.sideOrientation),s._originalBuilderSideOrientation=t.sideOrientation,is(t).applyToMesh(s,t.updatable),t.sourcePlane&&(s.translate(t.sourcePlane.normal,-t.sourcePlane.d),s.setDirection(t.sourcePlane.normal.scale(-1))),s}k.CreatePlane=is;O.CreatePlane=(r,t,e,s,i)=>as(r,{size:t,width:t,height:t,sideOrientation:i,updatable:s},e);function ns(r,t,e=null){const s=t.path;let i=t.instance,a=1;t.radius!==void 0?a=t.radius:i&&(a=i._creationDataStorage.radius);const n=t.tessellation||64,o=t.radiusFunction||null;let c=t.cap||O.NO_CAP;const f=t.invertUV||!1,g=t.updatable,h=O._GetDefaultSideOrientation(t.sideOrientation);t.arc=t.arc&&(t.arc<=0||t.arc>1)?1:t.arc||1;const u=(b,I,w,v,p,x,m,M)=>{const R=I.getTangents(),D=I.getNormals(),L=I.getDistances(),N=Math.PI*2/p*M,U=x||(()=>v);let G,z,X,B;const S=st.Matrix[0];let l=m===O.NO_CAP||m===O.CAP_END?0:2;for(let C=0;C<b.length;C++){z=U(C,L[C]),G=Array(),X=D[C];for(let E=0;E<p;E++)at.RotationAxisToRef(R[C],N*E,S),B=G[E]?G[E]:P.Zero(),P.TransformCoordinatesToRef(X,S,B),B.scaleInPlace(z).addInPlace(b[C]),G[E]=B;w[l]=G,l++}const T=(C,E)=>{const Y=Array();for(let F=0;F<C;F++)Y.push(b[E]);return Y};switch(m){case O.NO_CAP:break;case O.CAP_START:w[0]=T(p,0),w[1]=w[2].slice(0);break;case O.CAP_END:w[l]=w[l-1].slice(0),w[l+1]=T(p,b.length-1);break;case O.CAP_ALL:w[0]=T(p,0),w[1]=w[2].slice(0),w[l]=w[l-1].slice(0),w[l+1]=T(p,b.length-1);break}return w};let _,d;if(i){const b=i._creationDataStorage,I=t.arc||b.arc;return _=b.path3D.update(s),d=u(s,_,b.pathArray,a,b.tessellation,o,b.cap,I),i=Dt("",{pathArray:d,instance:i}),b.path3D=_,b.pathArray=d,b.arc=I,b.radius=a,i}_=new ae(s);const A=new Array;c=c<0||c>3?0:c,d=u(s,_,A,a,n,o,c,t.arc);const y=Dt(r,{pathArray:d,closePath:!0,closeArray:!1,updatable:g,sideOrientation:h,invertUV:f,frontUVs:t.frontUVs,backUVs:t.backUVs},e);return y._creationDataStorage.pathArray=d,y._creationDataStorage.path3D=_,y._creationDataStorage.tessellation=n,y._creationDataStorage.cap=c,y._creationDataStorage.arc=t.arc,y._creationDataStorage.radius=a,y}O.CreateTube=(r,t,e,s,i,a,n,o,c,f)=>ns(r,{path:t,radius:e,tessellation:s,radiusFunction:i,arc:1,cap:a,updatable:o,sideOrientation:c,instance:f},n);function rs(r){const t=[];t[0]={vertex:[[0,0,1.732051],[1.632993,0,-.5773503],[-.8164966,1.414214,-.5773503],[-.8164966,-1.414214,-.5773503]],face:[[0,1,2],[0,2,3],[0,3,1],[1,3,2]]},t[1]={vertex:[[0,0,1.414214],[1.414214,0,0],[0,1.414214,0],[-1.414214,0,0],[0,-1.414214,0],[0,0,-1.414214]],face:[[0,1,2],[0,2,3],[0,3,4],[0,4,1],[1,4,5],[1,5,2],[2,5,3],[3,5,4]]},t[2]={vertex:[[0,0,1.070466],[.7136442,0,.7978784],[-.3568221,.618034,.7978784],[-.3568221,-.618034,.7978784],[.7978784,.618034,.3568221],[.7978784,-.618034,.3568221],[-.9341724,.381966,.3568221],[.1362939,1,.3568221],[.1362939,-1,.3568221],[-.9341724,-.381966,.3568221],[.9341724,.381966,-.3568221],[.9341724,-.381966,-.3568221],[-.7978784,.618034,-.3568221],[-.1362939,1,-.3568221],[-.1362939,-1,-.3568221],[-.7978784,-.618034,-.3568221],[.3568221,.618034,-.7978784],[.3568221,-.618034,-.7978784],[-.7136442,0,-.7978784],[0,0,-1.070466]],face:[[0,1,4,7,2],[0,2,6,9,3],[0,3,8,5,1],[1,5,11,10,4],[2,7,13,12,6],[3,9,15,14,8],[4,10,16,13,7],[5,8,14,17,11],[6,12,18,15,9],[10,11,17,19,16],[12,13,16,19,18],[14,15,18,19,17]]},t[3]={vertex:[[0,0,1.175571],[1.051462,0,.5257311],[.3249197,1,.5257311],[-.8506508,.618034,.5257311],[-.8506508,-.618034,.5257311],[.3249197,-1,.5257311],[.8506508,.618034,-.5257311],[.8506508,-.618034,-.5257311],[-.3249197,1,-.5257311],[-1.051462,0,-.5257311],[-.3249197,-1,-.5257311],[0,0,-1.175571]],face:[[0,1,2],[0,2,3],[0,3,4],[0,4,5],[0,5,1],[1,5,7],[1,7,6],[1,6,2],[2,6,8],[2,8,3],[3,8,9],[3,9,4],[4,9,10],[4,10,5],[5,10,7],[6,7,11],[6,11,8],[7,10,11],[8,11,9],[9,11,10]]},t[4]={vertex:[[0,0,1.070722],[.7148135,0,.7971752],[-.104682,.7071068,.7971752],[-.6841528,.2071068,.7971752],[-.104682,-.7071068,.7971752],[.6101315,.7071068,.5236279],[1.04156,.2071068,.1367736],[.6101315,-.7071068,.5236279],[-.3574067,1,.1367736],[-.7888348,-.5,.5236279],[-.9368776,.5,.1367736],[-.3574067,-1,.1367736],[.3574067,1,-.1367736],[.9368776,-.5,-.1367736],[.7888348,.5,-.5236279],[.3574067,-1,-.1367736],[-.6101315,.7071068,-.5236279],[-1.04156,-.2071068,-.1367736],[-.6101315,-.7071068,-.5236279],[.104682,.7071068,-.7971752],[.6841528,-.2071068,-.7971752],[.104682,-.7071068,-.7971752],[-.7148135,0,-.7971752],[0,0,-1.070722]],face:[[0,2,3],[1,6,5],[4,9,11],[7,15,13],[8,16,10],[12,14,19],[17,22,18],[20,21,23],[0,1,5,2],[0,3,9,4],[0,4,7,1],[1,7,13,6],[2,5,12,8],[2,8,10,3],[3,10,17,9],[4,11,15,7],[5,6,14,12],[6,13,20,14],[8,12,19,16],[9,17,18,11],[10,16,22,17],[11,18,21,15],[13,15,21,20],[14,20,23,19],[16,19,23,22],[18,22,23,21]]},t[5]={vertex:[[0,0,1.322876],[1.309307,0,.1889822],[-.9819805,.8660254,.1889822],[.1636634,-1.299038,.1889822],[.3273268,.8660254,-.9449112],[-.8183171,-.4330127,-.9449112]],face:[[0,3,1],[2,4,5],[0,1,4,2],[0,2,5,3],[1,3,5,4]]},t[6]={vertex:[[0,0,1.159953],[1.013464,0,.5642542],[-.3501431,.9510565,.5642542],[-.7715208,-.6571639,.5642542],[.6633206,.9510565,-.03144481],[.8682979,-.6571639,-.3996071],[-1.121664,.2938926,-.03144481],[-.2348831,-1.063314,-.3996071],[.5181548,.2938926,-.9953061],[-.5850262,-.112257,-.9953061]],face:[[0,1,4,2],[0,2,6,3],[1,5,8,4],[3,6,9,7],[5,7,9,8],[0,3,7,5,1],[2,4,8,9,6]]},t[7]={vertex:[[0,0,1.118034],[.8944272,0,.6708204],[-.2236068,.8660254,.6708204],[-.7826238,-.4330127,.6708204],[.6708204,.8660254,.2236068],[1.006231,-.4330127,-.2236068],[-1.006231,.4330127,.2236068],[-.6708204,-.8660254,-.2236068],[.7826238,.4330127,-.6708204],[.2236068,-.8660254,-.6708204],[-.8944272,0,-.6708204],[0,0,-1.118034]],face:[[0,1,4,2],[0,2,6,3],[1,5,8,4],[3,6,10,7],[5,9,11,8],[7,10,11,9],[0,3,7,9,5,1],[2,4,8,11,10,6]]},t[8]={vertex:[[-.729665,.670121,.319155],[-.655235,-.29213,-.754096],[-.093922,-.607123,.537818],[.702196,.595691,.485187],[.776626,-.36656,-.588064]],face:[[1,4,2],[0,1,2],[3,0,2],[4,3,2],[4,1,0,3]]},t[9]={vertex:[[-.868849,-.100041,.61257],[-.329458,.976099,.28078],[-.26629,-.013796,-.477654],[-.13392,-1.034115,.229829],[.738834,.707117,-.307018],[.859683,-.535264,-.338508]],face:[[3,0,2],[5,3,2],[4,5,2],[1,4,2],[0,1,2],[0,3,5,4,1]]},t[10]={vertex:[[-.610389,.243975,.531213],[-.187812,-.48795,-.664016],[-.187812,.9759,-.664016],[.187812,-.9759,.664016],[.798201,.243975,.132803]],face:[[1,3,0],[3,4,0],[3,1,4],[0,2,1],[0,4,2],[2,4,1]]},t[11]={vertex:[[-1.028778,.392027,-.048786],[-.640503,-.646161,.621837],[-.125162,-.395663,-.540059],[.004683,.888447,-.651988],[.125161,.395663,.540059],[.632925,-.791376,.433102],[1.031672,.157063,-.354165]],face:[[3,2,0],[2,1,0],[2,5,1],[0,4,3],[0,1,4],[4,1,5],[2,3,6],[3,4,6],[5,2,6],[4,5,6]]},t[12]={vertex:[[-.669867,.334933,-.529576],[-.669867,.334933,.529577],[-.4043,1.212901,0],[-.334933,-.669867,-.529576],[-.334933,-.669867,.529577],[.334933,.669867,-.529576],[.334933,.669867,.529577],[.4043,-1.212901,0],[.669867,-.334933,-.529576],[.669867,-.334933,.529577]],face:[[8,9,7],[6,5,2],[3,8,7],[5,0,2],[4,3,7],[0,1,2],[9,4,7],[1,6,2],[9,8,5,6],[8,3,0,5],[3,4,1,0],[4,9,6,1]]},t[13]={vertex:[[-.931836,.219976,-.264632],[-.636706,.318353,.692816],[-.613483,-.735083,-.264632],[-.326545,.979634,0],[-.318353,-.636706,.692816],[-.159176,.477529,-.856368],[.159176,-.477529,-.856368],[.318353,.636706,.692816],[.326545,-.979634,0],[.613482,.735082,-.264632],[.636706,-.318353,.692816],[.931835,-.219977,-.264632]],face:[[11,10,8],[7,9,3],[6,11,8],[9,5,3],[2,6,8],[5,0,3],[4,2,8],[0,1,3],[10,4,8],[1,7,3],[10,11,9,7],[11,6,5,9],[6,2,0,5],[2,4,1,0],[4,10,7,1]]},t[14]={vertex:[[-.93465,.300459,-.271185],[-.838689,-.260219,-.516017],[-.711319,.717591,.128359],[-.710334,-.156922,.080946],[-.599799,.556003,-.725148],[-.503838,-.004675,-.969981],[-.487004,.26021,.48049],[-.460089,-.750282,-.512622],[-.376468,.973135,-.325605],[-.331735,-.646985,.084342],[-.254001,.831847,.530001],[-.125239,-.494738,-.966586],[.029622,.027949,.730817],[.056536,-.982543,-.262295],[.08085,1.087391,.076037],[.125583,-.532729,.485984],[.262625,.599586,.780328],[.391387,-.726999,-.716259],[.513854,-.868287,.139347],[.597475,.85513,.326364],[.641224,.109523,.783723],[.737185,-.451155,.538891],[.848705,-.612742,-.314616],[.976075,.365067,.32976],[1.072036,-.19561,.084927]],face:[[15,18,21],[12,20,16],[6,10,2],[3,0,1],[9,7,13],[2,8,4,0],[0,4,5,1],[1,5,11,7],[7,11,17,13],[13,17,22,18],[18,22,24,21],[21,24,23,20],[20,23,19,16],[16,19,14,10],[10,14,8,2],[15,9,13,18],[12,15,21,20],[6,12,16,10],[3,6,2,0],[9,3,1,7],[9,15,12,6,3],[22,17,11,5,4,8,14,19,23,24]]};const e=r.type&&(r.type<0||r.type>=t.length)?0:r.type||0,s=r.size,i=r.sizeX||s||1,a=r.sizeY||s||1,n=r.sizeZ||s||1,o=r.custom||t[e],c=o.face.length,f=r.faceUV||new Array(c),g=r.faceColors,h=r.flat===void 0?!0:r.flat,u=r.sideOrientation===0?0:r.sideOrientation||k.DEFAULTSIDE,_=[],d=[],A=[],y=[],b=[];let I=0,w=0;const v=[];let p=0,x=0,m,M,R,D,L,V;if(h)for(x=0;x<c;x++)g&&g[x]===void 0&&(g[x]=new It(1,1,1,1)),f&&f[x]===void 0&&(f[x]=new Mt(0,0,1,1));if(h)for(x=0;x<c;x++){const q=o.face[x].length;for(R=2*Math.PI/q,D=.5*Math.tan(R/2),L=.5,p=0;p<q;p++)_.push(o.vertex[o.face[x][p]][0]*i,o.vertex[o.face[x][p]][1]*a,o.vertex[o.face[x][p]][2]*n),v.push(I),I++,m=f[x].x+(f[x].z-f[x].x)*(.5+D),M=f[x].y+(f[x].w-f[x].y)*(L-.5),y.push(m,M),V=D*Math.cos(R)-L*Math.sin(R),L=D*Math.sin(R)+L*Math.cos(R),D=V,g&&b.push(g[x].r,g[x].g,g[x].b,g[x].a);for(p=0;p<q-2;p++)d.push(v[0+w],v[p+2+w],v[p+1+w]);w+=q}else{for(p=0;p<o.vertex.length;p++)_.push(o.vertex[p][0]*i,o.vertex[p][1]*a,o.vertex[p][2]*n),y.push(0,0);for(x=0;x<c;x++)for(p=0;p<o.face[x].length-2;p++)d.push(o.face[x][0],o.face[x][p+2],o.face[x][p+1])}k.ComputeNormals(_,d,A),k._ComputeSides(u,_,d,A,y,r.frontUVs,r.backUVs);const N=new k;return N.positions=_,N.indices=d,N.normals=A,N.uvs=y,g&&h&&(N.colors=b),N}function ue(r,t={},e=null){const s=new O(r,e);return t.sideOrientation=O._GetDefaultSideOrientation(t.sideOrientation),s._originalBuilderSideOrientation=t.sideOrientation,rs(t).applyToMesh(s,t.updatable),s}k.CreatePolyhedron=rs;O.CreatePolyhedron=(r,t,e)=>ue(r,t,e);function os(r){const t=r.sideOrientation||k.DEFAULTSIDE,e=r.radius||1,s=r.flat===void 0?!0:r.flat,i=(r.subdivisions||4)|0,a=r.radiusX||e,n=r.radiusY||e,o=r.radiusZ||e,c=(1+Math.sqrt(5))/2,f=[-1,c,-0,1,c,0,-1,-c,0,1,-c,0,0,-1,-c,0,1,-c,0,-1,c,0,1,c,c,0,1,c,0,-1,-c,0,1,-c,0,-1],g=[0,11,5,0,5,1,0,1,7,0,7,10,12,22,23,1,5,20,5,11,4,23,22,13,22,18,6,7,1,8,14,21,4,14,4,2,16,13,6,15,6,19,3,8,9,4,21,5,13,17,23,6,13,22,19,6,18,9,8,1],h=[0,1,2,3,4,5,6,7,8,9,10,11,0,2,3,3,3,4,7,8,9,9,10,11],u=[5,1,3,1,6,4,0,0,5,3,4,2,2,2,4,0,2,0,1,1,6,0,6,2,0,4,3,3,4,4,3,1,4,2,4,4,0,2,1,1,2,2,3,3,1,3,2,4],_=138/1024,d=239/1024,A=60/1024,y=26/1024,b=-40/1024,I=20/1024,w=[0,0,0,0,1,0,0,1,1,0,0,0,1,1,0,0,1,1,1,0],v=[],p=[],x=[],m=[];let M=0;const R=new Array(3),D=new Array(3);let L;for(L=0;L<3;L++)R[L]=P.Zero(),D[L]=rt.Zero();for(let N=0;N<20;N++){for(L=0;L<3;L++){const U=g[3*N+L];R[L].copyFromFloats(f[3*h[U]],f[3*h[U]+1],f[3*h[U]+2]),R[L].normalize(),D[L].copyFromFloats(u[2*U]*_+A+w[N]*b,u[2*U+1]*d+y+w[N]*I)}const q=(U,G,z,X)=>{const B=P.Lerp(R[0],R[2],G/i),S=P.Lerp(R[1],R[2],G/i),l=i===G?R[2]:P.Lerp(B,S,U/(i-G));l.normalize();let T;if(s){const F=P.Lerp(R[0],R[2],X/i),H=P.Lerp(R[1],R[2],X/i);T=P.Lerp(F,H,z/(i-X))}else T=new P(l.x,l.y,l.z);T.x/=a,T.y/=n,T.z/=o,T.normalize();const C=rt.Lerp(D[0],D[2],G/i),E=rt.Lerp(D[1],D[2],G/i),Y=i===G?D[2]:rt.Lerp(C,E,U/(i-G));p.push(l.x*a,l.y*n,l.z*o),x.push(T.x,T.y,T.z),m.push(Y.x,Y.y),v.push(M),M++};for(let U=0;U<i;U++)for(let G=0;G+U<i;G++)q(G,U,G+1/3,U+1/3),q(G+1,U,G+1/3,U+1/3),q(G,U+1,G+1/3,U+1/3),G+U+1<i&&(q(G+1,U,G+2/3,U+2/3),q(G+1,U+1,G+2/3,U+2/3),q(G,U+1,G+2/3,U+2/3))}k._ComputeSides(t,p,v,x,m,r.frontUVs,r.backUVs);const V=new k;return V.indices=v,V.positions=p,V.normals=x,V.uvs=m,V}function hs(r,t={},e=null){const s=new O(r,e);return t.sideOrientation=O._GetDefaultSideOrientation(t.sideOrientation),s._originalBuilderSideOrientation=t.sideOrientation,os(t).applyToMesh(s,t.updatable),s}k.CreateIcoSphere=os;O.CreateIcoSphere=(r,t,e)=>hs(r,t,e);const qs=new P(1,0,0),js=new P(-1,0,0),Qs=new P(0,1,0),Js=new P(0,-1,0),$s=new P(0,0,1),ti=new P(0,0,-1);class Gt{constructor(t=P.Zero(),e=P.Up(),s=rt.Zero(),i=0,a=0,n=null,o=null,c=null,f=null){this.position=t,this.normal=e,this.uv=s,this.vertexIdx=i,this.vertexIdxForBones=a,this.localPositionOverride=n,this.localNormalOverride=o,this.matrixIndicesOverride=c,this.matrixWeightsOverride=f}clone(){return new Gt(this.position.clone(),this.normal.clone(),this.uv.clone(),this.vertexIdx,this.vertexIdxForBones,this.localPositionOverride?.slice(),this.localNormalOverride?.slice(),this.matrixIndicesOverride?.slice(),this.matrixWeightsOverride?.slice())}}function cs(r,t,e){const s=!!t.skeleton,i=!!t.morphTargetManager?.numTargets,a=e.localMode||s,n=t.getIndices(),o=s||i?t.getPositionData(!0,!0):t.getVerticesData(Q.PositionKind),c=s||i?t.getNormalsData(!0,!0):t.getVerticesData(Q.NormalKind),f=a?s?t.getVerticesData(Q.PositionKind):o:null,g=a?s?t.getVerticesData(Q.NormalKind):c:null,h=t.getVerticesData(Q.UVKind),u=s?t.getVerticesData(Q.MatricesIndicesKind):null,_=s?t.getVerticesData(Q.MatricesWeightsKind):null,d=s?t.getVerticesData(Q.MatricesIndicesExtraKind):null,A=s?t.getVerticesData(Q.MatricesWeightsExtraKind):null,y=e.position||P.Zero();let b=e.normal||P.Up();const I=e.size||P.One(),w=e.angle||0;if(!b){const z=new P(0,0,1),X=t.getScene().activeCamera,B=P.TransformCoordinates(z,X.getWorldMatrix());b=X.globalPosition.subtract(B)}const v=-Math.atan2(b.z,b.x)-Math.PI/2,p=Math.sqrt(b.x*b.x+b.z*b.z),x=Math.atan2(b.y,p),m=new k;m.indices=[],m.positions=[],m.normals=[],m.uvs=[],m.matricesIndices=s?[]:null,m.matricesWeights=s?[]:null,m.matricesIndicesExtra=d?[]:null,m.matricesWeightsExtra=A?[]:null;let M=0;const R=(z,X)=>{const B=new Gt;if(!n||!o||!c)return B;const S=n[z];if(B.vertexIdx=S*3,B.vertexIdxForBones=S*4,B.position=new P(o[S*3],o[S*3+1],o[S*3+2]),P.TransformCoordinatesToRef(B.position,X,B.position),B.normal=new P(c[S*3],c[S*3+1],c[S*3+2]),P.TransformNormalToRef(B.normal,X,B.normal),e.captureUVS&&h){const l=h[S*2+1];B.uv=new rt(h[S*2],l)}return B},D=[0,0,0,0],L=(z,X)=>{if(z.length===0)return z;const B=.5*Math.abs(P.Dot(I,X)),S=(C,E,Y,F)=>{for(let H=0;H<F;++H)if(C[Y+H]===E)return Y+H;return-1},l=(C,E)=>{const Y=P.GetClipFactor(C.position,E.position,X,B);let F=D,H=D;if(u&&_){const Lt=C.matrixIndicesOverride?0:C.vertexIdxForBones,Jt=C.matrixIndicesOverride??u,de=C.matrixWeightsOverride??_,$t=E.matrixIndicesOverride?0:E.vertexIdxForBones,fe=E.matrixIndicesOverride??u,pe=E.matrixWeightsOverride??_;F=[0,0,0,0],H=[0,0,0,0];let wt=0;for(let bt=0;bt<4;++bt)if(de[Lt+bt]>0){const Ft=S(fe,Jt[Lt+bt],$t,4);F[wt]=Jt[Lt+bt],H[wt]=xe(de[Lt+bt],Ft>=0?pe[Ft]:0,Y),wt++}for(let bt=0;bt<4&&wt<4;++bt){const Ft=fe[$t+bt];S(Jt,Ft,Lt,4)===-1&&(F[wt]=Ft,H[wt]=xe(0,pe[$t+bt],Y),wt++)}const Yt=H[0]+H[1]+H[2]+H[3];H[0]/=Yt,H[1]/=Yt,H[2]/=Yt,H[3]/=Yt}const $=C.localPositionOverride?C.localPositionOverride[0]:f?.[C.vertexIdx]??0,ot=C.localPositionOverride?C.localPositionOverride[1]:f?.[C.vertexIdx+1]??0,it=C.localPositionOverride?C.localPositionOverride[2]:f?.[C.vertexIdx+2]??0,ht=E.localPositionOverride?E.localPositionOverride[0]:f?.[E.vertexIdx]??0,W=E.localPositionOverride?E.localPositionOverride[1]:f?.[E.vertexIdx+1]??0,J=E.localPositionOverride?E.localPositionOverride[2]:f?.[E.vertexIdx+2]??0,Z=C.localNormalOverride?C.localNormalOverride[0]:g?.[C.vertexIdx]??0,ct=C.localNormalOverride?C.localNormalOverride[1]:g?.[C.vertexIdx+1]??0,xt=C.localNormalOverride?C.localNormalOverride[2]:g?.[C.vertexIdx+2]??0,mt=E.localNormalOverride?E.localNormalOverride[0]:g?.[E.vertexIdx]??0,At=E.localNormalOverride?E.localNormalOverride[1]:g?.[E.vertexIdx+1]??0,St=E.localNormalOverride?E.localNormalOverride[2]:g?.[E.vertexIdx+2]??0,Ot=Z+(mt-Z)*Y,Bt=ct+(At-ct)*Y,Et=xt+(St-xt)*Y,Qt=Math.sqrt(Ot*Ot+Bt*Bt+Et*Et);return new Gt(P.Lerp(C.position,E.position,Y),P.Lerp(C.normal,E.normal,Y).normalize(),rt.Lerp(C.uv,E.uv,Y),-1,-1,f?[$+(ht-$)*Y,ot+(W-ot)*Y,it+(J-it)*Y]:null,g?[Ot/Qt,Bt/Qt,Et/Qt]:null,F,H)};let T=null;z.length>3&&(T=[]);for(let C=0;C<z.length;C+=3){let E=0,Y=null,F=null,H=null,$=null;const ot=P.Dot(z[C].position,X)-B,it=P.Dot(z[C+1].position,X)-B,ht=P.Dot(z[C+2].position,X)-B,W=ot>0,J=it>0,Z=ht>0;switch(E=(W?1:0)+(J?1:0)+(Z?1:0),E){case 0:z.length>3?(T.push(z[C]),T.push(z[C+1]),T.push(z[C+2])):T=z;break;case 1:if(T=T??new Array,W&&(Y=z[C+1],F=z[C+2],H=l(z[C],Y),$=l(z[C],F)),J){Y=z[C],F=z[C+2],H=l(z[C+1],Y),$=l(z[C+1],F),T.push(H),T.push(F.clone()),T.push(Y.clone()),T.push(F.clone()),T.push(H.clone()),T.push($);break}Z&&(Y=z[C],F=z[C+1],H=l(z[C+2],Y),$=l(z[C+2],F)),Y&&F&&H&&$&&(T.push(Y.clone()),T.push(F.clone()),T.push(H),T.push($),T.push(H.clone()),T.push(F.clone()));break;case 2:T=T??new Array,W||(Y=z[C].clone(),F=l(Y,z[C+1]),H=l(Y,z[C+2]),T.push(Y),T.push(F),T.push(H)),J||(Y=z[C+1].clone(),F=l(Y,z[C+2]),H=l(Y,z[C]),T.push(Y),T.push(F),T.push(H)),Z||(Y=z[C+2].clone(),F=l(Y,z[C]),H=l(Y,z[C+1]),T.push(Y),T.push(F),T.push(H));break}}return T},V=t instanceof O?t:null,N=V?._thinInstanceDataStorage.matrixData,q=V?.thinInstanceCount||1,U=st.Matrix[0];U.copyFrom(at.IdentityReadOnly);for(let z=0;z<q;++z){if(V?.hasThinInstances&&N){const C=z*16;U.setRowFromFloats(0,N[C+0],N[C+1],N[C+2],N[C+3]),U.setRowFromFloats(1,N[C+4],N[C+5],N[C+6],N[C+7]),U.setRowFromFloats(2,N[C+8],N[C+9],N[C+10],N[C+11]),U.setRowFromFloats(3,N[C+12],N[C+13],N[C+14],N[C+15])}const X=at.RotationYawPitchRoll(v,x,w).multiply(at.Translation(y.x,y.y,y.z)),B=at.Invert(X),S=t.getWorldMatrix(),l=U.multiply(S).multiply(B),T=new Array(3);for(let C=0;C<n.length;C+=3){let E=T;if(E[0]=R(C,l),E[1]=R(C+1,l),E[2]=R(C+2,l),!(e.cullBackFaces&&-E[0].normal.z<=0&&-E[1].normal.z<=0&&-E[2].normal.z<=0)&&(E=L(E,qs),!!E&&(E=L(E,js),!!E&&(E=L(E,Qs),!!E&&(E=L(E,Js),!!E&&(E=L(E,$s),!!E&&(E=L(E,ti),!!E)))))))for(let Y=0;Y<E.length;Y++){const F=E[Y];if(m.indices.push(M),a?(F.localPositionOverride?(m.positions[M*3]=F.localPositionOverride[0],m.positions[M*3+1]=F.localPositionOverride[1],m.positions[M*3+2]=F.localPositionOverride[2]):f&&(m.positions[M*3]=f[F.vertexIdx],m.positions[M*3+1]=f[F.vertexIdx+1],m.positions[M*3+2]=f[F.vertexIdx+2]),F.localNormalOverride?(m.normals[M*3]=F.localNormalOverride[0],m.normals[M*3+1]=F.localNormalOverride[1],m.normals[M*3+2]=F.localNormalOverride[2]):g&&(m.normals[M*3]=g[F.vertexIdx],m.normals[M*3+1]=g[F.vertexIdx+1],m.normals[M*3+2]=g[F.vertexIdx+2])):(F.position.toArray(m.positions,M*3),F.normal.toArray(m.normals,M*3)),m.matricesIndices&&m.matricesWeights&&(F.matrixIndicesOverride?(m.matricesIndices[M*4]=F.matrixIndicesOverride[0],m.matricesIndices[M*4+1]=F.matrixIndicesOverride[1],m.matricesIndices[M*4+2]=F.matrixIndicesOverride[2],m.matricesIndices[M*4+3]=F.matrixIndicesOverride[3]):(u&&(m.matricesIndices[M*4]=u[F.vertexIdxForBones],m.matricesIndices[M*4+1]=u[F.vertexIdxForBones+1],m.matricesIndices[M*4+2]=u[F.vertexIdxForBones+2],m.matricesIndices[M*4+3]=u[F.vertexIdxForBones+3]),d&&m.matricesIndicesExtra&&(m.matricesIndicesExtra[M*4]=d[F.vertexIdxForBones],m.matricesIndicesExtra[M*4+1]=d[F.vertexIdxForBones+1],m.matricesIndicesExtra[M*4+2]=d[F.vertexIdxForBones+2],m.matricesIndicesExtra[M*4+3]=d[F.vertexIdxForBones+3])),F.matrixWeightsOverride?(m.matricesWeights[M*4]=F.matrixWeightsOverride[0],m.matricesWeights[M*4+1]=F.matrixWeightsOverride[1],m.matricesWeights[M*4+2]=F.matrixWeightsOverride[2],m.matricesWeights[M*4+3]=F.matrixWeightsOverride[3]):(_&&(m.matricesWeights[M*4]=_[F.vertexIdxForBones],m.matricesWeights[M*4+1]=_[F.vertexIdxForBones+1],m.matricesWeights[M*4+2]=_[F.vertexIdxForBones+2],m.matricesWeights[M*4+3]=_[F.vertexIdxForBones+3]),A&&m.matricesWeightsExtra&&(m.matricesWeightsExtra[M*4]=A[F.vertexIdxForBones],m.matricesWeightsExtra[M*4+1]=A[F.vertexIdxForBones+1],m.matricesWeightsExtra[M*4+2]=A[F.vertexIdxForBones+2],m.matricesWeightsExtra[M*4+3]=A[F.vertexIdxForBones+3]))),e.captureUVS)F.uv.toArray(m.uvs,M*2);else{m.uvs.push(.5+F.position.x/I.x);const H=.5+F.position.y/I.y;m.uvs.push(H)}M++}}}m.indices.length===0&&(m.indices=null),m.positions.length===0&&(m.positions=null),m.normals.length===0&&(m.normals=null),m.uvs.length===0&&(m.uvs=null),m.matricesIndices?.length===0&&(m.matricesIndices=null),m.matricesWeights?.length===0&&(m.matricesWeights=null),m.matricesIndicesExtra?.length===0&&(m.matricesIndicesExtra=null),m.matricesWeightsExtra?.length===0&&(m.matricesWeightsExtra=null);const G=new O(r,t.getScene());return m.applyToMesh(G),a?(G.skeleton=t.skeleton,G.parent=t):(G.position=y.clone(),G.rotation=new P(x,v,w)),G.computeWorldMatrix(!0),G.refreshBoundingInfo(!0,!0),G}O.CreateDecal=(r,t,e,s,i,a)=>cs(r,t,{position:e,normal:s,size:i,angle:a});function ls(r={subdivisions:2,tessellation:16,height:1,radius:.25,capSubdivisions:6}){const t=Math.max(r.subdivisions?r.subdivisions:2,1)|0,e=Math.max(r.tessellation?r.tessellation:16,3)|0,s=Math.max(r.height?r.height:1,0),i=Math.max(r.radius?r.radius:.25,0),a=Math.max(r.capSubdivisions?r.capSubdivisions:6,1)|0,n=e,o=t,c=Math.max(r.radiusTop?r.radiusTop:i,0),f=Math.max(r.radiusBottom?r.radiusBottom:i,0),g=s-(c+f),h=0,u=2*Math.PI,_=Math.max(r.topCapSubdivisions?r.topCapSubdivisions:a,1),d=Math.max(r.bottomCapSubdivisions?r.bottomCapSubdivisions:a,1),A=Math.acos((f-c)/s);let y=[];const b=[],I=[],w=[];let v=0;const p=[],x=g*.5,m=Math.PI*.5;let M,R;const D=P.Zero(),L=P.Zero(),V=Math.cos(A),N=Math.sin(A),q=new rt(c*N,x+c*V).subtract(new rt(f*N,-x+f*V)).length(),U=c*A+q+f*(m-A);let G=0;for(R=0;R<=_;R++){const S=[],l=m-A*(R/_);G+=c*A/_;const T=Math.cos(l),C=Math.sin(l),E=T*c;for(M=0;M<=n;M++){const Y=M/n,F=Y*u+h,H=Math.sin(F),$=Math.cos(F);L.x=E*H,L.y=x+C*c,L.z=E*$,b.push(L.x,L.y,L.z),D.set(T*H,C,T*$),I.push(D.x,D.y,D.z),w.push(Y,1-G/U),S.push(v),v++}p.push(S)}const z=s-c-f+V*c-V*f,X=N*(f-c)/z;for(R=1;R<=o;R++){const S=[];G+=q/o;const l=N*(R*(f-c)/o+c);for(M=0;M<=n;M++){const T=M/n,C=T*u+h,E=Math.sin(C),Y=Math.cos(C);L.x=l*E,L.y=x+V*c-R*z/o,L.z=l*Y,b.push(L.x,L.y,L.z),D.set(E,X,Y).normalize(),I.push(D.x,D.y,D.z),w.push(T,1-G/U),S.push(v),v++}p.push(S)}for(R=1;R<=d;R++){const S=[],l=m-A-(Math.PI-A)*(R/d);G+=f*A/d;const T=Math.cos(l),C=Math.sin(l),E=T*f;for(M=0;M<=n;M++){const Y=M/n,F=Y*u+h,H=Math.sin(F),$=Math.cos(F);L.x=E*H,L.y=-x+C*f,L.z=E*$,b.push(L.x,L.y,L.z),D.set(T*H,C,T*$),I.push(D.x,D.y,D.z),w.push(Y,1-G/U),S.push(v),v++}p.push(S)}for(M=0;M<n;M++)for(R=0;R<_+o+d;R++){const S=p[R][M],l=p[R+1][M],T=p[R+1][M+1],C=p[R][M+1];y.push(S),y.push(l),y.push(C),y.push(l),y.push(T),y.push(C)}if(y=y.reverse(),r.orientation&&!r.orientation.equals(P.Up())){const S=new at;r.orientation.clone().scale(Math.PI*.5).cross(P.Up()).toQuaternion().toRotationMatrix(S);const l=P.Zero();for(let T=0;T<b.length;T+=3)l.set(b[T],b[T+1],b[T+2]),P.TransformCoordinatesToRef(l.clone(),S,l),b[T]=l.x,b[T+1]=l.y,b[T+2]=l.z}const B=new k;return B.positions=b,B.normals=I,B.uvs=w,B.indices=y,B}function us(r,t={orientation:P.Up(),subdivisions:2,tessellation:16,height:1,radius:.25,capSubdivisions:6,updatable:!1},e=null){const s=new O(r,e);return ls(t).applyToMesh(s,t.updatable),s}O.CreateCapsule=(r,t,e)=>us(r,t,e);k.CreateCapsule=ls;class et{constructor(t=0,e=0){this.x=t,this.y=e,t!==Math.floor(t)&&(t=Math.floor(t),dt.Warn("x is not an integer, floor(x) used")),e!==Math.floor(e)&&(e=Math.floor(e),dt.Warn("y is not an integer, floor(y) used"))}clone(){return new et(this.x,this.y)}rotate60About(t){const e=this.x;return this.x=t.x+t.y-this.y,this.y=e+this.y-t.x,this}rotateNeg60About(t){const e=this.x;return this.x=e+this.y-t.y,this.y=t.x+t.y-e,this}rotate120(t,e){t!==Math.floor(t)&&(t=Math.floor(t),dt.Warn("m not an integer only floor(m) used")),e!==Math.floor(e)&&(e=Math.floor(e),dt.Warn("n not an integer only floor(n) used"));const s=this.x;return this.x=t-s-this.y,this.y=e+s,this}rotateNeg120(t,e){t!==Math.floor(t)&&(t=Math.floor(t),dt.Warn("m is not an integer, floor(m) used")),e!==Math.floor(e)&&(e=Math.floor(e),dt.Warn("n is not an integer,   floor(n) used"));const s=this.x;return this.x=this.y-e,this.y=t+e-s-this.y,this}toCartesianOrigin(t,e){const s=P.Zero();return s.x=t.x+2*this.x*e+this.y*e,s.y=t.y+Math.sqrt(3)*this.y*e,s}static Zero(){return new et(0,0)}}class ds{constructor(){this.cartesian=[],this.vertices=[],this.max=[],this.min=[],this.closestTo=[],this.innerFacets=[],this.isoVecsABOB=[],this.isoVecsOBOA=[],this.isoVecsBAOA=[],this.vertexTypes=[],this.IDATA=new ne("icosahedron","Regular",[[0,nt,-1],[-nt,1,0],[-1,0,-nt],[1,0,-nt],[nt,1,0],[0,nt,1],[-1,0,nt],[-nt,-1,0],[0,-nt,-1],[nt,-1,0],[1,0,nt],[0,-nt,1]],[[0,2,1],[0,3,2],[0,4,3],[0,5,4],[0,1,5],[7,6,1],[8,7,2],[9,8,3],[10,9,4],[6,10,5],[2,7,1],[3,8,2],[4,9,3],[5,10,4],[1,6,5],[11,6,7],[11,7,8],[11,8,9],[11,9,10],[11,10,6]])}setIndices(){let t=12;const e={},s=this.m,i=this.n;let a=s,n=1,o=0;i!==0&&(a=ye(s,i)),n=s/a,o=i/a;let c,f,g,h,u;const _=et.Zero(),d=new et(s,i),A=new et(-i,s+i),y=et.Zero(),b=et.Zero(),I=et.Zero();let w=[],v,p,x,m;const M=[],R=this.vertByDist,D=(L,V,N,q)=>{v=L+"|"+N,p=V+"|"+q,v in e||p in e?v in e&&!(p in e)?e[p]=e[v]:p in e&&!(v in e)&&(e[v]=e[p]):(e[v]=t,e[p]=t,t++),R[N][0]>2?M[e[v]]=[-R[N][0],R[N][1],e[v]]:M[e[v]]=[w[R[N][0]],R[N][1],e[v]]};this.IDATA.edgematch=[[1,"B"],[2,"B"],[3,"B"],[4,"B"],[0,"B"],[10,"O",14,"A"],[11,"O",10,"A"],[12,"O",11,"A"],[13,"O",12,"A"],[14,"O",13,"A"],[0,"O"],[1,"O"],[2,"O"],[3,"O"],[4,"O"],[19,"B",5,"A"],[15,"B",6,"A"],[16,"B",7,"A"],[17,"B",8,"A"],[18,"B",9,"A"]];for(let L=0;L<20;L++){if(w=this.IDATA.face[L],g=w[2],h=w[1],u=w[0],x=_.x+"|"+_.y,v=L+"|"+x,v in e||(e[v]=g,M[g]=[w[R[x][0]],R[x][1]]),x=d.x+"|"+d.y,v=L+"|"+x,v in e||(e[v]=h,M[h]=[w[R[x][0]],R[x][1]]),x=A.x+"|"+A.y,v=L+"|"+x,v in e||(e[v]=u,M[u]=[w[R[x][0]],R[x][1]]),c=this.IDATA.edgematch[L][0],f=this.IDATA.edgematch[L][1],f==="B")for(let V=1;V<a;V++)b.x=s-V*(n+o),b.y=i+V*n,I.x=-V*o,I.y=V*(n+o),x=b.x+"|"+b.y,m=I.x+"|"+I.y,D(L,c,x,m);if(f==="O")for(let V=1;V<a;V++)I.x=-V*o,I.y=V*(n+o),y.x=V*n,y.y=V*o,x=I.x+"|"+I.y,m=y.x+"|"+y.y,D(L,c,x,m);if(c=this.IDATA.edgematch[L][2],f=this.IDATA.edgematch[L][3],f&&f==="A")for(let V=1;V<a;V++)y.x=V*n,y.y=V*o,b.x=s-(a-V)*(n+o),b.y=i+(a-V)*n,x=y.x+"|"+y.y,m=b.x+"|"+b.y,D(L,c,x,m);for(let V=0;V<this.vertices.length;V++)x=this.vertices[V].x+"|"+this.vertices[V].y,v=L+"|"+x,v in e||(e[v]=t++,R[x][0]>2?M[e[v]]=[-R[x][0],R[x][1],e[v]]:M[e[v]]=[w[R[x][0]],R[x][1],e[v]])}this.closestTo=M,this.vecToidx=e}calcCoeffs(){const t=this.m,e=this.n,s=Math.sqrt(3)/3,i=t*t+e*e+t*e;this.coau=(t+e)/i,this.cobu=-e/i,this.coav=-s*(t-e)/i,this.cobv=s*(2*t+e)/i}createInnerFacets(){const t=this.m,e=this.n;for(let s=0;s<e+t+1;s++)for(let i=this.min[s];i<this.max[s]+1;i++)i<this.max[s]&&i<this.max[s+1]+1&&this.innerFacets.push(["|"+i+"|"+s,"|"+i+"|"+(s+1),"|"+(i+1)+"|"+s]),s>0&&i<this.max[s-1]&&i+1<this.max[s]+1&&this.innerFacets.push(["|"+i+"|"+s,"|"+(i+1)+"|"+s,"|"+(i+1)+"|"+(s-1)])}edgeVecsABOB(){const t=this.m,e=this.n,s=new et(-e,t+e);for(let i=1;i<t+e;i++){const a=new et(this.min[i],i),n=new et(this.min[i-1],i-1),o=new et(this.min[i+1],i+1),c=a.clone(),f=n.clone(),g=o.clone();c.rotate60About(s),f.rotate60About(s),g.rotate60About(s);const h=new et(this.max[c.y],c.y),u=new et(this.max[c.y-1],c.y-1),_=new et(this.max[c.y-1]-1,c.y-1);(c.x!==h.x||c.y!==h.y)&&(c.x!==u.x?(this.vertexTypes.push([1,0,0]),this.isoVecsABOB.push([a,u,_]),this.vertexTypes.push([1,0,0]),this.isoVecsABOB.push([a,_,h])):c.y===g.y?(this.vertexTypes.push([1,1,0]),this.isoVecsABOB.push([a,n,u]),this.vertexTypes.push([1,0,1]),this.isoVecsABOB.push([a,u,o])):(this.vertexTypes.push([1,1,0]),this.isoVecsABOB.push([a,n,u]),this.vertexTypes.push([1,0,0]),this.isoVecsABOB.push([a,u,h])))}}mapABOBtoOBOA(){const t=new et(0,0);for(let e=0;e<this.isoVecsABOB.length;e++){const s=[];for(let i=0;i<3;i++)t.x=this.isoVecsABOB[e][i].x,t.y=this.isoVecsABOB[e][i].y,this.vertexTypes[e][i]===0&&t.rotateNeg120(this.m,this.n),s.push(t.clone());this.isoVecsOBOA.push(s)}}mapABOBtoBAOA(){const t=new et(0,0);for(let e=0;e<this.isoVecsABOB.length;e++){const s=[];for(let i=0;i<3;i++)t.x=this.isoVecsABOB[e][i].x,t.y=this.isoVecsABOB[e][i].y,this.vertexTypes[e][i]===1&&t.rotate120(this.m,this.n),s.push(t.clone());this.isoVecsBAOA.push(s)}}MapToFace(t,e){const s=this.IDATA.face[t],i=s[2],a=s[1],n=s[0],o=P.FromArray(this.IDATA.vertex[i]),c=P.FromArray(this.IDATA.vertex[a]),f=P.FromArray(this.IDATA.vertex[n]),g=c.subtract(o),h=f.subtract(o),u=g.scale(this.coau).add(h.scale(this.cobu)),_=g.scale(this.coav).add(h.scale(this.cobv));let d,A=st.Vector3[0];for(let y=0;y<this.cartesian.length;y++)A=u.scale(this.cartesian[y].x).add(_.scale(this.cartesian[y].y)).add(o),A.x,A.y,A.z,d=t+"|"+this.vertices[y].x+"|"+this.vertices[y].y,e.vertex[this.vecToidx[d]]=[A.x,A.y,A.z]}build(t,e){const s=[],i=et.Zero(),a=new et(t,e),n=new et(-e,t+e);s.push(i,a,n);for(let p=e;p<t+1;p++)for(let x=0;x<t+1-p;x++)s.push(new et(x,p));if(e>0){const p=ye(t,e),x=t/p,m=e/p;for(let R=1;R<p;R++)s.push(new et(R*x,R*m)),s.push(new et(-R*m,R*(x+m))),s.push(new et(t-R*(x+m),e+R*x));const M=t/e;for(let R=1;R<e;R++)for(let D=0;D<R*M;D++)s.push(new et(D,R)),s.push(new et(D,R).rotate120(t,e)),s.push(new et(D,R).rotateNeg120(t,e))}s.sort((p,x)=>p.x-x.x),s.sort((p,x)=>p.y-x.y);const o=new Array(t+e+1),c=new Array(t+e+1);for(let p=0;p<o.length;p++)o[p]=1/0,c[p]=-1/0;let f=0,g=0;const h=s.length;for(let p=0;p<h;p++)g=s[p].x,f=s[p].y,o[f]=Math.min(g,o[f]),c[f]=Math.max(g,c[f]);const u=(p,x)=>{const m=p.clone();return x==="A"&&m.rotateNeg120(t,e),x==="B"&&m.rotate120(t,e),m.x<0?m.y:m.x+m.y},_=[],d=[],A=[],y=[],b={},I=[];let w=-1,v=-1;for(let p=0;p<h;p++)_[p]=s[p].toCartesianOrigin(new et(0,0),.5),d[p]=u(s[p],"O"),A[p]=u(s[p],"A"),y[p]=u(s[p],"B"),d[p]===A[p]&&A[p]===y[p]?(w=3,v=d[p]):d[p]===A[p]?(w=4,v=d[p]):A[p]===y[p]?(w=5,v=A[p]):y[p]===d[p]&&(w=6,v=d[p]),d[p]<A[p]&&d[p]<y[p]&&(w=2,v=d[p]),A[p]<d[p]&&A[p]<y[p]&&(w=1,v=A[p]),y[p]<A[p]&&y[p]<d[p]&&(w=0,v=y[p]),I.push([w,v,s[p].x,s[p].y]);I.sort((p,x)=>p[2]-x[2]),I.sort((p,x)=>p[3]-x[3]),I.sort((p,x)=>p[1]-x[1]),I.sort((p,x)=>p[0]-x[0]);for(let p=0;p<I.length;p++)b[I[p][2]+"|"+I[p][3]]=[I[p][0],I[p][1],p];return this.m=t,this.n=e,this.vertices=s,this.vertByDist=b,this.cartesian=_,this.min=o,this.max=c,this}}class ne{constructor(t,e,s,i){this.name=t,this.category=e,this.vertex=s,this.face=i}}class qt extends ne{innerToData(t,e){for(let s=0;s<e.innerFacets.length;s++)this.face.push(e.innerFacets[s].map(i=>e.vecToidx[t+i]))}mapABOBtoDATA(t,e){const s=e.IDATA.edgematch[t][0];for(let i=0;i<e.isoVecsABOB.length;i++){const a=[];for(let n=0;n<3;n++)e.vertexTypes[i][n]===0?a.push(t+"|"+e.isoVecsABOB[i][n].x+"|"+e.isoVecsABOB[i][n].y):a.push(s+"|"+e.isoVecsABOB[i][n].x+"|"+e.isoVecsABOB[i][n].y);this.face.push([e.vecToidx[a[0]],e.vecToidx[a[1]],e.vecToidx[a[2]]])}}mapOBOAtoDATA(t,e){const s=e.IDATA.edgematch[t][0];for(let i=0;i<e.isoVecsOBOA.length;i++){const a=[];for(let n=0;n<3;n++)e.vertexTypes[i][n]===1?a.push(t+"|"+e.isoVecsOBOA[i][n].x+"|"+e.isoVecsOBOA[i][n].y):a.push(s+"|"+e.isoVecsOBOA[i][n].x+"|"+e.isoVecsOBOA[i][n].y);this.face.push([e.vecToidx[a[0]],e.vecToidx[a[1]],e.vecToidx[a[2]]])}}mapBAOAtoDATA(t,e){const s=e.IDATA.edgematch[t][2];for(let i=0;i<e.isoVecsBAOA.length;i++){const a=[];for(let n=0;n<3;n++)e.vertexTypes[i][n]===1?a.push(t+"|"+e.isoVecsBAOA[i][n].x+"|"+e.isoVecsBAOA[i][n].y):a.push(s+"|"+e.isoVecsBAOA[i][n].x+"|"+e.isoVecsBAOA[i][n].y);this.face.push([e.vecToidx[a[0]],e.vecToidx[a[1]],e.vecToidx[a[2]]])}}orderData(t){const e=[];for(let n=0;n<13;n++)e[n]=[];const s=t.closestTo;for(let n=0;n<s.length;n++)s[n][0]>-1?s[n][1]>0&&e[s[n][0]].push([n,s[n][1]]):e[12].push([n,s[n][0]]);const i=[];for(let n=0;n<12;n++)i[n]=n;let a=12;for(let n=0;n<12;n++){e[n].sort((o,c)=>o[1]-c[1]);for(let o=0;o<e[n].length;o++)i[e[n][o][0]]=a++}for(let n=0;n<e[12].length;n++)i[e[12][n][0]]=a++;for(let n=0;n<this.vertex.length;n++)this.vertex[n].push(i[n]);this.vertex.sort((n,o)=>n[3]-o[3]);for(let n=0;n<this.vertex.length;n++)this.vertex[n].pop();for(let n=0;n<this.face.length;n++)for(let o=0;o<this.face[n].length;o++)this.face[n][o]=i[this.face[n][o]];this.sharedNodes=e[12].length,this.poleNodes=this.vertex.length-this.sharedNodes}setOrder(t,e){const s=[],i=[];let a=e.pop();i.push(a);let n=this.face[a].indexOf(t);n=(n+2)%3;let o=this.face[a][n];s.push(o);let c=0;for(;e.length>0;)a=e[c],this.face[a].indexOf(o)>-1?(n=(this.face[a].indexOf(o)+1)%3,o=this.face[a][n],s.push(o),i.push(a),e.splice(c,1),c=0):c++;return this.adjacentFaces.push(s),i}toGoldbergPolyhedronData(){const t=new ne("GeoDual","Goldberg",[],[]);t.name="GD dual";const e=this.vertex.length,s=new Array(e);for(let f=0;f<e;f++)s[f]=[];for(let f=0;f<this.face.length;f++)for(let g=0;g<3;g++)s[this.face[f][g]].push(f);let i=0,a=0,n=0,o=[],c=[];this.adjacentFaces=[];for(let f=0;f<s.length;f++){t.face[f]=this.setOrder(f,s[f].concat([]));for(const g of s[f]){i=0,a=0,n=0,o=this.face[g];for(let h=0;h<3;h++)c=this.vertex[o[h]],i+=c[0],a+=c[1],n+=c[2];t.vertex[g]=[i/3,a/3,n/3]}}return t}static BuildGeodesicData(t){const e=new qt("Geodesic-m-n","Geodesic",[[0,nt,-1],[-nt,1,0],[-1,0,-nt],[1,0,-nt],[nt,1,0],[0,nt,1],[-1,0,nt],[-nt,-1,0],[0,-nt,-1],[nt,-1,0],[1,0,nt],[0,-nt,1]],[]);t.setIndices(),t.calcCoeffs(),t.createInnerFacets(),t.edgeVecsABOB(),t.mapABOBtoOBOA(),t.mapABOBtoBAOA();for(let i=0;i<t.IDATA.face.length;i++)t.MapToFace(i,e),e.innerToData(i,t),t.IDATA.edgematch[i][1]==="B"&&e.mapABOBtoDATA(i,t),t.IDATA.edgematch[i][1]==="O"&&e.mapOBOAtoDATA(i,t),t.IDATA.edgematch[i][3]==="A"&&e.mapBAOAtoDATA(i,t);e.orderData(t);const s=1;return e.vertex=e.vertex.map(function(i){const a=i[0],n=i[1],o=i[2],c=Math.sqrt(a*a+n*n+o*o);return i[0]*=s/c,i[1]*=s/c,i[2]*=s/c,i}),e}}function ei(r,t,e=null){let s=t.m||1;s!==Math.floor(s)&&(s=Math.floor(s),dt.Warn("m not an integer only floor(m) used"));let i=t.n||0;if(i!==Math.floor(i)&&(i=Math.floor(i),dt.Warn("n not an integer only floor(n) used")),i>s){const f=i;i=s,s=f,dt.Warn("n > m therefore m and n swapped")}const a=new ds;a.build(s,i);const o={custom:qt.BuildGeodesicData(a),size:t.size,sizeX:t.sizeX,sizeY:t.sizeY,sizeZ:t.sizeZ,faceUV:t.faceUV,faceColors:t.faceColors,flat:t.flat,updatable:t.updatable,sideOrientation:t.sideOrientation,frontUVs:t.frontUVs,backUVs:t.backUVs};return ue(r,o,e)}O._GoldbergMeshParser=(r,t)=>jt.Parse(r,t);class jt extends O{constructor(){super(...arguments),this.goldbergData={faceColors:[],faceCenters:[],faceZaxis:[],faceXaxis:[],faceYaxis:[],nbSharedFaces:0,nbUnsharedFaces:0,nbFaces:0,nbFacesAtPole:0,adjacentFaces:[]}}relatedGoldbergFace(t,e){return e===void 0?(t>this.goldbergData.nbUnsharedFaces-1&&(dt.Warn("Maximum number of unshared faces used"),t=this.goldbergData.nbUnsharedFaces-1),this.goldbergData.nbUnsharedFaces+t):(t>11&&(dt.Warn("Last pole used"),t=11),e>this.goldbergData.nbFacesAtPole-1&&(dt.Warn("Maximum number of faces at a pole used"),e=this.goldbergData.nbFacesAtPole-1),12+t*this.goldbergData.nbFacesAtPole+e)}_changeGoldbergFaceColors(t){for(let s=0;s<t.length;s++){const i=t[s][0],a=t[s][1],n=t[s][2];for(let o=i;o<a+1;o++)this.goldbergData.faceColors[o]=n}const e=[];for(let s=0;s<12;s++)for(let i=0;i<5;i++)e.push(this.goldbergData.faceColors[s].r,this.goldbergData.faceColors[s].g,this.goldbergData.faceColors[s].b,this.goldbergData.faceColors[s].a);for(let s=12;s<this.goldbergData.faceColors.length;s++)for(let i=0;i<6;i++)e.push(this.goldbergData.faceColors[s].r,this.goldbergData.faceColors[s].g,this.goldbergData.faceColors[s].b,this.goldbergData.faceColors[s].a);return e}setGoldbergFaceColors(t){const e=this._changeGoldbergFaceColors(t);this.setVerticesData(Q.ColorKind,e)}updateGoldbergFaceColors(t){const e=this._changeGoldbergFaceColors(t);this.updateVerticesData(Q.ColorKind,e)}_changeGoldbergFaceUVs(t){const e=this.getVerticesData(Q.UVKind);for(let s=0;s<t.length;s++){const i=t[s][0],a=t[s][1],n=t[s][2],o=t[s][3],c=t[s][4],f=[],g=[];let h,u;for(let _=0;_<5;_++)h=n.x+o*Math.cos(c+_*Math.PI/2.5),u=n.y+o*Math.sin(c+_*Math.PI/2.5),h<0&&(h=0),h>1&&(h=1),f.push(h,u);for(let _=0;_<6;_++)h=n.x+o*Math.cos(c+_*Math.PI/3),u=n.y+o*Math.sin(c+_*Math.PI/3),h<0&&(h=0),h>1&&(h=1),g.push(h,u);for(let _=i;_<Math.min(12,a+1);_++)for(let d=0;d<5;d++)e[10*_+2*d]=f[2*d],e[10*_+2*d+1]=f[2*d+1];for(let _=Math.max(12,i);_<a+1;_++)for(let d=0;d<6;d++)e[12*_-24+2*d]=g[2*d],e[12*_-23+2*d]=g[2*d+1]}return e}setGoldbergFaceUVs(t){const e=this._changeGoldbergFaceUVs(t);this.setVerticesData(Q.UVKind,e)}updateGoldbergFaceUVs(t){const e=this._changeGoldbergFaceUVs(t);this.updateVerticesData(Q.UVKind,e)}placeOnGoldbergFaceAt(t,e,s){const i=P.RotationFromAxis(this.goldbergData.faceXaxis[e],this.goldbergData.faceYaxis[e],this.goldbergData.faceZaxis[e]);t.rotation=i,t.position=this.goldbergData.faceCenters[e].add(this.goldbergData.faceXaxis[e].scale(s.x)).add(this.goldbergData.faceYaxis[e].scale(s.y)).add(this.goldbergData.faceZaxis[e].scale(s.z))}serialize(t){super.serialize(t),t.type="GoldbergMesh";const e={};if(e.adjacentFaces=this.goldbergData.adjacentFaces,e.nbSharedFaces=this.goldbergData.nbSharedFaces,e.nbUnsharedFaces=this.goldbergData.nbUnsharedFaces,e.nbFaces=this.goldbergData.nbFaces,e.nbFacesAtPole=this.goldbergData.nbFacesAtPole,this.goldbergData.faceColors){e.faceColors=[];for(const s of this.goldbergData.faceColors)e.faceColors.push(s.asArray())}if(this.goldbergData.faceCenters){e.faceCenters=[];for(const s of this.goldbergData.faceCenters)e.faceCenters.push(s.asArray())}if(this.goldbergData.faceZaxis){e.faceZaxis=[];for(const s of this.goldbergData.faceZaxis)e.faceZaxis.push(s.asArray())}if(this.goldbergData.faceYaxis){e.faceYaxis=[];for(const s of this.goldbergData.faceYaxis)e.faceYaxis.push(s.asArray())}if(this.goldbergData.faceXaxis){e.faceXaxis=[];for(const s of this.goldbergData.faceXaxis)e.faceXaxis.push(s.asArray())}t.goldbergData=e}static Parse(t,e){const s=t.goldbergData;s.faceColors=s.faceColors.map(a=>It.FromArray(a)),s.faceCenters=s.faceCenters.map(a=>P.FromArray(a)),s.faceZaxis=s.faceZaxis.map(a=>P.FromArray(a)),s.faceXaxis=s.faceXaxis.map(a=>P.FromArray(a)),s.faceYaxis=s.faceYaxis.map(a=>P.FromArray(a));const i=new jt(t.name,e);return i.goldbergData=s,i}}function si(r,t){const e=r.size,s=r.sizeX||e||1,i=r.sizeY||e||1,a=r.sizeZ||e||1,n=r.sideOrientation===0?0:r.sideOrientation||k.DEFAULTSIDE,o=[],c=[],f=[],g=[];let h=1/0,u=-1/0,_=1/0,d=-1/0;for(let b=0;b<t.vertex.length;b++)h=Math.min(h,t.vertex[b][0]*s),u=Math.max(u,t.vertex[b][0]*s),_=Math.min(_,t.vertex[b][1]*i),d=Math.max(d,t.vertex[b][1]*i);let A=0;for(let b=0;b<t.face.length;b++){const I=t.face[b],w=P.FromArray(t.vertex[I[0]]),v=P.FromArray(t.vertex[I[2]]),p=P.FromArray(t.vertex[I[1]]),x=v.subtract(w),m=p.subtract(w),M=P.Cross(m,x).normalize();for(let R=0;R<I.length;R++){f.push(M.x,M.y,M.z);const D=t.vertex[I[R]];o.push(D[0]*s,D[1]*i,D[2]*a);const L=(D[1]*i-_)/(d-_);g.push((D[0]*s-h)/(u-h),L)}for(let R=0;R<I.length-2;R++)c.push(A,A+R+2,A+R+1);A+=I.length}k._ComputeSides(n,o,c,f,g);const y=new k;return y.positions=o,y.indices=c,y.normals=f,y.uvs=g,y}function ii(r,t,e=null){const s=t.size,i=t.sizeX||s||1,a=t.sizeY||s||1,n=t.sizeZ||s||1;let o=t.m||1;o!==Math.floor(o)&&(o=Math.floor(o),dt.Warn("m not an integer only floor(m) used"));let c=t.n||0;if(c!==Math.floor(c)&&(c=Math.floor(c),dt.Warn("n not an integer only floor(n) used")),c>o){const d=c;c=o,o=d,dt.Warn("n > m therefore m and n swapped")}const f=new ds;f.build(o,c);const g=qt.BuildGeodesicData(f),h=g.toGoldbergPolyhedronData(),u=new jt(r,e);t.sideOrientation=O._GetDefaultSideOrientation(t.sideOrientation),u._originalBuilderSideOrientation=t.sideOrientation,si(t,h).applyToMesh(u,t.updatable),u.goldbergData.nbSharedFaces=g.sharedNodes,u.goldbergData.nbUnsharedFaces=g.poleNodes,u.goldbergData.adjacentFaces=g.adjacentFaces,u.goldbergData.nbFaces=u.goldbergData.nbSharedFaces+u.goldbergData.nbUnsharedFaces,u.goldbergData.nbFacesAtPole=(u.goldbergData.nbUnsharedFaces-12)/12;for(let d=0;d<g.vertex.length;d++)u.goldbergData.faceCenters.push(P.FromArray(g.vertex[d])),u.goldbergData.faceCenters[d].x*=i,u.goldbergData.faceCenters[d].y*=a,u.goldbergData.faceCenters[d].z*=n,u.goldbergData.faceColors.push(new It(1,1,1,1));for(let d=0;d<h.face.length;d++){const A=h.face[d],y=P.FromArray(h.vertex[A[0]]),b=P.FromArray(h.vertex[A[2]]),I=P.FromArray(h.vertex[A[1]]),w=b.subtract(y),v=I.subtract(y),p=P.Cross(v,w).normalize(),x=P.Cross(v,p).normalize();u.goldbergData.faceXaxis.push(v.normalize()),u.goldbergData.faceYaxis.push(p),u.goldbergData.faceZaxis.push(x)}return u}class ai{constructor(t){this._paths=[],this._tempPaths=[],this._holes=[],this._resolution=t}moveTo(t,e){this._currentPath=new Ce(t,e),this._tempPaths.push(this._currentPath)}lineTo(t,e){this._currentPath.addLineTo(t,e)}quadraticCurveTo(t,e,s,i){this._currentPath.addQuadraticCurveTo(t,e,s,i,this._resolution)}bezierCurveTo(t,e,s,i,a,n){this._currentPath.addBezierCurveTo(t,e,s,i,a,n,this._resolution)}extractHoles(){for(const t of this._tempPaths)t.area()>0?this._holes.push(t):this._paths.push(t);if(!this._paths.length&&this._holes.length){const t=this._holes;this._holes=this._paths,this._paths=t}this._tempPaths.length=0}get paths(){return this._paths}get holes(){return this._holes}}function ni(r,t,e,s,i,a){const n=a.glyphs[r]||a.glyphs["?"];if(!n)return null;const o=new ai(i);if(n.o){const c=n.o.split(" ");for(let f=0,g=c.length;f<g;)switch(c[f++]){case"m":{const u=parseInt(c[f++])*t+e,_=parseInt(c[f++])*t+s;o.moveTo(u,_);break}case"l":{const u=parseInt(c[f++])*t+e,_=parseInt(c[f++])*t+s;o.lineTo(u,_);break}case"q":{const u=parseInt(c[f++])*t+e,_=parseInt(c[f++])*t+s,d=parseInt(c[f++])*t+e,A=parseInt(c[f++])*t+s;o.quadraticCurveTo(d,A,u,_);break}case"b":{const u=parseInt(c[f++])*t+e,_=parseInt(c[f++])*t+s,d=parseInt(c[f++])*t+e,A=parseInt(c[f++])*t+s,y=parseInt(c[f++])*t+e,b=parseInt(c[f++])*t+s;o.bezierCurveTo(d,A,y,b,u,_);break}}}return o.extractHoles(),{offsetX:n.ha*t,shapePath:o}}function ri(r,t,e,s){const i=Array.from(r),a=t/s.resolution,n=(s.boundingBox.yMax-s.boundingBox.yMin+s.underlineThickness)*a,o=[];let c=0,f=0;for(let g=0;g<i.length;g++){const h=i[g];if(h===`
`)c=0,f-=n;else{const u=ni(h,a,c,f,e,s);u&&(c+=u.offsetX,o.push(u.shapePath))}}return o}function oi(r,t,e,s={size:50,resolution:8,depth:1},i=null,a=earcut){const n=ri(t,s.size||50,s.resolution||8,e),o=[];let c=0;for(const g of n){if(!g.paths.length)continue;const h=g.holes.slice();for(const u of g.paths){const _=[],d=[],A=u.getPoints();for(const I of A)d.push(new P(I.x,0,I.y));const y=h.slice();for(const I of y){const w=I.getPoints();let v=!1;for(const x of w)if(u.isPointInside(x)){v=!0;break}if(!v)continue;const p=[];for(const x of w)p.push(new P(x.x,0,x.y));_.push(p),h.splice(h.indexOf(I),1)}if(!_.length&&h.length)for(const I of h){const w=I.getPoints(),v=[];for(const p of w)v.push(new P(p.x,0,p.y));_.push(v)}const b=le(r,{shape:d,holes:_.length?_:void 0,depth:s.depth||1,faceUV:s.faceUV||s.perLetterFaceUV?.(c),faceColors:s.faceColors||s.perLetterFaceColors?.(c),sideOrientation:O._GetDefaultSideOrientation(s.sideOrientation||O.DOUBLESIDE)},i,a);o.push(b),c++}}const f=O.MergeMeshes(o,!0,!0);if(f){const g=f.getBoundingInfo().boundingBox;f.position.x+=-(g.minimumWorld.x+g.maximumWorld.x)/2,f.position.y+=-(g.minimumWorld.y+g.maximumWorld.y)/2,f.position.z+=-(g.minimumWorld.z+g.maximumWorld.z)/2+g.extendSize.z,f.name=r;const h=new Ns("pivot",i);h.rotation.x=-Math.PI/2,f.parent=h,f.bakeCurrentTransformIntoVertices(),f.parent=null,h.dispose()}return f}const ci={CreateBox:Ve,CreateTiledBox:Zs,CreateSphere:ke,CreateDisc:Re,CreateIcoSphere:hs,CreateRibbon:Dt,CreateCylinder:We,CreateTorus:Ye,CreateTorusKnot:He,CreateLineSystem:qe,CreateLines:je,CreateDashedLines:Qe,ExtrudeShape:$e,ExtrudeShapeCustom:ts,CreateLathe:ss,CreateTiledPlane:Ys,CreatePlane:as,CreateGround:Be,CreateTiledGround:Ee,CreateGroundFromHeightMap:Le,CreatePolygon:ce,ExtrudePolygon:le,CreateTube:ns,CreatePolyhedron:ue,CreateGeodesic:ei,CreateGoldberg:ii,CreateDecal:cs,CreateCapsule:us,CreateText:oi};export{tt as A,Kt as H,ci as M};
